# ARIA COMPILER - PRODUCTION-READY BETA ROADMAP
**Target**: Production-Quality Beta (Ready for Alpha Testing)  
**Current Version**: v0.0.9 (Clean Architecture)  
**Date Created**: December 11, 2025  
**Estimated Timeline**: 6-12 months (with parallel research/implementation)

---

## üìã TABLE OF CONTENTS

1. [Phase 0: Research Foundation](#phase-0-research-foundation)
2. [Phase 1: Core Type System Completion](#phase-1-core-type-system-completion)
3. [Phase 2: Memory Safety & Borrow Checking](#phase-2-memory-safety--borrow-checking)
4. [Phase 3: Module System & Visibility](#phase-3-module-system--visibility)
5. [Phase 4: Generics & Monomorphization](#phase-4-generics--monomorphization)
6. [Phase 5: Standard Library - Core](#phase-5-standard-library---core)
7. [Phase 6: Standard Library - I/O](#phase-6-standard-library---io)
8. [Phase 7: Standard Library - Concurrency](#phase-7-standard-library---concurrency)
9. [Phase 8: Advanced Features](#phase-8-advanced-features)
10. [Phase 9: Optimization & Polish](#phase-9-optimization--polish)
11. [Phase 10: Testing & Validation](#phase-10-testing--validation)
12. [Phase 11: Documentation & Release](#phase-11-documentation--release)

---

## PHASE 0: Research Foundation
**Goal**: Fill critical knowledge gaps via Gemini research  
**Timeline**: 1-2 weeks (parallel to Phase 1 implementation)  
**Status**: Research system ready, tasks defined

### 0.1 Critical Research (BLOCKING)
- [x] **research_001: Borrow Checker Implementation** ‚úÖ COMPLETE (406 lines)
  - [x] Upload source compilations to Gemini (9 files)
  - [x] Review response document
  - [x] Extract lifetime analysis algorithm
  - [x] Extract borrow checking rules
  - [x] Extract integration strategy with Appendage Theory
  - [x] Document: `/docs/gemini/responses/research_001_borrow_checker.txt`
  - [ ] **TODO**: Extract implementation plan for Phase 2

- [x] **research_002: Balanced Ternary Arithmetic** ‚úÖ COMPLETE + IMPLEMENTED
  - [x] Upload source compilations to Gemini (7 files)
  - [x] Review response document (54KB received)
  - [x] Extract ternary arithmetic algorithms
  - [x] Extract trit/tryte packing strategy (10 trits in uint16)
  - [x] Extract binary‚Üîternary conversion algorithms
  - [x] Document: `/docs/gemini/responses/research_002_balanced_ternary_arithmetic.txt`
  - [x] **IMPLEMENTATION**: Phases 1-6 complete on `dev/balanced-ternary` branch
    * Phase 1: Type system (TypeKind::TRIT, TRYTE)
    * Phase 2: Runtime (561 lines) - TernaryOps class, packing/unpacking
    * Phase 3: LLVM codegen (456 lines) - TernaryLowerer class
    * Phase 4: Testing (20/20 passing) - Full arithmetic validation
    * Phase 5: Documentation (640 lines) - STATUS.md + FINAL_REPORT.md
    * Phase 6: Partial (backend done, BLOCKED on parser expression support)

- [x] **research_003: Balanced Nonary Arithmetic** ‚úÖ COMPLETE + IMPLEMENTED (Dec 11, 2025)
  - [x] Upload source compilations to Gemini (7 files)
  - [x] Review response document (59KB received)
  - [x] Extract nonary arithmetic algorithms
    * **Key Finding**: Biased-Radix Packing (value + 29524)
    * Addition: `A + B - bias` (3-5 cycles)
    * Comparison: Works directly on packed values (monotonic!)
    * Performance: 50-70% of native int16 with safety
  - [x] Extract nit/nyte packing strategy (5 nits in uint16)
    * 9^5 = 59,049 values ‚Üí 90.1% efficiency in uint16
    * 6,487 spare code points ‚Üí ERR sentinel for free!
    * Zero = 0x7354, ERR = 0xFFFF
  - [x] Extract binary‚Üînonary conversion algorithms
    * SIMD-friendly operations (8 nytes per SSE register)
  - [x] Document findings: `/docs/gemini/responses/research_003_balanced_nonary_arithmetic.txt`
  - [x] **IMPLEMENTATION**: Complete on `main` branch (v0.0.12)
    * Runtime: 360 lines (NonaryOps class) - biased-radix packing
    * Codegen: 242 lines (NonaryLowerer class) - LLVM integration
    * C Runtime: 91 lines - external linkage wrappers
    * Testing: 26/26 passing - full coverage
    * Documentation: BALANCED_NONARY_STATUS.md
    * Timeline: 3.5 hours (as predicted)

### 0.2 High-Priority Research (Important but not blocking)
- [x] **research_004: File I/O Library Design** ‚úÖ COMPLETE (Dec 11, 2025)
  - [x] Upload compilations (8 files)
  - [x] Review response document (933 lines received)
  - [x] Extract API design
    * **Key Finding**: Multi-layered I/O with RAII-compliant File struct
    * Builder pattern for file operations
    * TBB-integrated error handling (sticky ERR propagation)
    * Hybrid async runtime (io_uring on Linux, IOCP on Windows)
  - [x] Extract error handling patterns
    * Result types: {err, val} for all I/O operations
    * TBB types for offsets/sizes (overflow ‚Üí ERR)
    * Structured error objects (not just error codes)
  - [x] Extract async integration strategy
    * Zero-copy optimizations with wild buffers
    * Memory-mapped files for high-throughput
    * defer for deterministic resource cleanup
  - [x] Document: `/docs/gemini/responses/research_004_file_io_library.txt`

- [x] **research_005: Process Management Library** ‚úÖ COMPLETE (Dec 11, 2025)
  - [x] Upload compilations
  - [x] Review response document (397 lines received)
  - [x] Extract process API design
    * **Key Finding**: Builder pattern (Command struct)
    * Deprecate fork() for posix_spawn (thread-safe)
    * Windows: CreateProcess + Job Objects + IOCP
  - [x] Extract IPC mechanisms
    * Stdio enum (Inherit, Null, Piped)
    * Fluent API: cmd.arg().env().stdin(Piped)
    * pidfd on Linux 5.3+ (stable, epoll-compatible)
  - [x] Extract cross-platform strategy
    * Unix: posix_spawn (avoids fork deadlocks)
    * Linux: pidfd_open for stable process handles
    * Windows: Job Objects for lifecycle management
    * RAII Child struct (prevents zombie processes)
  - [x] Document: `/docs/gemini/responses/research_005_process_management.txt`

- [x] **research_006: Modern I/O Streams (6-stream system)** ‚úÖ COMPLETE (Dec 11, 2025)
  - [x] Upload compilations
  - [x] Review response document (388 lines received)
  - [x] Extract stream purpose analysis
    * **Key Finding**: 6-stream topology replaces 3-stream Unix model
    * stdin/stdout/stderr: Text (UTF-8) - line buffered
    * stddbg (FD 3): Diagnostic telemetry - async ring buffered
    * stddati (FD 4): Binary data in - block buffered
    * stddato (FD 5): Binary data out - block buffered
  - [x] Extract implementation strategy
    * Linux: FDs 3-5 via fcntl + dup2 + process inheritance
    * Windows: STARTUPINFOEX + env var passing (__ARIA_STREAMS)
    * Named pipes for persistent IPC
    * Zero-copy optimizations (splice() on Linux)
  - [x] Understand stddbg/stddati/stddato rationale
    * Separation of concerns: text vs binary, errors vs debug
    * Prevents stdout corruption in pipelines
    * Enables ML/blockchain apps (binary tensor streaming)
    * 33% bandwidth savings (no Base64 encoding needed)
  - [x] Document: `/docs/gemini/responses/research_006_modern_streams.txt`

- [x] **research_007: Threading Library** ‚úÖ COMPLETE (Dec 11, 2025)
  - [x] Upload compilations
  - [x] Review response document (comprehensive design spec)
  - [x] Extract threading model design
    * **Key Finding**: Hybrid M:N + 1:1 threading model
    * M:N: Task runtime with work-stealing scheduler (async/await)
    * 1:1: Thread subsystem for CPU-bound work (aria.thread)
    * Bridge: spawn_blocking prevents colored function problem
  - [x] Extract synchronization primitives
    * Async Mutex: Task-aware (suspends coroutine, not thread)
    * Sync Mutex: Thread-blocking (pthread_mutex_t wrapper)
    * Channels: Go-style MPSC with bounded/unbounded modes
    * Semaphores: Both async and sync variants
  - [x] Extract async/thread integration strategy
    * Work-stealing: Chase-Lev lock-free deques
    * Global injection queue for external tasks
    * Fairness: Check global queue every 61 ticks
    * Task: Stackless coroutines (~200-500 bytes)
    * Thread: OS threads (pthread/CreateThread)
  - [x] Document: `/docs/gemini/responses/research_007_threading_library.txt`

### 0.3 Medium-Priority Research (Nice to have)
- [x] **research_008: Atomics library** ‚úÖ COMPLETE (Dec 11, 2025)
  * **Memory Model**: Adopts C++11/LLVM standard for compatibility
    - Sequenced-before, Synchronizes-with, Happens-before relationships
    - Data races in wild memory = UB, in gc memory = logical corruption
  * **Five Memory Orderings**: Relaxed, Acquire, Release, AcqRel, SeqCst
    - Explicit ordering required (no defaults, forces consideration)
    - Maps to x86-64 TSO and ARMv8 weak memory model instructions
  * **API Design**: Based on Rust's std::sync::atomic (explicit methods, not operators)
    - `Atomic<T>`, specialized aliases (AtomicInt64, AtomicBool, AtomicPtr, etc.)
    - Core methods: load, store, swap, compare_exchange, fetch_add/sub/and/or/xor
  * **TBB Challenge**: Hardware atomics incompatible with sticky error semantics
    - Standard types (int/uint): Use hardware fetch-and-add (LOCK XADD, LDADD)
    - TBB types (tbb8/16/32/64): Compiler-synthesized CAS loops to preserve ERR stickiness
  * **Lock-Free Patterns**: Arc (reference counting), Treiber Stack, ABA mitigation
  * **Platform Specifics**:
    - x86-64 TSO: Many atomics "free" (MOV sufficient), SeqCst needs MFENCE
    - ARMv8: LDAR/STLR for acquire/release, DMB/DSB for full barriers
  * **Testing Strategy**: ThreadSanitizer integration, torture tests, model checking
  * **Reference**: `/docs/gemini/responses/research_008_atomics_library.txt` (417 lines)
- [x] **research_009: Timer/Clock Library** ‚úÖ COMPLETE (Dec 11, 2025)
  * **Core Design**: Hierarchical Timing Wheel (5-level hashed wheel, O(1) insert/cancel)
  * **Key Innovations**:
    - TBB64 temporal calculus: Symmetric time arithmetic eliminates overflow bugs
    - Duration/Instant types with ERR sentinel for safe time math
    - Monotonic time enforcement (never use wall-clock for durations)
    - Per-worker wheels (zero lock contention, NUMA-friendly)
  * **Platform Integration**:
    - Linux: timerfd + epoll (nanosecond precision via VDSO)
    - Windows: Waitable Timers + IOCP (QueryPerformanceCounter)
    - macOS/BSD: kqueue EVFILT_TIMER (mach_absolute_time)
  * **Async Support**:
    - sleep(), timeout(), Ticker (periodic events)
    - Appendage Theory enforcement for timer callbacks
    - Cancellation via Future drop (zombie timer mitigation)
  * **Performance**: VDSO usage (15ns clock reads), cache-friendly wheel structure
  * **Reference**: `/docs/gemini/responses/research_009_timer_clock_library.txt` (502 lines)
- [x] **research_010+011: Macro Preprocessor & Comptime Metaprogramming System** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Scope**: Two-phase metaprogramming architecture (NASM-style textual macros + Zig-style semantic comptime)
  * **Phase 1 - Macro Preprocessor** (Textual/Syntactic):
    - **Context Stack Management**: %push/%pop/%repl/%ifctx for nested macro states
    - **Label Hygiene**: Context-local labels (%$label) prevent symbol collision
    - **Token Manipulation**: %rotate for variadic argument processing
    - **Multi-line Capture**: %body directive for DSL block capture
    - **Recursive Expansion**: Support for self-referential macros with depth limits
  * **Phase 2 - Comptime Execution Engine** (Semantic):
    - **CTFE Interpreter**: Tree-walking VM operating on typed AST
    - **TBB-Aware ALU**: Native sticky error propagation for compile-time TBB arithmetic
    - **Exotic Type Support**: Ternary/nonary unpacking and logic emulation
    - **Types as Values**: @typeInfo() reflection, type:T first-class parameter
    - **Virtual Heap**: Sandboxed memory arena simulating wild/gc allocation at compile-time
  * **Bridge Mechanism**:
    - **@mixin Operator**: Injects generated code strings back into parser
    - **Source Maps**: Full provenance tracking for error messages (file/line/macro stack)
  * **High-Level Library** (Macro-Implemented):
    - Control flow: IF/ELIF/ELSE/ENDIF, WHILE/ENDWHILE with BREAK/CONTINUE
    - ACTOR macro: Generates struct + message enum + mailbox loop
    - Memory-aware generics: Vector<T> adapts to wild vs gc allocation
  * **Integration**:
    - Borrow checker: Validates # pinning, $ safe references in macro output
    - Threading: SPAWN safety checks (@typeInfo(T).is_sendable)
    - Atomics: Macro-generated CAS loops for TBB types
  * **Timeline**: 14-week implementation roadmap detailed
  * **Reference**: `/docs/gemini/responses/research_010-011_macro_comptime.txt` (comprehensive 600+ line report)

### 0.4 Remaining Core Research (Pending)
- [x] **research_012: Standard Integer and Unsigned Integer Types** ‚úÖ COMPLETE + TYPE SYSTEM IMPLEMENTED (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_012_standard_integer_types.txt` (401 lines)
  * **Status**: `/docs/STANDARD_INTEGER_TYPES_STATUS.md` (Commit 3f2634d)
  * **Key Findings**:
    - **Two's Complement** for all signed types (int1-512)
    - **Modular Arithmetic** (wrap-around, no trap) for hardware alignment
    - **Sub-byte types** (int1, int2, int4) with bit-packing in structs (@pack)
    - **Wide types** (256/512) as first-class for crypto (no BigInt needed)
    - **LLVM Mapping**: i8-i64 native, i128/i256/i512 as arbitrary precision
    - **Read-Modify-Write** sequences for sub-byte field access
    - Asymmetric range (e.g., int8: -128 to +127, not symmetric like TBB)
  * **IMPLEMENTATION COMPLETE**:
    ‚úÖ Type system: INT1, INT2, INT4, UINT128, UINT256, UINT512 added to TypeKind
    ‚úÖ LLVM codegen: All 23 integer types map correctly (i1-i512)
    ‚úÖ Tests: test_integers_simple.aria, test_standard_integers.aria
    ‚úÖ Compilation: Generates valid LLVM IR for all types
  * **REMAINING**: Literal suffixes, @pack directive, checked intrinsics, SIMD opts
- [x] **research_013: Floating-Point Types (Extended Precision)** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_013_floating_point_types.txt` (640 lines)
  * **Key Findings**:
    - **Hybrid Model**: flt32/64 hardware (SSE/AVX), flt128 hybrid, flt256/512 software
    - **IEEE 754-2019 Strict Compliance**: Full subnormal support, signed zero, deterministic NaN
    - **TBB Interop**: ERR ‚Üí NaN, NaN/Inf ‚Üí ERR (strict semantic boundary)
    - **Limb-based representation** for flt256/512 (arrays of uint64)
    - **Precision**: flt256 ~71.3 decimal, flt512 ~147.2 decimal digits
    - **Rounding**: All 4 IEEE modes (RNE, RTZ, RUP, RDN) via thread-local state
    - **Frontend refactor needed**: Store literals as APFloat (not C++ double)
  * **TODO**: Implement SoftFloat runtime, LLVM lowering, literal parsing
- [x] **research_014: Composite Types - Part 1 (Object, Dynamic, Boolean)** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_014_composite_types_part1.txt` (262 lines)
  * **Key Findings**:
    - **bool**: Binary primitive (i1 LLVM), strictly separate from trit (no ternary ambiguity)
      * Vector support: bvec2-4 for SIMD masking (AVX-512 k-masks)
      * Physical storage: 8-bit padded for addressability
    - **obj**: Universal associative array with hybrid storage
      * **ObjHeader** (64-bit): mark/pin/forward/nursery/size_class/type_id bits
      * **Hidden Classes** optimization (V8-style shapes for fixed keys)
      * Dictionary fallback for dynamic property addition
      * Pinning support via # operator (pinned_bit prevents GC move)
    - **dyn**: Type-erased polymorphism container
      * Small Object Optimization for primitives (avoid heap allocation)
      * GC root tracking integration
  * **TODO**: Implement ObjHeader, shape caching, GC integration
    - Conversion from TBB ERR (error ‚Üí false?)
- [x] **research_015: Composite Types - Part 2 (Vectors, Structs, Strings)** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_015_composite_types_part2.txt` (253 lines)
  * **Key Findings**:
    - **Vector Types**: vec2-4 (flt32), dvec2-4 (flt64), ivec2-4 (int32)
      * **Direct SIMD mapping**: vec4 ‚Üí XMM (128-bit), dvec4 ‚Üí YMM (256-bit)
      * **vec9 (Exotic)**: 9D-TWI support, 288-bit for 3√ó3 matrix flattening
      * AVX-512 ZMM registers for vec9 (writemask for 9 lanes)
      * Geometric intrinsics: dot (horizontal add), cross (runtime call), normalize
      * Swizzling via CreateShuffleVector (v.wzyx ‚Üí single SHUFPS)
    - **struct**: Natural alignment (no vtable), @pack for bit-level control
      * Plain Old Data (POD) for C ABI compatibility
    - **string**: Small String Optimization (SSO) to eliminate heap churn
  * **TODO**: Implement VectorLowerer, struct layout engine, SSO runtime
    - Memory model (always GC? support wild struct?)
    - Method definitions (attached functions?)
    - Inheritance or composition model
  * **string**:
    - Encoding (UTF-8 native? ASCII? UCS-2?)
    - Small String Optimization (SSO) threshold
    - Immutability (Rust String vs &str model?)
    - String concatenation (operator+ vs builder pattern?)
    - Integration with template literals (`...`)
    - GC vs wild string allocation
- [x] **research_016: Functional Types (Result, Func, Array)** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_016_functional_types.txt` (250 lines)
  * **Key Findings**:
    - **result<T>**: Zero-cost monadic error propagation
      * Binary layout: `{ i8 err, T val }` - fits in 2 registers (RAX+RDX)
      * Discriminator: 0 = success, non-zero = error code (test against zero)
      * ? operator: Early return via basic block split (flatMap/bind operation)
      * Specialized layouts: result<void> = i8, result<int64> = 16 bytes
      * TBB bridge: ERR ‚Üí result error, separate data vs control failure
      * Pattern matching: switch on err field (jump table optimization)
    - **func**: Unified closure/function pointer representation
      * Three models: static function pointer, stateful closure, async task
      * Interchangeable in higher-order functions
    - **array**: Dynamic collections with slice views
      * Bounds checking configurable
      * Integration with range operators (.., ...)
  * **TODO**: Implement result lowering, monadic operators, func closure capture
- [ ] **research_017: Advanced Mathematical Types (Tensor, Matrix)**
  * **Scope**: Design tensor and matrix types
  * **tensor<T, Shape>**:
    - N-dimensional array representation
    - Shape encoding (compile-time or runtime dimensions?)
    - Stride calculation and memory layout (row-major, column-major, custom)
    - Broadcasting rules (NumPy-style or custom?)
    - SIMD/GPU acceleration hooks
    - Integration with ML libraries
  * **matrix<T, Rows, Cols>**:
    - Specialized 2D tensor with linear algebra operations
    - Matrix multiplication (naive, Strassen, BLAS integration)
    - Decomposition (LU, QR, SVD)
    - Sparse matrix support
    - Relationship to vec2/vec3 (matrix-vector multiplication)
    - Fixed-size vs dynamic-size matrices

### 0.5 Control Flow Constructs Research
- [x] **research_018: Looping Constructs (while, for, loop, till)** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_018_looping_constructs.txt` (509 lines)
  * **Key Findings**:
    - **Native Implementation**: Loops elevated from macros to first-class constructs
    - **TBB Safety Integration**: Loop counters can be TBB types with automatic overflow termination
    - **Automatic $ Variable**: Context-sensitive iteration variable with type inference
      * Scope: Implicitly injected into SymbolTable for till/loop constructs
      * Type: Inferred from loop bounds (till(100) ‚Üí int, till(tbb64) ‚Üí tbb64)
      * Immutability: Read-only, assignment to $ is compile error
      * Nesting: Inner loops shadow outer $ (automatic scope management)
    - **Loop Types**:
      * **while**: Standard conditional, TBB-aware condition checks
      * **for Dual-Mode**: Parser discriminates TOKEN_KW_IN vs TOKEN_SEMICOLON
        - Iterator: `for (x in iterable)` with range support (0..10, 0...10)
        - C-Style: `for (init; cond; step)` with precise pointer control
      * **loop**: Explicit bounds `loop(start, limit, step)`
      * **till**: Zero-indexed `till(limit, step)` implicitly starts at 0
      * **when**: Tri-state `when (cond) { } then { } end { }` for search patterns
    - **TBB Loop Safety**:
      * Increment i++ lowered to TBB-safe addition
      * If counter reaches ERR, loop terminates (prevents infinite wrapping)
      * Comparison i < limit checks for ERR state (ERR < value ‚Üí false)
    - **CFG Generation**: Header/Body/Latch/Exit blocks with PHI nodes for SSA
    - **Async Integration**: await in loops splits state machine, $ promoted to coroutine frame
  * **TODO**: Implement WhileLoop, ForLoop, TillLoop, LoopStmt, WhenLoop AST nodes
- [ ] **research_019: Conditional Constructs (if/else, when/then/end, pick)**
  * **Scope**: Detailed semantics for conditionals and pattern matching
  * **if (cond) { } else { }**:
    - Standard branching
    - Short-circuit evaluation
    - Integration with safe navigation (?.)
    - Optimization: branch prediction hints
  * **when (cond) { body } then { success } end { failure }**:
    - Completion-aware loop with handlers
    - 'then' runs after normal completion
    - 'end' runs if loop never executed or broke early
    - State tracking mechanism
  * **pick (value) { cases }**:
    - Pattern matching switch
    - Case types: exact, range (.., ...), comparison (<, >, <=, >=)
    - Destructuring patterns ({ field: value }, [a, b, c])
    - Wildcard (*) and unreachable (!)
    - fall(label) explicit fallthrough
    - Exhaustiveness checking
- [x] **research_020: Control Transfer (break, continue, return, defer)** ‚úÖ COMPLETE (Dec 13, 2025)
  * **Document**: `/docs/gemini/responses/research_020_control_transfer.txt` (410 lines)
  * **Key Findings**:
    - **Result Monad Integration**: Implicit result<T> wrapping for all functions
    - **pass/fail Syntax Sugar**: Simplified error propagation
      * pass(expr) ‚Üí return {err: 0, val: expr}
      * fail(error_code) ‚Üí return {err: error_code, val: 0}
    - **defer (Block-Scoped RAII)**: Unlike Go (function-scoped), Aria's defer is block-scoped
      * Execution: LIFO stack within block, runs at } or return/break/continue
      * Wild Memory: Essential pattern for aria.free cleanup
      * Borrow Checker: Verifies defer dominates all exit points (prevents leaks)
      * No Unwind: defer does NOT execute on panic/trap (corrupted state = unsafe cleanup)
    - **Labeled Control Flow**:
      * break(label), continue(label) for nested loops
      * Target validation: Label must refer to loop construct
      * Scope exit: defer blocks execute for all exited scopes (inside-out)
    - **when Loop Tri-State Logic**:
      * did_break flag (PHI node): Routes to then (natural exit) vs end (break exit)
      * break promotes from jump to state-carrying signal
      * Eliminates bool found flags
    - **TBB Safety**: Implicit break on overflow ($ reaches ERR in loops)
    - **pick Statement**: Explicit fall(label) for case fallthrough (no implicit)
    - **Result Struct ABI**:
      * Small (<16 bytes): Returns in RAX+RDX (System V)
      * Large: Hidden pointer first argument (sret calling convention)
    - **Async Integration**: defer blocks part of coroutine frame, execute on true exit
  * **TODO**: Implement ReturnStmt/PassStmt/FailStmt, defer stack management, when loop state machine

### 0.6 Memory Management Research
- [ ] **research_021: Garbage Collection System**
  * **Scope**: Complete GC architecture and integration
  * **GC Algorithm**:
    - Generational design (nursery + mature space)
    - Minor GC (young generation, copying collector)
    - Major GC (full heap, mark-sweep-compact or mark-region)
    - Fragmented nursery design (per-worker arenas)
  * **Root Tracking**:
    - Shadow stack implementation
    - Conservative stack scanning fallback
    - Global roots and static data
  * **Write Barriers**:
    - Incremental/concurrent GC support
    - Remembered set for cross-generation pointers
  * **Pinning Integration**:
    - # operator marks objects non-movable
    - Pin counting mechanism
    - Interaction with compaction
  * **Performance**:
    - Allocation fast path (bump pointer in nursery)
    - GC pause time targets (sub-millisecond minor, <10ms major)
    - Throughput optimization
  * **Platform Specifics**:
    - Linux: mmap/madvise for memory management
    - Windows: VirtualAlloc/VirtualFree
    - macOS: vm_allocate/vm_deallocate
- [x] **research_022: Wild and Wildx Memory (Manual Management)** ‚úÖ COMPLETE (Dec 13, 2025)
  * **Document**: `/docs/gemini/responses/research_022_wild_wildx_memory.txt` (379 lines)
  * **Key Findings**:
    - **Tripartite Memory Model**: Stack (LIFO) + GC Heap (generational) + Wild Heap (manual)
    - **Allocation Strategy Enum**: AllocStrategy::STACK, ::GC, ::WILD, ::WILDX
    - **Wild Memory API**:
      * aria.alloc(size) ‚Üí wild void@ (uninitialized, malloc-like)
      * aria.free(ptr) ‚Üí void (matches allocation)
      * aria.realloc(ptr, new_size) ‚Üí wild void@ (invalidates old pointer)
      * aria.alloc_aligned(size, alignment) ‚Üí wild void@ (for SIMD types)
      * defer aria.free(ptr) for RAII cleanup (scope exit guarantee)
    - **WildX (Executable Memory)**:
      * W‚äïX enforcement: Never RWX, transition RW ‚Üí RX only
      * State machine: UNINITIALIZED ‚Üí WRITABLE ‚Üí EXECUTABLE ‚Üí FREED
      * aria.alloc_exec(size) ‚Üí wildx void@ (page-aligned RW)
      * aria.mem_protect_exec(ptr, size) ‚Üí Seal RW ‚Üí RX (flush I-cache)
      * WildXGuard RAII: Automatic sealing + cleanup on scope exit
      * Security: Hardware NX bit prevents writes after sealing (SIGSEGV)
    - **Pointer Operators**: 
      * @ (address-of): Returns wild T@ pointer to variable
      * # (pin): Pins GC object, returns wild T@ (prevents GC relocation)
      * -> (member access): ONLY syntax for pointer dereference (no standalone *)
      * * (NOT dereference): Generic type prefix only (func<T> uses *T)
      * $ (safe reference): Borrow checker reference (borrowing), also iteration variable
    - **Safety Boundaries**:
      * Invisible Root Rule: GC doesn't scan wild memory, prevents wild ‚Üí GC dangling pointers
      * Appendage Theory: Depth(Host) ‚â§ Depth(Appendage), pin (Host) must outlive pointer (Appendage)
      * Use-After-Free Detection: Flow-sensitive tracking, State(ptr) == Dead triggers compile error
      * Fat Pointers (debug mode): {ptr, base, size, alloc_id} for bounds checking
    - **GC Integration**:
      * pinned_bit in object header (marks object as non-relocatable)
      * Wild structs holding GC refs require # operator to make reference "visible"
      * GC maps adapt based on struct contents (Vector<wild int*> vs Vector<string>)
    - **Performance**: Wild alloc O(log n) vs GC bump-pointer O(1), but zero pause times (deterministic)
  * **TODO**: Implement Wild allocator wrapper, WildX state machine, fat pointer debug mode
- [x] **research_023: Runtime Assembler (Wildx Code Generation)** ‚úÖ COMPLETE (Dec 13, 2025)
  * **Document**: `/docs/gemini/responses/research_023_runtime_assembler.txt` (544 lines)
  * **Key Findings**:
    - **Aria Runtime Assembler (ARA)**: Fluent interface API for x86-64 JIT compilation
    - **WildX Integration**: Enforces W‚äïX security through RAII state machine
      * Allocation: aria_alloc_exec(size) ‚Üí RW memory (page-aligned)
      * Sealing: aria_mem_protect_exec(ptr, size) ‚Üí RW‚ÜíRX (flush I-cache, mprotect/VirtualProtect)
      * WildXGuard: RAII wrapper (allocate ‚Üí write ‚Üí seal ‚Üí execute ‚Üí free)
    - **x86-64 Instruction Encoding**:
      * Variable length (1-15 bytes): Legacy Prefixes + REX + Opcode + ModR/M + SIB + Disp + Imm
      * REX Prefix (0x40-0x4F): 0100WRXB bits for 64-bit ops and R8-R15 access
      * ModR/M: Mod(2) + Reg/Opcode(3) + R/M(3) bits for addressing modes
      * SIB: Scale(2) + Index(3) + Base(3) for complex memory operands
      * Shortest encoding heuristic: Sign-extension, immediate optimization
    - **Register Allocation**: Linear Scan (O(N) vs Graph Coloring O(N¬≤))
      * Live interval analysis (backward pass)
      * Allocation walk: Expire old, allocate new, spill when pressure high
      * Spill heuristic: Interval with furthest end point
      * Register constraints: Caller-saved (RAX, RCX, RDX, R8-R11), callee-saved (RBX, RBP, R12-R15)
      * Pre-coloring: Fixed registers for IDIV (RDX:RAX), shifts (RCX)
    - **System V ABI Compliance**:
      * Integer args: RDI, RSI, RDX, RCX, R8, R9 (stack for 7+)
      * Float args: XMM0-XMM7
      * Returns: RAX (int), XMM0 (float), RAX+RDX (128-bit)
      * Result struct bridge: Small (<16B) in RAX+RDX, large via hidden pointer (sret)
    - **Fluent API**: Method chaining (asm.mov(rax, rbx).add(rax, 10).ret())
      * Type safety: Distinct types for Reg, Imm, Mem prevent invalid combos
      * CodeBuffer: Dynamic growth (geometric)
      * Label: Backpatching for forward jumps (unbound ‚Üí emit placeholder ‚Üí bind ‚Üí patch)
    - **Literal Pool**: SIMD constants appended after ret, RIP-relative loads
    - **Safety Features**:
      * Stack consistency check (simulated depth)
      * Instruction boundary verification (prevents ROP gadgets)
      * Disassembly integration (Zydis library, ARIA_JIT_DEBUG)
    - **Performance**: 5-12x speedup vs interpreter, 50-70% of LLVM AOT
  * **TODO**: Implement Assembler class, x86-64 encoder, Linear Scan allocator, WildXGuard RAII

### 0.7 Operators Research
- [x] **research_024: Arithmetic and Bitwise Operators** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_024_arithmetic_bitwise_operators.txt` (408 lines)
  * **Key Findings**:
    - **Standard Integers**: Modular arithmetic (wrap-around), deterministic behavior
      * Rationale: Cryptographic necessity (ChaCha20, SHA-256), hardware alignment
      * Overflow: Valid wrap-around (modulo 2^N), NOT undefined behavior
      * Division by zero: Hardware trap (SIGFPE), panic with stack unwind
      * INT_MIN / -1: Hardware trap, consistent cross-platform
    - **TBB Operators**: Sticky error propagation state machine
      * Input Sticky: ERR in either operand ‚Üí Result = ERR
      * Overflow Check: Result exceeds range ‚Üí ERR
      * Sentinel Collision: Valid result matches ERR bit pattern ‚Üí ERR
      * Division: Never traps, division-by-zero returns ERR (safe)
    - **Bitwise Unsigned Mandate**: &, |, ^, ~, <<, >> only on unsigned types
      * Prevents sign-extension ambiguity in shifts
      * Error: "Bitwise operator '&' not defined for 'int32', cast to 'uint32'"
    - **Shift Safety**: Oversize shifts (n >= width) guaranteed to return 0
      * x86 masks shift count, ARM saturates ‚Üí Aria inserts explicit checks
    - **TBBLowerer**: Branch-free lowering via select + overflow intrinsics
      * llvm.sadd.with.overflow, llvm.smul.with.overflow
      * CMOV instructions (non-branching, constant time)
    - **SIMD**: AVX-512 masked operations for TBB arrays (4-6 cycles overhead)
    - **Performance**: TBB 20-50% slower than standard (acceptable for safety)
  * **TODO**: Implement TBBLowerer, bitwise type checks, shift safety
- [x] **research_025: Comparison and Logical Operators** ‚úÖ COMPLETE (Dec 12, 2025)
  * **Document**: `/docs/gemini/responses/research_025_comparison_logical_operators.txt` (194 lines)
  * **Key Findings**:
    - **Strict Boolean Semantics**: Logical ops (&&, ||, !) only accept bool
      * No truthiness (rejects implicit coercion from 0, null, etc.)
      * Rationale: Prevents TBB 0 (Unknown) from being treated as false
      * Example: `if (ptr)` is error, must write `if (ptr != null)`
    - **Short-Circuit Guarantee**: && and || use conditional branches, not bitwise
      * Safety pattern: `if (ptr != null && ptr->is_valid())` never segfaults
      * LLVM: Entry ‚Üí EvalB (if A true) ‚Üí Merge with PHI node
    - **Relational Operators**: ==, !=, <, <=, >, >= with TBB integration
      * Standard ints: Direct icmp/fcmp mapping
      * TBB: Comparisons act as "error sinks" (ERR ‚Üí bool, loses stickiness)
      * ERR == ERR ‚Üí true (explicit error check)
      * ERR < valid ‚Üí treated as incomparable (may trap or special handling)
    - **Spaceship Operator (<=>)**: Three-way comparison
      * Returns: -1 (less), 0 (equal), 1 (greater)
      * Use: Sorting, branchless algorithms (result = (a > b) - (a < b))
      * Lexicographical for strings/vectors
      * Defines total ordering on vec types (enables TreeMap keys)
    - **Pointer Comparison**: Lifetime-checked equality
      * GC pointer vs Wild pointer: Requires pinning (#) to stabilize address
      * Prevents non-deterministic results from GC relocation
    - **Dynamic Types (dyn)**: Runtime dispatch via type_id
      * Fast path: Primitives use direct comparison
      * Slow path: Objects use vtable Eq trait lookup
      * Type mismatch: Returns false (no implicit coercion)
  * **TODO**: Implement boolean type checking, TBB comparison logic, <=> lowering
- [x] **research_026: Special Operators (Memory, Safety, Pipeline)** ‚úÖ COMPLETE (Dec 13, 2025)
  * **Document**: `/docs/gemini/responses/research_026_special_operators.txt` (475 lines)
  * **Key Findings**:
    - **Memory Operators**:
      * **@ (address-of)**: wild T@ = @variable (like C &)
        - Stack: ABC tracks lifetime, prevents escape
        - GC objects: FORBIDDEN (must use # to pin first)
        - LLVM: alloca pointer or getelementptr
      * **# (pinning)**: wild T@ = #gc_obj
        - Sets pinned_bit in object header (GC won't relocate)
        - Returns raw pointer to payload
        - Appendage Theory: Lifetime(Appendage) ‚äÜ Lifetime(PinScope)
        - Enables pointer arithmetic (#obj + n)
        - Invisible Root Rule: Wild struct can't hold GC ref unless pinned
      * **$ (safe reference / iteration)**:
        - $var: Immutable borrow (Rust-like &)
        - Loop context: Implicit iteration variable
        - WildX context: Instruction pointer in assembler macros
      * **-> (member access)**: ONLY syntax for pointer deref (no standalone *ptr)
      * **wildx**: W‚äïX state machine (RW ‚Üí RX via aria.mem_protect_exec)
    - **Error Handling Operators**:
      * **? (propagate)**: Monadic bind for result<T>
        - expr? ‚Üí if err, early return
        - TBB integration: Checks for ERR sentinel, propagates
      * **?. (safe navigation)**: obj?.member
        - Short-circuit on null/ERR
        - LLVM: Branch structure with phi node
      * **?? (null coalescing)**: expr1 ?? expr2
        - Returns expr1 if not null/ERR, else expr2
        - Lazy evaluation (expr2 only if needed)
        - Composition: user?.profile?.getName() ?? \"Guest\"
    - **Pipeline Operators**:
      * **|> (forward)**: data |> func
        - Desugaring: x |> f ‚Üí f(x), x |> f(y) ‚Üí f(x, y)
        - Subject-first insertion
        - Precedence: PREC_PIPELINE (4), left-associative
        - Chaining: data |> filter(p) |> map(f) |> reduce(sum)
      * **<| (backward)**: f <| x ‚Üí f(x) (apply operator, avoids parens)
    - **Range Operators**:
      * **.. (inclusive)**: 0..10 is [0, 10] (11 elements)
      * **... (exclusive)**: 0...10 is [0, 10) (10 elements)
      * Infinite: 0.. (TYPE_MAX)
      * Steps: Via loop(start, end, step) or range.step(2)
    - **String Interpolation** (NOT closures):
      * &{expr} inside backtick strings: `Value: &{x + 1}`
      * Closures use func keyword or => lambda syntax
      * Capture semantics: By-value (copy), by-reference (Stack Closure), move (ownership)
      * Inline optimization: Devirtualization via monomorphization
    - **Operator Precedence Table**: 17 levels (Primary to Comma)
      * Primary (17): (), [], ., ?. (highest)
      * Unary (16): !, -, @, #, $, ?
      * Pipeline (4): |>, <|
      * Assignment (2): =, +=, ??=
      * Comma (1): , (lowest)
  * **TODO**: Implement all operators in parser, precedence climbing, ABC integration for @ and #

### 0.8 Language Infrastructure Research
- [x] **research_027: Generics and Templates (Monomorphization System)** ‚úÖ COMPLETE (Dec 13, 2025)
  * **Document**: `/docs/gemini/responses/research_027_generics_templates.txt` (385 lines)
  * **Key Findings**:
    - **Zero-Cost Abstractions**: Compile-time monomorphization (instantiate specialized copy per type combo)
    - **Syntax Philosophy**: func<T> declares, *T references (explicit sigil prevents C++ ambiguity)
      * In angle brackets <T>: Declares type parameter
      * Everywhere else: Must use *T (marks generic usage syntactically)
      * Example: func<T>:identity = *T(*T:value) { return value; }
    - **Instantiation Strategy**: Lazy, demand-driven
      * Registration: func<T> stored as generic AST (not compiled)
      * Discovery: Call site identity(42) triggers inference (T = int32)
      * Cache Lookup: specialization_map[(identity, [int32])]
      * Pipeline: Clone AST ‚Üí Substitute *T with int32 ‚Üí Re-analyze ‚Üí Codegen
    - **Deduplication**:
      * Frontend: Type aliases canonicalized (MyInt = int32 ‚Üí same cache key)
      * Linker: Deterministic mangling + linkonce_odr ‚Üí discard duplicates across modules
    - **Name Mangling**: _Aria_M_<FuncName>_<TypeHash>_<TypeDesc>
      * Example: func<T>:max with tbb8 ‚Üí _Aria_M_max_F4A19C88_tbb8
      * TypeHash: 64-bit FNV-1a for uniqueness
      * TypeDesc: Human-readable (debugger/stack traces)
    - **Depth Limits**: 64 nested instantiations max, cycle detection prevents infinite expansion
    - **Type Inference**: Local bidirectional (constraint generation ‚Üí unification ‚Üí substitution)
      * No implicit coercion: swap(int32, int64) fails (must cast explicitly)
      * Ambiguous cases require Turbofish: default::<int64>()
    - **Constraint System**: Trait bounds checked at instantiation
      * func<T: Hashable & Display> (multiple bounds with &)
      * Definition-time: Body only calls methods in traits
      * Instantiation-time: Type must implement traits (checked via impl_table)
      * Built-in traits: Copy, Drop, Add, Sub, Mul, Div, Send
    - **TBB Integration**: Semantic polymorphism
      * func<T>(a + b) with T=int32 ‚Üí single CPU add instruction
      * Same function with T=tbb32 ‚Üí complex sticky error propagation logic
      * Backend recognizes TBB, intercepts +, delegates to TBBLowerer::createAdd
    - **Memory Model Integration**:
      * Vector<wild int*>: Null GC map (opaque to GC, no write barriers)
      * Vector<string>: GC map marks pointer array, emits write barriers
      * Single Vector implementation serves both via monomorphization
    - **Borrow Checker**: Generic parameters transparent to lifetime tracking
      * func<T>(*T:x) ‚Üí *T infers return lifetime tied to argument lifetime
    - **Advanced Features (Planned)**:
      * Const generics: struct<T, const N: int>:Matrix { *T[N * N]:data; }
      * Variadic generics: func<...Ts>:tuple(*Ts...:args) (Research_030)
    - **Performance**: Compilation speed moderate (deduplication cost), zero runtime overhead
  * **TODO**: Implement Monomorphizer (src/backend/monomorphization.cpp), TBB lowering integration, GC map generation
- [x] **research_028: Module System (use, mod, pub, extern)** ‚úÖ COMPLETE (Dec 13, 2025)
  * **Document**: `/docs/gemini/responses/research_028_module_system.txt` (510 lines)
  * **Key Findings**:
    - **Keywords**: use (import), mod (define), pub (export), extern (FFI)
    - **use (Import Syntax)**:
      * Canonical: use std.io, use std.collections.map
      * Selective: use std.collections.{array, map, Vector}
      * Wildcard: use math.* (not recommended, forward compat hazard)
      * Aliasing: use "./utils.aria" as utils, use std.network.http.client as HttpClient
      * Path-based: use "../shared/crypto.aria", use "/usr/lib/aria/graphics"
    - **Import Resolution Algorithm**:
      * Normalization: String literals resolved relative to current file
      * Root Resolution: Check package manifest ‚Üí dependency map
      * Directory Traversal: a.b ‚Üí <root>/a/b.aria OR <root>/a/b/mod.aria
      * Failure: Scan ARIA_PATH ‚Üí Fatal E001: Module not found
    - **Circular Dependency Management**:
      * DAG Requirement: Cycles banned (compile-time error E003)
      * Detection: LoadingStack tracks parsing chain, push/pop/check
      * Resolution: Interface Extraction pattern (move shared to Module C) or Trait abstraction
    - **mod (Module Definition)**:
      * Inline: mod internal_logic { func:helper = void() {... } }
      * External: mod network; (looks for network.aria or network/mod.aria)
      * Hierarchical: mod acts as mount point, separates declaration from implementation
    - **Directory Structure**:
      * Standard layout: src/{main.aria, lib.aria, utils.aria, net/{mod.aria, http.aria}}
      * mod.aria: Directory module marker (like Python __init__.py, Rust mod.rs)
    - **Visibility System (Private-by-Default)**:
      * Private (default): Visible only in defining module + submodules
      * pub: Visible to any importer
      * pub(package): Visible within compilation unit (crate), not external
      * pub(super): Visible to parent module (sibling sharing)
    - **pub use Re-exports**: Facade pattern for clean APIs
      * Internal: std.internal.collections.hashmap
      * Public: pub use internal.collections.hashmap.HashMap ‚Üí std.collections.HashMap
    - **Visibility Enforcement**: Semantic analyzer checks access during symbol resolution
    - **extern (FFI)**:
      * Syntax: extern "libc" { func:malloc = void*(uint64:size); func:free = void(void*:ptr); }
      * Linkage: String literal specifies library (instructs linker)
      * Safety: All extern items implicitly unsafe
    - **Type Mapping (C FFI)**:
      * Integers: int8-int64 ‚Üí int8_t-int64_t (direct binary compat)
      * Floats: flt32/64 ‚Üí float/double (IEEE 754)
      * Pointers: void*, @type ‚Üí void*, type*
      * Strings: string ‚Üí struct {char* ptr; size_t len;} (auto-marshal to null-terminated)
      * TBB: tbb8 ‚Üí int8_t (hazard: -128 is ERR in Aria, valid in C)
      * Structs: Only compatible if #[repr(C)] (disables field reordering)
    - **WildX Security**: Exporting wildx pointers requires unsafe marker (prevents code injection via C)
    - **Calling Conventions**: Default cdecl, #[call_conv("stdcall")] for Windows APIs
    - **Symbol Resolution**: Hierarchical SymbolTable (Level 0: universe, Level 1: module, Level 2+: local)
    - **Two-Pass Compilation**:
      * Pass 1: Interface discovery (scan declarations, skip bodies) ‚Üí Build SymbolTable skeleton
      * Pass 2: Semantic analysis (bodies) ‚Üí All interfaces known, no forward decls needed
    - **Generic Monomorphization**: Generic ASTs serialized in module metadata (.lib/.mod files)
    - **Build System**: aria.toml package manifest
      * [package]: name, version, authors, edition
      * [dependencies]: std = {version}, json = {git}, shared_utils = {path}
      * [build]: optimize, output_dir
    - **Incremental Compilation**:
      * Hash modules (source + config), compare to target/incremental/
      * Interface hashing: Body changes don't force dependent re-type-check (only re-link)
    - **Conditional Compilation**: cfg(target_os = "linux") evaluated at parse time (AST erasure)
    - **Error Diagnostics**:
      * E001: Module not found (with search paths)
      * E002: Visibility violation (symbol private in module X)
      * E003: Circular dependency (refactor suggestion)
      * E004: FFI safety (TBB to C, wildx export)
  * **TODO**: Implement module resolver, SymbolTable hierarchy, two-pass compiler, aria.toml parser
    - Visibility levels (pub, pub(crate), pub(super), private)
    - FFI type mappings (Aria ‚Üî C types)
    - Conditional compilation (use cfg(target_os = "linux"))
  * **Integration**:
    - File/directory structure conventions
    - Package manifest format
    - Symbol resolution
    - Incremental compilation with modules
- [x] **research_029: Async/Await System** ‚úÖ COMPLETE (Dec 13, 2025) ‚≠ê CRITICAL
  * **Document**: `/docs/gemini/responses/research_029_async_await_system.txt` (823 lines)
  * **Key Findings**:
    - **Hybrid M:N Threading Model**: Maps M lightweight tasks onto N OS threads
    - **RAMP Optimization**: Zero-alloc fast path for synchronous completion
      * RampResult ABI: Union of {direct value} | {coroutine pointer}
      * Heap promotion only on first suspension (__aria_ramp_promote intrinsic)
      * Optimistic execution on caller's stack
    - **Wild Affinity Scheduling**: Thread-pinning for tasks with wild pointers
      * has_wild_affinity flag prevents cross-thread stealing
      * Solves Send/Sync without requiring Arc/Mutex wrappers
      * affinity_thread_id tracks owning worker
    - **Stackless Coroutines**: State machine transformation
      * CoroutineFrame struct (state, waker, spilled variables)
      * LLVM coroutine intrinsics for lowering
      * 64-byte alignment for AVX-512 support
    - **Future Trait**: poll(Context) ‚Üí Ready(T) | PENDING | ERROR
      * TBB sticky error propagation across await boundaries
      * No exception handling overhead
      * Waker for task resumption
    - **Chase-Lev Work-Stealing**: Lock-free scheduler
      * Local LIFO pop (cache locality)
      * Remote FIFO steal (fairness)
      * Global queue for external tasks (every 61 ticks)
    - **Six-Stream Reactor Integration**:
      * io_uring (Linux) / IOCP (Windows) for true async I/O
      * AsyncRead/AsyncWrite traits for stddati/stddato
      * Zero-copy with wild memory + pinning (#)
    - **Cancellation**: Drop-based with defer cleanup (RAII)
    - **Advanced Features**:
      * Async generators (yield)
      * Combinators (then, map, join, select)
      * spawn_blocking for CPU-bound work
      * Timeout via select + Timer
  * **Integration**:
    - Works with research_007 threading primitives
    - Uses research_005 I/O with io_uring/IOCP
    - Respects research_001 borrow checker ($ lifetimes)
    - TBB arithmetic from research_002
    - Wild/WildX from research_022

- [x] **research_030: Const/Compile-Time Evaluation** ‚úÖ COMPLETE (Dec 13, 2025) ‚≠ê CRITICAL
  * **Document**: `/docs/gemini/responses/research_030_const_compile_time.txt` (864 lines)
  * **Key Findings**:
    - **Two-Phase Metaprogramming Model**:
      * Phase 1: Preprocessor (syntactic expansion, macros)
      * Phase 2: Semantic CTFE (type-checked execution)
      * const resolved after macros, before codegen
    - **Virtual Heap**: Sandboxed compile-time memory
      * Pointer handles: {AllocID, Offset} (not raw addresses)
      * Prevents host memory access (security)
      * 1GB cap, 1M instruction budget, 512 frame depth
    - **TBB Arithmetic Emulation**: Host ALU enforces TBB semantics
      * Sticky error propagation in CTFE
      * const tbb8:x = 127 + 1; ‚Üí ERR (not -128)
      * Prevents divergence between compile-time and runtime
    - **Const Functions**: Auto-detection of purity
      * Deterministic, no side effects, no WildX
      * Memoization for recursive calls (factorial example)
      * Optional const modifier for API stability
    - **Const Generics**: Monomorphization pipeline
      * Name mangling: _Aria_Inst_Matrix_int32_4_4
      * Cache lookup prevents duplicate instantiation
      * Fixed-size arrays: int[N], Matrix<T, Rows, Cols>
      * Supported types: integers, booleans, types, enums
    - **Hybrid Const Correctness**: Integrates with Wild/GC memory
      * # pinning for const I/O operations
      * Appendage Theory: const cannot hold dangling references
      * WildX banned from CTFE (security)
    - **Optimization**: Constant folding ‚Üí DCE ‚Üí .rodata
      * Dead code elimination for const bool branches
      * LLVM linkonce_odr for aggregate constants
      * Debug info (DW_TAG_const_type) for symbolic debugging
  * **Synergy with comptime**:
    - comptime (imperative): "Do this calculation now"
    - const (declarative): "This name = this immutable value"
    - Pattern: const TABLE = comptime { /* loop logic */ };
  * **Integration**:
    - Works with research_010 comptime/macro system
    - Uses research_001 Appendage Theory (lifetime safety)
    - TBB emulation from research_002
    - Reflection via @typeInfo for generic constraints

### 0.9 Essential Standard Library Research (Bootstrap Requirements)
- [x] **research_031: Essential Standard Library (Compiler Bootstrap)** ‚úÖ COMPLETE (Dec 12, 2025) ‚≠ê CRITICAL
  * **Document**: `/docs/gemini/responses/research_031_essential_stdlib.txt` (199 lines)
  * **Key Findings**:
    - **Platform Abstraction Layer (std.sys)**:
      * Unified system interface via cfg conditional compilation
      * **6-Channel I/O Model**: stdin/out/err (text) + stddbg (debug) + stddati/stddato (binary)
      * Process management: spawn, wait, signal handling
      * System diagnostics: getCPUCount(), getMemoryUsage(), getPageSize()
      * Platform detection: ARIA_ARCH_*, ARIA_PLATFORM_* macros
    - **Memory Management (std.mem)**:
      * **Hybrid Allocator Strategy**: GC (aria.gc_alloc), Wild (aria.alloc), WildX (aria.alloc_exec)
      * **Shadow Stack**: Root tracking for moving GC (aria_shadow_stack_push_frame)
      * **Pinning Protocol**: # operator sets pinned_bit in ObjHeader (prevents GC move)
      * **W^X Compliance**: aria.protect_exec transitions RW ‚Üí RX for executable memory
    - **Bootstrap Philosophy**:
      * "Safety through Stickiness" - TBB sentinel propagation
      * "Hybrid Memory Sovereignty" - Stack/GC/Wild unification
      * "Observability by Default" - 6-channel separation of concerns
    - **Three-Phase Bootstrap**:
      1. Hello World (print + syscalls)
      2. File I/O Programs (readFile/writeFile)
      3. Self-Hosting (full stdlib subset for compiler)
  * **TODO**: Implement std.sys (platform.h wrappers), std.mem (allocator interfaces), std.io (6-channel streams)

---

## PHASE 1: Core Type System Completion
**Goal**: Implement all spec-defined types with full codegen  
**Dependencies**: Research 002, 003 for exotic types  
**Timeline**: 3-4 weeks  
**Priority**: CRITICAL (language syntax completion)

### 1.1 TBB (Twisted Balanced Binary) Types ‚úÖ COMPLETE
**Status**: Codegen, TypeChecker, and Tests complete
**Location**: src/backend/codegen_tbb.cpp, src/frontend/sema/tbb_checker.cpp, tests/tbb/
**Test Results**: 26/26 passing

#### 1.1.1 TBB Type Checker Implementation ‚úÖ
- [x] Created `TBBTypeChecker` in `src/frontend/sema/tbb_checker.cpp` (113 lines)
  - [x] Implemented symmetric range validation
    - [x] tbb8: [-127, +127], ERR = -128
    - [x] tbb16: [-32767, +32767], ERR = -32768
    - [x] tbb32: [-2147483647, +2147483647], ERR = INT32_MIN
    - [x] tbb64: symmetric range, ERR = INT64_MIN
  - [x] Implemented literal validation (reject out-of-range constants)
  - [x] Implemented ERR literal checking (context-dependent type)
  - [x] Added comprehensive tests in `tests/tbb/test_tbb_ops.cpp`

#### 1.1.2 TBB Arithmetic CodeGen - Sticky Error Propagation ‚úÖ
- [x] Extended CodeGen with TBB operations in `codegen_tbb.cpp` (247 lines)
  - [x] **Addition with overflow detection**
    - [x] Check if either operand is ERR ‚Üí return ERR (sticky)
    - [x] Perform addition with LLVM overflow intrinsics
    - [x] Check if result exceeds symmetric range ‚Üí return ERR
    - [x] Emit LLVM IR: `llvm.sadd.with.overflow`
  - [x] **Subtraction with overflow detection**
    - [x] Check ERR propagation
    - [x] Perform subtraction with overflow check
    - [x] Emit LLVM IR: `llvm.ssub.with.overflow`
  - [x] **Multiplication with overflow detection**
    - [x] Check ERR propagation
    - [x] Perform multiplication with overflow check
    - [x] Emit LLVM IR: `llvm.smul.with.overflow`
  - [x] **Division with error checking**
    - [x] Check ERR propagation
    - [x] Check division by zero ‚Üí return ERR
    - [x] Handle MIN / -1 overflow ‚Üí return ERR
  - [x] **Modulo operation**
    - [x] Same error propagation rules implemented
  - [x] **Negation safety**
    - [x] Special case: -ERR = ERR (sticky)
    - [x] Check if negation would overflow ‚Üí ERR
    - [x] Example: tbb8(-127) negates to +127 (safe!)
  - [x] **Tests validate all operations**: 26/26 passing
    - [ ] No overflow possible with symmetric range
  - [ ] Add comprehensive tests in `tests/codegen/test_tbb_arithmetic.cpp`
    - [ ] Test sticky error propagation: ERR + 5 = ERR
    - [ ] Test overflow detection: tbb8(100) + tbb8(50) = ERR
    - [ ] Test symmetric negation: -127 ‚Üí +127
    - [ ] Test chained operations: (ERR + 5) * 10 = ERR

#### 1.1.3 TBB Comparison Operations
- [ ] Implement TBB comparison in `ExprCodeGen`
  - [ ] ERR comparisons: ERR == ERR ‚Üí true, ERR != anything ‚Üí true
  - [ ] Normal comparisons work as expected
  - [ ] Document comparison semantics

#### 1.1.4 TBB-Regular Type Interactions
- [ ] Define implicit/explicit conversion rules
  - [ ] int32 ‚Üí tbb32: check range, emit ERR if out of bounds
  - [ ] tbb32 ‚Üí int32: check for ERR, handle appropriately
  - [ ] Document conversion semantics

### 1.2 Exotic Types (Balanced Ternary/Nonary) - NON-NEGOTIABLE
**Status**: Tokens/Parser done, waiting on research  
**Dependencies**: research_002, research_003

#### 1.2.1 Trit/Tryte Implementation ‚úÖ COMPLETE (v0.0.15 - Dec 14, 2025)
**Research Status**: ‚úÖ research_002 (612 lines) - Balanced Ternary Arithmetic
**Implementation Status**: ‚úÖ COMPLETE (commit e81c29d)

**Key Implementation Details**:
- Split-Byte Packing: 10 trits in uint16 (90.1% efficiency)
  * Low byte (bits 0-7): Trits 0-4
  * High byte (bits 8-15): Trits 5-9  
  * Each 5-trit chunk with bias of 121
- Range: [-29,524, +29,524]
- ERR Sentinel: 0xFFFF (65,535)
- O(1) Unpacking: 256-entry lookup table
- Sticky Error Propagation: ERR + x = ERR, overflow ‚Üí ERR

**Files Implemented**:
- [x] `src/backend/ternary_ops.{h,cpp}` - Runtime operations (237 + 329 lines)
  - [x] TernaryOps class with pack/unpack
  - [x] 256-entry LUT for O(1) trybble unpacking
  - [x] Ternary addition with carry propagation
  - [x] Symmetric negation (trit inversion)
  - [x] Shift-and-add multiplication
  - [x] Non-restoring division
  - [x] Binary‚Üîternary conversion with carry adjustment
- [x] `src/backend/ternary_runtime.cpp` - C linkage wrappers (157 lines)
  - [x] aria_tryte_add, sub, mul, div, mod
  - [x] aria_tryte_negate
  - [x] aria_tryte_eq, ne, lt, le, gt, ge
  - [x] aria_int32_to_tryte, aria_tryte_to_int32
- [x] `src/backend/codegen_ternary.{h,cpp}` - LLVM IR generation (182 + 276 lines)
  - [x] TernaryLowerer class
  - [x] Runtime function declarations
  - [x] IR generation for all operations
- [x] `tests/ternary/test_ternary_ops.cpp` - Comprehensive tests (11/11 passing)
  - [x] Binary ‚Üî tryte conversion (zero, positive, negative, max, min)
  - [x] Addition (positive, negative, overflow)
  - [x] Subtraction (negative results)
  - [x] Multiplication (sign handling)
  - [x] Division (divide-by-zero protection)
  - [x] Negation and double negation
  - [x] Sticky error propagation
  - [x] Overflow detection
  - [x] Pack/unpack trit arrays
  - [x] Out-of-range validation

#### 1.2.2 Nit/Nyte Implementation ‚úÖ COMPLETE (v0.0.12 - Dec 11, 2025)
**Research Status**: ‚úÖ Received Dec 11, 2025 (59KB report)
**Implementation Status**: ‚úÖ COMPLETE (3.5 hours)

**Key Implementation Details**:
- Biased-Radix Packing: `stored = value + 29524`
- Zero = 0x7354, Min = 0x0000, Max = 0xE6A8, ERR = 0xFFFF
- Optimized arithmetic: Direct bias operations
- Comparison: O(1) unsigned less-than (monotonic encoding)
- Performance: 50-70% of native int16 with safety guarantees
- SIMD-ready: 8 nytes per SSE register

**Files Implemented**:
- [x] `src/backend/nonary_ops.{h,cpp}` - Runtime operations (360 lines)
- [x] `src/backend/codegen_nonary.{h,cpp}` - LLVM codegen (242 lines)
- [x] `src/backend/nonary_runtime.cpp` - C linkage wrappers (91 lines)
- [x] `docs/BALANCED_NONARY_STATUS.md` - Complete documentation

**Operations Implemented**:
- [x] Create runtime library with NonaryOps class
  - [x] Implement `aria_nyte_add(uint16_t a, uint16_t b)` with bias logic
  - [x] Implement `aria_nyte_sub(uint16_t a, uint16_t b)`
  - [x] Implement `aria_nyte_mul(uint16_t a, uint16_t b)` with 64-bit intermediate
  - [x] Implement `aria_nyte_div(uint16_t a, uint16_t b)` with zero check
  - [x] Implement `aria_nyte_mod(uint16_t a, uint16_t b)` modulo operation
  - [x] Implement `aria_nyte_negate(uint16_t a)` negation
  - [x] Add sticky ERR propagation to all operations
- [x] Create packing/unpacking functions
  - [x] `packNyte()`: Pack value into biased uint16 (value + 29524)
  - [x] `unpackNyte()`: Extract value from biased uint16 (stored - 29524)
  - [x] `isValidNyte()`: Check if uint16 is valid nyte (‚â§ 0xE6A8)
  - [x] Document bias = 29524, range [-29524, +29524]
- [x] Implement binary‚Üînonary string conversion
  - [x] `unpackValue()`: Extract int32 value (stored - 29524)
  - [x] `packValue()`: Pack int32 with range check
  - [x] `toString()`: Convert to balanced nonary digits (-4..+4)
  - [x] `nitToString()`: Format individual nit values
- [x] Extend codegen for nit/nyte operations
  - [x] NonaryLowerer class with LLVM IR generation
  - [x] Runtime function declarations
  - [x] Map nit to i8 (native), nyte to i16 (packed)
  - [x] Use optimized comparison (direct uint16 compare)
- [x] Add comprehensive tests (26/26 passing)
  - [x] Test biased arithmetic correctness
  - [x] Test ERR sentinel propagation (sticky errors)
  - [x] Test edge cases (min/max values, overflow ‚Üí ERR)
  - [x] Test comparison operations (monotonic encoding)

### 1.3 Vector Types (vec2, vec3, vec4) ‚úÖ COMPLETE (v0.0.13 - Dec 11, 2025)
**Status**: Runtime + SIMD codegen complete
**Implementation Time**: ~2 hours
**Test Results**: 25/25 passing

**Files Implemented**:
- [x] `src/backend/vector_ops.{h,cpp}` - Runtime operations (Vec2/3/4, DVec2/3/4, IVec2/3/4)
- [x] `src/backend/codegen_vector.{h,cpp}` - LLVM SIMD codegen (VectorLowerer class)
- [x] `src/backend/vector_runtime.cpp` - C linkage wrappers
- [x] `tests/vector/test_vector_ops.cpp` - 25 comprehensive tests

**Operations Implemented**:
- [x] Vector arithmetic (add, sub, mul, div, scale, negate)
- [x] Vector operations (dot product, cross product, length, normalize, distance)
- [x] Component access (extract/insert elements)
- [x] Swizzling (shufflevector for efficient reordering)
- [x] SIMD optimization (LLVM fixed-size vectors, fmul/fadd/fsub)
- [x] Comparison (component-wise with epsilon tolerance)

**SIMD Features**:
- [x] Uses LLVM FixedVectorType for hardware acceleration
- [x] Horizontal add for dot product
- [x] LLVM sqrt/fabs intrinsics
- [x] Shufflevector for swizzling (zero-cost abstraction)

**Test Coverage**:
- [x] Vec2/3/4 construction and arithmetic (8 tests)
- [x] Vector operations: dot, cross, length, normalize (9 tests)
- [x] Edge cases: zero vectors, perpendicular, self-cross (8 tests)
- All tests passing with float precision tolerance

### 1.4 Compound Types ‚úÖ COMPLETE (v0.0.14 - Dec 11, 2025)

#### 1.4.1 Tensor Type Implementation ‚úÖ
**Status**: Runtime complete, 22/22 tests passing
**Implementation Time**: ~10 minutes

**Files Implemented**:
- [x] `src/backend/tensor_ops.h` - Template-based tensor class (320 lines)
- [x] `tests/tensor/test_tensor_ops.cpp` - Comprehensive tests (22/22 passing)

**Operations Implemented**:
- [x] N-dimensional array construction (1D, 2D, 3D, arbitrary rank)
- [x] Row-major memory layout (C-style, cache-friendly)
- [x] Multi-dimensional indexing with stride calculation
- [x] Reshape (constant size, view change)
- [x] Transpose (2D tensors)
- [x] Element-wise arithmetic (add, sub, mul, scale)
- [x] Matrix multiplication (optimized inner loop)
- [x] Reductions (sum, mean)
- [x] Type specializations (TensorF32, TensorF64, TensorI32, TensorI64)

**Test Coverage**:
- [x] Construction: 1D/2D/3D tensors, fill values, from data (5 tests)
- [x] Indexing: Multi-dimensional access, row-major layout (4 tests)
- [x] Reshape: 2D‚Üî1D, arbitrary dimensions (3 tests)
- [x] Transpose: 2D matrix transposition (1 test)
- [x] Arithmetic: Element-wise ops, scalar multiply (4 tests)
- [x] Matrix multiplication: 2x2, 2x3√ó3x2 (2 tests)
- [x] Reductions: sum, mean (2 tests)
- [x] Integer tensors: TensorI32 operations (1 test)

#### 1.4.2 Matrix Type Implementation
- [ ] Define `MatrixType` in AST
  - [ ] Support NxM matrices
  - [ ] Specialized 2D tensor representation
- [ ] Implement matrix operations
  - [ ] Matrix addition/subtraction
  - [ ] Matrix multiplication (optimized)
  - [ ] Transpose
  - [ ] Determinant
  - [ ] Inverse
- [ ] CodeGen for matrices
  - [ ] Use BLAS/LAPACK when available
  - [ ] Optimize memory access patterns
  - [ ] SIMD acceleration
- [ ] Add tests

### 1.5 System Types for Standard Library

#### 1.5.1 Binary Type
- [ ] Define `BinaryType` for raw byte data
- [ ] Implement binary operations
- [ ] Add serialization/deserialization
- [ ] CodeGen and tests

#### 1.5.2 Buffer Type
- [ ] Define `BufferType` for memory buffers
- [ ] Implement buffer operations (read, write, resize)
- [ ] Add bounds checking
- [ ] CodeGen and tests

#### 1.5.3 Stream Type
- [ ] Define `StreamType` for I/O streams
- [ ] Implement stream operations (read, write, seek, close)
- [ ] Add buffering support
- [ ] CodeGen and tests

#### 1.5.4 Process Type
- [ ] Define `ProcessType` for OS processes
- [ ] Implement process operations (spawn, wait, kill, communicate)
- [ ] Add platform-specific implementations
- [ ] CodeGen and tests

#### 1.5.5 Pipe Type
- [ ] Define `PipeType` for IPC
- [ ] Implement pipe operations (read, write, close)
- [ ] Add bidirectional pipe support
- [ ] CodeGen and tests

---

## PHASE 2: Memory Safety & Borrow Checking
**Goal**: Implement Rust-style borrow checker for wild memory safety  
**Dependencies**: research_001 MUST be complete  
**Timeline**: 4-6 weeks  
**Priority**: CRITICAL (core safety feature)

### 2.1 Lifetime Analysis System
**Status**: Stubs exist, need full implementation  
**Reference**: `/docs/research/wildx_memory_regions.md` (Appendage Theory)

#### 2.1.1 Lifetime Annotation Framework
- [ ] After receiving research_001 response, extract lifetime algorithm
- [ ] Create `LifetimeAnalyzer` class in `src/frontend/sema/lifetime_analyzer.cpp`
  - [ ] Define lifetime representation
    - [ ] Named lifetimes: 'a, 'b, 'static
    - [ ] Anonymous lifetimes (inferred)
    - [ ] Lifetime bounds and constraints
  - [ ] Implement lifetime inference
    - [ ] Function parameter lifetimes
    - [ ] Return value lifetime elision
    - [ ] Struct field lifetimes
  - [ ] Build lifetime dependency graph
    - [ ] Track lifetime relationships
    - [ ] Detect lifetime conflicts
    - [ ] Validate lifetime hierarchies
  - [ ] Add tests for lifetime inference

#### 2.1.2 Borrow Checker Core
- [ ] Implement `BorrowChecker` class (expand existing stub)
  - [ ] **Borrow rules implementation**
    - [ ] Rule 1: Multiple immutable borrows allowed
    - [ ] Rule 2: Only one mutable borrow at a time
    - [ ] Rule 3: No mutable borrow while immutable borrows exist
    - [ ] Rule 4: Borrows must not outlive referent
  - [ ] **Borrow tracking**
    - [ ] Track active borrows per scope
    - [ ] Track borrow kind (immutable vs mutable)
    - [ ] Track borrow lifetime
  - [ ] **Validation logic**
    - [ ] Check for conflicting borrows
    - [ ] Check for use-after-free
    - [ ] Check for dangling references
  - [ ] **Error reporting**
    - [ ] Clear borrow conflict messages
    - [ ] Show conflicting borrow locations
    - [ ] Suggest fixes (e.g., scope reduction)
  - [ ] Add comprehensive tests
    - [ ] Test basic borrow rules
    - [ ] Test complex borrowing patterns
    - [ ] Test error messages

#### 2.1.3 Pinning Operator (#) Implementation
- [ ] Implement `#` (pin) operator semantics
  - [ ] Parse pinning expressions
  - [ ] Type check pinned values
  - [ ] Generate pinning metadata
- [ ] Integrate with GC
  - [ ] Mark pinned objects in GC header
  - [ ] Prevent GC from moving pinned objects
  - [ ] Auto-unpin when scope ends
- [ ] CodeGen for pinning
  - [ ] Emit pin markers in LLVM IR
  - [ ] Generate cleanup code (unpin on scope exit)
  - [ ] Handle pinning errors
- [ ] Add tests
  - [ ] Test pinning GC objects
  - [ ] Test pinning in closures
  - [ ] Test pinning with async

#### 2.1.4 Appendage Theory Integration
- [ ] Review `/docs/research/wildx_memory_regions.md`
- [ ] Implement GC body + wild appendages model
  - [ ] Track appendages attached to GC objects
  - [ ] Enforce borrow rules for appendages
  - [ ] Cleanup appendages when body is collected
- [ ] Add lifetime tracking for appendages
  - [ ] Appendage lifetime tied to body lifetime
  - [ ] Prevent dangling appendage references
- [ ] CodeGen for appendages
  - [ ] Emit appendage registration
  - [ ] Emit cleanup code
- [ ] Add tests

### 2.2 Escape Analysis
**Status**: Stub exists, needs implementation

#### 2.2.1 Escape Analysis Pass
- [ ] Expand `EscapeAnalyzer` class
  - [ ] Implement control flow analysis
  - [ ] Track value flow through program
  - [ ] Identify values that escape function scope
  - [ ] Identify values that escape to heap
- [ ] Integration with memory allocation
  - [ ] Auto-promote stack‚Üíheap when necessary
  - [ ] Warn about unnecessary heap allocations
  - [ ] Suggest stack allocation when safe
- [ ] Add tests

### 2.3 Safe Reference ($) Operator
**Status**: Token exists, needs full implementation

#### 2.3.1 Safe Reference Implementation
- [ ] Implement `$` operator semantics
  - [ ] Safe references can't dangle
  - [ ] Enforced by borrow checker
  - [ ] Used in till loops and safe contexts
- [ ] Type checking for safe references
- [ ] CodeGen for safe references
- [ ] Add tests

---

## PHASE 3: Module System & Visibility
**Goal**: Implement complete module system with imports and visibility  
**Dependencies**: None (can run parallel to Phase 1/2)  
**Timeline**: 3-4 weeks  
**Priority**: HIGH (necessary for stdlib organization)

### 3.1 Module Resolution

#### 3.1.1 Module Path Resolution
- [ ] Review existing research: `/docs/research/module_system_implementation.md`
- [ ] Implement `ModuleResolver` class in `src/frontend/module_resolver.cpp`
  - [ ] **Path resolution strategies**
    - [ ] Relative imports: `use "./local.aria"`
    - [ ] Absolute imports: `use "/usr/lib/aria/module"`
    - [ ] Standard library imports: `use std.io`
    - [ ] Selective imports: `use std.collections.{array, map}`
    - [ ] Wildcard imports: `use math.*`
  - [ ] **Module search paths**
    - [ ] Current directory
    - [ ] Project source directory
    - [ ] Standard library path ($ARIA_LIB)
    - [ ] User-defined paths (ARIA_PATH environment variable)
  - [ ] **File resolution**
    - [ ] .aria file extension handling
    - [ ] Directory modules (module.aria or mod.aria in directory)
    - [ ] Index file support
  - [ ] Add tests for path resolution

#### 3.1.2 Module Dependency Graph
- [ ] Implement dependency tracking
  - [ ] Build directed acyclic graph (DAG) of modules
  - [ ] Detect circular dependencies ‚Üí error
  - [ ] Topological sort for compilation order
- [ ] Handle module initialization order
  - [ ] Ensure dependencies initialized before dependents
  - [ ] Generate static initializer calls
- [ ] Add tests
  - [ ] Test simple dependencies
  - [ ] Test complex dependency chains
  - [ ] Test circular dependency detection

### 3.2 Module Definition (mod keyword)

#### 3.2.1 Module Declaration
- [ ] Implement module declaration parsing (already done)
- [ ] Type checking for modules
  - [ ] Validate module names (no conflicts)
  - [ ] Check for duplicate definitions
  - [ ] Validate nested modules
- [ ] CodeGen for modules
  - [ ] Generate module namespace
  - [ ] Emit module metadata
  - [ ] Handle nested modules
- [ ] Add tests

### 3.3 Visibility Control (pub keyword)

#### 3.3.1 Visibility Rules Implementation
- [ ] Implement visibility checker in type checker
  - [ ] Private by default (no `pub`)
  - [ ] Public when `pub` specified
  - [ ] Check access violations
    - [ ] Can't access private items from outside module
    - [ ] Can access public items from anywhere
  - [ ] Nested module visibility rules
    - [ ] Parent can access child's private items
    - [ ] Child can access parent's private items
    - [ ] Siblings need `pub` for access
- [ ] Add visibility to all declarations
  - [ ] Functions
  - [ ] Structs
  - [ ] Traits
  - [ ] Impls
  - [ ] Constants
  - [ ] Type aliases
- [ ] Generate clear error messages for visibility violations
- [ ] Add tests

### 3.4 Import System (use keyword)

#### 3.4.1 Import Declaration Processing
- [ ] Implement import resolution
  - [ ] Simple imports: `use std.io`
  - [ ] Selective imports: `use std.{io, fs}`
  - [ ] Aliased imports: `use "./utils.aria" as utils`
  - [ ] Wildcard imports: `use math.*`
- [ ] Build import table for each module
- [ ] Resolve imported symbols
  - [ ] Map import names to module symbols
  - [ ] Handle name conflicts ‚Üí error
  - [ ] Support nested imports
- [ ] CodeGen for imports
  - [ ] Link imported modules
  - [ ] Generate import metadata
- [ ] Add tests

### 3.5 External C Integration (extern keyword)

#### 3.5.1 C FFI Implementation
- [ ] Implement `extern` block parsing (already done)
- [ ] Type mapping: Aria ‚Üî C
  - [ ] int8 ‚Üî int8_t
  - [ ] int32 ‚Üî int32_t
  - [ ] string ‚Üî char*
  - [ ] pointers ‚Üî pointers
  - [ ] arrays ‚Üî arrays
- [ ] Call convention handling
  - [ ] Default C calling convention
  - [ ] Platform-specific conventions (cdecl, stdcall, etc.)
- [ ] Symbol resolution
  - [ ] Dynamic library loading
  - [ ] Static library linking
- [ ] CodeGen for extern functions
  - [ ] Emit LLVM external declarations
  - [ ] Generate wrapper functions if needed
  - [ ] Handle varargs (printf, etc.)
- [ ] Add tests
  - [ ] Test calling libc functions
  - [ ] Test external libraries

### 3.6 Conditional Compilation

#### 3.6.1 cfg() Attribute System
- [ ] Implement conditional compilation attributes
  - [ ] Platform detection: `cfg(target_os = "linux")`
  - [ ] Feature flags: `cfg(feature = "networking")`
  - [ ] Architecture: `cfg(target_arch = "x86_64")`
- [ ] Parse cfg attributes
- [ ] Evaluate cfg conditions at compile time
- [ ] Remove disabled code from compilation
- [ ] Add tests

---

## PHASE 4: Generics & Monomorphization
**Goal**: Zero-cost generic programming via monomorphization  
**Dependencies**: Type system complete (Phase 1)  
**Timeline**: 4-5 weeks  
**Priority**: HIGH (core abstraction mechanism)

### 4.1 Generic Type Parameters

#### 4.1.1 Type Parameter Parsing & Validation
- [ ] Review existing research: `/docs/research/generics_monomorphization_implementation.md`
- [ ] Enhance generic function parsing (basic parsing exists)
  - [ ] Parse type parameter lists: `<T, U, V>`
  - [ ] Parse type parameter constraints (bounds)
  - [ ] Parse where clauses (if needed)
- [ ] Type checking for generics
  - [ ] Validate type parameter names (no conflicts)
  - [ ] Check constraint satisfaction
  - [ ] Validate generic function bodies
    - [ ] Ensure `*T` used correctly
    - [ ] Check operations valid for generic types
  - [ ] Handle recursive generic definitions
- [ ] Add tests

#### 4.1.2 Type Inference System
- [ ] Implement type inference for generic calls
  - [ ] Infer type arguments from function arguments
  - [ ] Infer from return type context
  - [ ] Infer from multiple sources (unification)
- [ ] Implement unification algorithm
  - [ ] Unify type variables
  - [ ] Detect unification failures ‚Üí error
  - [ ] Generate clear error messages
- [ ] Add tests
  - [ ] Test simple inference: `max(1, 2)` ‚Üí `max<int32>`
  - [ ] Test complex inference: nested generics
  - [ ] Test inference failures

### 4.2 Monomorphization Pass

#### 4.2.1 Monomorphization Implementation
- [ ] Create `MonomorphizationPass` in `src/backend/monomorphization.cpp` (stub exists)
  - [ ] **Collect generic instantiations**
    - [ ] Scan AST for generic function calls
    - [ ] Record (function, type args) pairs
    - [ ] Handle transitive instantiations (generic calls generic)
  - [ ] **Generate specialized versions**
    - [ ] Clone function AST
    - [ ] Substitute type parameters with concrete types
      - [ ] Replace `*T` with concrete type
      - [ ] Update all type references
    - [ ] Rename specialized function (mangling)
      - [ ] Example: `max<int32>` ‚Üí `max_int32`
      - [ ] Handle multiple type parameters
  - [ ] **Deduplication**
    - [ ] Cache generated specializations
    - [ ] Reuse existing specializations
    - [ ] Avoid duplicate codegen
  - [ ] **Update call sites**
    - [ ] Replace generic calls with specialized calls
    - [ ] Update function references
- [ ] Add comprehensive tests
  - [ ] Test simple generics: `identity<T>`
  - [ ] Test multiple type parameters: `convert<T,U>`
  - [ ] Test generic structs (if supported)
  - [ ] Test transitive instantiation
  - [ ] Test large-scale monomorphization (compile time impact)

### 4.3 Generic Structs (if in spec)

#### 4.3.1 Generic Struct Support
- [ ] Check spec for generic struct syntax
- [ ] If supported, implement:
  - [ ] Parse generic struct definitions
  - [ ] Type check generic structs
  - [ ] Monomorphize struct definitions
  - [ ] Generate specialized struct types
  - [ ] Update field access codegen
- [ ] Add tests

### 4.4 Generic Traits (if in spec)

#### 4.4.1 Generic Trait Support
- [ ] Check spec for generic trait syntax
- [ ] If supported, implement:
  - [ ] Parse generic trait definitions
  - [ ] Type check generic traits
  - [ ] Monomorphize trait impls
  - [ ] Update trait dispatch
- [ ] Add tests

---

## PHASE 5: Standard Library - Core
**Goal**: Implement essential stdlib functions per spec  
**Dependencies**: Type system (Phase 1), Module system (Phase 3)  
**Timeline**: 3-4 weeks  
**Priority**: HIGH (basic functionality)

### 5.1 Memory Management Functions

#### 5.1.1 Allocator Functions
- [ ] Implement in `stdlib/memory.aria` or `src/runtime/stdlib/memory.cpp`
  - [ ] `aria.alloc(size: uint64) -> result<void*, string>`
    - [ ] Wrapper around mimalloc
    - [ ] Return error on allocation failure
    - [ ] Add tests
  - [ ] `aria.free(ptr: void*)`
    - [ ] Wrapper around free
    - [ ] Null pointer handling
    - [ ] Add tests
  - [ ] `aria.gc_alloc(size: uint64) -> result<void*, string>`
    - [ ] Allocate in GC nursery
    - [ ] Register with GC
    - [ ] Add tests
  - [ ] `aria.alloc_buffer(size: uint64) -> result<buffer, string>`
    - [ ] Specialized buffer allocation
    - [ ] Add metadata (size, capacity)
    - [ ] Add tests
  - [ ] `aria.alloc_string(size: uint64) -> result<string, string>`
    - [ ] String-specific allocation
    - [ ] UTF-8 handling
    - [ ] Add tests
  - [ ] `aria.alloc_array(elem_size: uint64, count: uint64) -> result<array, string>`
    - [ ] Array allocation with size info
    - [ ] Bounds checking metadata
    - [ ] Add tests

### 5.2 String Functions

#### 5.2.1 Basic String Operations
- [ ] Implement in `stdlib/string.aria`
  - [ ] `string.length() -> int64`
  - [ ] `string.concat(other: string) -> string`
  - [ ] `string.substring(start: int64, end: int64) -> string`
  - [ ] `string.indexOf(substr: string) -> int64`
  - [ ] `string.split(delimiter: string) -> array<string>`
  - [ ] `string.trim() -> string`
  - [ ] `string.toUpper() -> string`
  - [ ] `string.toLower() -> string`
  - [ ] Add comprehensive tests

### 5.3 Array Functions

#### 5.3.1 Functional Array Operations
- [ ] Implement in `stdlib/array.aria`
  - [ ] `filter<T>(arr: *T[], pred: func(*T) -> bool) -> *T[]`
    - [ ] Filter elements by predicate
    - [ ] Use generics for type safety
    - [ ] Add tests
  - [ ] `transform<T,U>(arr: *T[], f: func(*T) -> *U) -> *U[]`
    - [ ] Map function over array
    - [ ] Support type transformation
    - [ ] Add tests (also called `map`)
  - [ ] `reduce<T,U>(arr: *T[], f: func(*U, *T) -> *U, init: *U) -> *U`
    - [ ] Fold array into single value
    - [ ] Generic accumulator type
    - [ ] Add tests
  - [ ] `sort<T>(arr: *T[], cmp: func(*T, *T) -> int) -> *T[]`
    - [ ] Generic sorting with comparator
    - [ ] Use quicksort or mergesort
    - [ ] Add tests
  - [ ] `reverse<T>(arr: *T[]) -> *T[]`
    - [ ] Reverse array in-place or return new
    - [ ] Add tests
  - [ ] `unique<T>(arr: *T[]) -> *T[]`
    - [ ] Remove duplicates
    - [ ] Preserve order
    - [ ] Add tests

### 5.4 Math Functions

#### 5.4.1 Basic Math Operations
- [ ] Implement in `stdlib/math.aria`
  - [ ] `Math.round(x: flt64) -> flt64`
  - [ ] `Math.floor(x: flt64) -> flt64`
  - [ ] `Math.ceil(x: flt64) -> flt64`
  - [ ] `Math.abs(x: flt64) -> flt64`
  - [ ] `Math.sqrt(x: flt64) -> flt64`
  - [ ] `Math.pow(x: flt64, y: flt64) -> flt64`
  - [ ] `Math.sin(x: flt64) -> flt64`
  - [ ] `Math.cos(x: flt64) -> flt64`
  - [ ] `Math.tan(x: flt64) -> flt64`
  - [ ] Add comprehensive tests

### 5.5 System Diagnostics

#### 5.5.1 Diagnostic Functions
- [ ] Implement in `stdlib/system.aria`
  - [ ] `getMemoryUsage() -> obj`
    - [ ] Return heap usage, GC stats, etc.
    - [ ] Add tests
  - [ ] `getActiveConnections() -> int64`
    - [ ] Count active network connections
    - [ ] Add tests

---

## PHASE 6: Standard Library - I/O
**Goal**: Implement file I/O, streams, and process management  
**Dependencies**: research_004, research_005, research_006  
**Timeline**: 4-5 weeks  
**Priority**: HIGH (critical for real applications)

### 6.1 File I/O System
**Status**: Awaiting research_004

#### 6.1.1 Basic File Operations
- [ ] After research_004 complete, review API design
- [ ] Implement in `stdlib/io/file.aria` or `src/runtime/io/file.cpp`
  - [ ] **readFile(path: string) -> result<string, string>**
    - [ ] Open file (error handling)
    - [ ] Read entire contents
    - [ ] Return error result on failure
    - [ ] Platform-specific implementations
      - [ ] Linux: use open/read/close
      - [ ] Windows: use CreateFile/ReadFile/CloseHandle
    - [ ] Add tests
      - [ ] Test successful reads
      - [ ] Test file not found
      - [ ] Test permission denied
      - [ ] Test large files
  - [ ] **writeFile(path: string, content: string) -> result<void, string>**
    - [ ] Create/truncate file
    - [ ] Write content
    - [ ] Error handling (disk full, permissions, etc.)
    - [ ] Add tests
  - [ ] **readJSON(path: string) -> result<obj, string>**
    - [ ] Read file
    - [ ] Parse JSON
    - [ ] Return structured object
    - [ ] Add JSON parser if not exists
    - [ ] Add tests
  - [ ] **readCSV(path: string) -> result<array<array<string>>, string>**
    - [ ] Read file
    - [ ] Parse CSV
    - [ ] Handle quoted fields, escaping
    - [ ] Add tests

#### 6.1.2 Stream-Based File I/O
- [ ] **openFile(path: string, mode: string) -> result<stream, string>**
  - [ ] Modes: "r" (read), "w" (write), "a" (append), "r+" (read/write)
  - [ ] Return stream object
  - [ ] Error handling
  - [ ] Add tests
- [ ] Implement `stream` type operations
  - [ ] `stream.read(size: int64) -> result<string, string>`
  - [ ] `stream.readLine() -> result<string, string>`
  - [ ] `stream.write(data: string) -> result<void, string>`
  - [ ] `stream.seek(offset: int64, whence: int) -> result<void, string>`
  - [ ] `stream.tell() -> result<int64, string>`
  - [ ] `stream.close() -> result<void, string>`
  - [ ] Add tests for all operations

### 6.2 Modern I/O Streams (6-Stream System) ‚úÖ RESEARCH COMPLETE
**Status**: ‚úÖ Research complete (research_006, 388 lines)
**Reference**: `/docs/IO_STREAMS_IMPLEMENTATION_PLAN.md` (detailed 8-week plan)
**Dependencies**: Phase 5 (file I/O), Phase 7 (async runtime)
**Timeline**: 8 weeks

**Key Design**: Replaces 3-stream Unix model with semantic separation:
- **Text Plane** (stdin/stdout/stderr): Human interaction, line-buffered, UTF-8
- **Data Plane** (stddati/stddato): Binary pipelines, block-buffered, zero-copy
- **Observability** (stddbg): Diagnostics, async ring-buffered, drop-on-full

#### 6.2.1 Runtime Stream Infrastructure (2 weeks)
- [ ] Create `src/runtime/stream.cpp` with base Stream trait
  - [ ] Text I/O: `write()`, `writeLine()`, `readLine()` (UTF-8 enforced)
  - [ ] Binary I/O: `writeBytes()`, `readBytes()`, `readInto()` (wild buffers)
  - [ ] TBB I/O: `writeTBB8/16/32/64()`, `readTBB8/16/32/64()` (sentinel-safe)
  - [ ] Utility: `flush()`, `close()`, `isatty()`
- [ ] Create DebugStream specialization for stddbg
  - [ ] `log(level, msg, data)`, `warn()`, `error()` methods
  - [ ] Structured logging (JSON lines or custom format)
- [ ] Create DataStream specialization for stddati/stddato
  - [ ] Binary protocol support
  - [ ] Endianness handling (Network Byte Order default)
- [ ] Create buffering implementations in `src/runtime/io_buffers.cpp`
  - [ ] LineBuffer: 1-4KB, flush on newline (text streams)
  - [ ] BlockBuffer: 64KB+, dynamic sizing (data streams)
  - [ ] AsyncRingBuffer: SPSC lock-free, drop-on-full (stddbg)

#### 6.2.2 Platform-Specific Backends (2 weeks)
- [ ] Create `src/runtime/io_linux.cpp`
  - [ ] Initialize FDs 3-5 using `fcntl(F_GETFD)` validation
  - [ ] Default provisioning: stddbg‚Üí/dev/null or $ARIA_LOG_FILE
  - [ ] Process spawning: `dup2()` for pipe wiring to FDs 3-5
  - [ ] Zero-copy: `splice()` syscall for stddati‚Üístddato
  - [ ] Conditional compilation: `cfg(target_os = "linux")`
- [ ] Create `src/runtime/io_windows.cpp`
  - [ ] Initialize HANDLEs via `CreatePipe()` for anonymous pipes
  - [ ] Handle passing: env var `__ARIA_STREAMS=DBG:<val>;IN:<val>;OUT:<val>`
  - [ ] Runtime reconstruction: parse env var, cast to HANDLEs
  - [ ] Named pipes: `\\.\pipe\aria-debug-*` for persistent IPC
  - [ ] Conditional compilation: `cfg(target_os = "windows")`
- [ ] Create `src/runtime/io_init.cpp`
  - [ ] Global singleton initialization for all 6 streams
  - [ ] Platform detection and backend selection
  - [ ] Early runtime initialization (before main)

#### 6.2.3 High-Level API (1 week)
- [ ] Implement global stream objects in `std.io` module
  - [ ] `io.stdin`: Stream (FD 0, text, line-buffered)
  - [ ] `io.stdout`: Stream (FD 1, text, line-buffered)
  - [ ] `io.stderr`: Stream (FD 2, text, line-buffered)
  - [ ] `io.stddbg`: DebugStream (FD 3, structured, async ring)
  - [ ] `io.stddati`: DataStream (FD 4, binary, block-buffered)
  - [ ] `io.stddato`: DataStream (FD 5, binary, block-buffered)
- [ ] Implement cross-platform normalization
  - [ ] Line ending: `\r\n`‚Üí`\n` on input, `\n`‚Üí`\r\n` on Windows output
  - [ ] UTF-8 validation: enforce on text streams, reject invalid sequences
  - [ ] Binary streams: no normalization, raw bytes
- [ ] Thread safety
  - [ ] Mutex locking per stream (atomic writes)
  - [ ] Buffer pinning: `#` operator for GC-managed buffers during syscalls
  - [ ] Wild memory: zero-copy I/O without pinning overhead

#### 6.2.4 Process Integration (1 week)
- [ ] Enhance `spawn()` API in `src/runtime/process/`
  - [ ] Stream redirection configuration:
    ```aria
    spawn("./processor", {
      stdin: io.stdin,
      stdout: io.stdout,
      stderr: io.stderr,
      stddbg: openFile("debug.log", "w"),
      stddati: pipe_reader,
      stddato: pipe_writer
    });
    ```
  - [ ] Pipe wiring for FDs 3-5 (Linux: dup2, Windows: STARTUPINFOEX)
  - [ ] Handle inheritance (Windows: bInheritHandle=TRUE)
- [ ] Create `createPipe()` utility
  - [ ] Return pipe with read/write ends
  - [ ] Compatible with stream interface
  - [ ] Support for complex pipelines

#### 6.2.5 Async Integration (1 week)
- [ ] Register FDs 3-5 with event loop
  - [ ] Linux: `epoll` for all file descriptors
  - [ ] macOS: `kqueue`
  - [ ] Windows: `IOCP` for HANDLEs
- [ ] Implement async methods on Stream trait
  - [ ] `readAsync(size)`: suspend coroutine if no data
  - [ ] `writeAsync(data)`: suspend if buffer full
  - [ ] Coroutine resumption on data available (epoll signal)
- [ ] Backpressure management
  - [ ] Stop reading from FD if ring buffer fills
  - [ ] Kernel pipe/socket buffer fills ‚Üí sender throttles
  - [ ] Automatic flow control prevents OOM

#### 6.2.6 Testing & Documentation (1 week)
- [ ] Unit tests in `tests/io/`
  - [ ] `test_text_io.cpp`: line buffering, UTF-8 validation, newline normalization
  - [ ] `test_binary_io.cpp`: zero-copy, raw bytes, no corruption
  - [ ] `test_debug_stream.cpp`: structured logging, async buffering
  - [ ] `test_tbb_serialization.cpp`: sentinel-safe TBB read/write
  - [ ] `test_pipelines.cpp`: multi-process stddato‚Üístddati chains
- [ ] Integration tests
  - [ ] ML pipeline simulation: binary tensors + text progress + debug logs
  - [ ] Stress tests: async I/O with high concurrency
  - [ ] Cross-platform: Ubuntu + Windows validation
- [ ] Documentation
  - [ ] API reference: `/docs/stdlib/io_streams.md`
  - [ ] Usage examples: text I/O, binary pipelines, debug logging
  - [ ] Migration guide: 3-stream ‚Üí 6-stream transition

#### 6.2.7 Security Hardening
- [ ] Implement stddbg secure mode
  - [ ] Environment variable: `ARIA_SECURE_MODE=1` ‚Üí redirect to /dev/null
  - [ ] Compile-time stripping: `cfg(release)` removes stddbg calls
- [ ] WildX protection
  - [ ] Type system: forbid passing `wildx` pointers to stream writes
  - [ ] Compiler error: security violation at compile time

### 6.3 Process Management
**Status**: Awaiting research_005

#### 6.3.1 Process Creation & Control
- [ ] After research_005 complete, review API design
- [ ] Implement in `stdlib/process.aria` or `src/runtime/process/`
  - [ ] **spawn(command: string, args: array<string>) -> result<process, string>**
    - [ ] Platform-specific implementations
      - [ ] Unix: fork + exec
      - [ ] Windows: CreateProcess
    - [ ] Return process handle
    - [ ] Error handling (command not found, permission denied)
    - [ ] Add tests
  - [ ] **fork() -> result<obj, string>**
    - [ ] Unix-specific (stub on Windows)
    - [ ] Return {is_child: bool, child_pid: int}
    - [ ] Add tests
  - [ ] **exec(command: string, args: array<string>) -> result<void, string>**
    - [ ] Replace current process
    - [ ] Platform-specific
    - [ ] Add tests
  - [ ] **wait(pid: int) -> result<int, string>**
    - [ ] Wait for process completion
    - [ ] Return exit code
    - [ ] Add tests

#### 6.3.2 Inter-Process Communication
- [ ] **createPipe() -> result<pipe, string>**
  - [ ] Create bidirectional pipe
  - [ ] Platform-specific (pipe() on Unix, CreatePipe on Windows)
  - [ ] Return pipe object with read/write ends
  - [ ] Add tests
- [ ] Implement `pipe` type operations
  - [ ] `pipe.read() -> result<string, string>`
  - [ ] `pipe.write(data: string) -> result<void, string>`
  - [ ] `pipe.close()` - close both ends
  - [ ] Add tests

### 6.4 HTTP Client (if in spec)

#### 6.4.1 Basic HTTP Support
- [ ] Check if `httpGet()` is in spec
- [ ] If yes, implement:
  - [ ] `httpGet(url: string) -> result<obj, string>`
    - [ ] Use libcurl or platform HTTP API
    - [ ] Return response object {status, headers, body}
    - [ ] Add tests

---

## PHASE 7: Standard Library - Concurrency
**Goal**: Implement threading, async improvements, atomics  
**Dependencies**: research_007 ‚úÖ, research_008, research_009, Phase 2 (borrow checker)  
**Timeline**: 14 weeks (~3.5 months)  
**Priority**: MEDIUM-HIGH (important for performance)  
**Implementation Plan**: `/docs/THREADING_IMPLEMENTATION_PLAN.md` (755 lines)

**Architecture Overview** (from research_007):
- **Hybrid M:N + 1:1 Threading Model**: Explicit choice between lightweight async tasks and OS threads
- **Work-Stealing Scheduler**: Chase-Lev lock-free deques, O(1) local operations
- **Two-Layer API**:
  - `aria.task` (M:N): Async/await with work-stealing (200-500 bytes/task, millions concurrent)
  - `aria.thread` (1:1): Direct OS threads for CPU-bound work (~8MB/thread, ~10K max)
- **Blocking Bridge**: `spawn_blocking()` offloads sync work to dedicated thread pool
- **Thread Safety**: Enforced via Send/Sync traits integrated with Appendage Theory

### 7.1 Work-Stealing Scheduler (3 weeks)
**Status**: Ready to implement (Phase 7.1 in plan)

- [ ] **Chase-Lev Deque** (`src/runtime/work_stealing_deque.{h,cpp}`)
  - [ ] Implement lock-free deque (owner push/pop bottom, thieves steal top)
  - [ ] Atomic operations: CAS on last item prevents ABA problem
  - [ ] LIFO for owner (cache locality), FIFO for thieves (load balancing)
  - [ ] Dynamic buffer resize (rare, grows 2x)
  - [ ] Unit tests: push, pop, steal, concurrent stress test
  - [ ] Validate with ThreadSanitizer (no data races)

- [ ] **Worker Threads** (`src/runtime/worker_thread.cpp`)
  - [ ] Implement scheduler loop (spawn N workers, N = num_cores)
  - [ ] Local deque per worker (hot path, cache-friendly)
  - [ ] Steal logic: random victim selection (prevents pathological patterns)
  - [ ] Check global queue every 61 ticks (fairness, borrowed from Go)
  - [ ] Park/unpark mechanism (condvar, reduces CPU when idle)

- [ ] **Global Injection Queue** (`src/runtime/global_queue.cpp`)
  - [ ] MPMC lock-free queue (or mutex-based fallback)
  - [ ] Integration with worker loop (checked periodically for fairness)
  - [ ] Used for external task submission (spawn from non-worker threads)

### 7.2 Task Runtime API (2 weeks)
**Status**: Ready to implement (Phase 7.2 in plan)

- [ ] **aria.task Module** (`stdlib/task.aria` + C++ runtime)
  - [ ] `spawn<T>(async func:f) -> Future<T>`: Create task, push to local deque, eager execution
  - [ ] `spawn_blocking<T>(func:f) -> Future<T>`: Offload to blocking pool, prevents worker stalling
  - [ ] `yield_now()`: Cooperative yield, task suspended and re-enqueued
  - [ ] `block_on<T>(Future<T>:fut) -> Result<T>`: Entry point, drives scheduler from sync code
  - [ ] `id() -> uint64`: Get current task ID
  - [ ] Add tests: 10K concurrent tasks, mixed CPU/IO workloads

- [ ] **CoroutineFrame Layout** (LLVM backend integration)
  - [ ] State machine for async functions (LLVM 20.1.2 already supports coroutines)
  - [ ] Waker registration for resumption (when future resolves)
  - [ ] Result storage for completed tasks
  - [ ] Integration with work-stealing scheduler

### 7.3 Blocking Thread Pool (1 week)
**Status**: Ready to implement (Phase 7.3 in plan)

- [ ] **BlockingPool Class** (`src/runtime/blocking_pool.cpp`)
  - [ ] Dynamic thread pool: starts with N threads (num_cores)
  - [ ] Grows on demand (max 512 threads), shrinks after idle timeout (60s)
  - [ ] MPMC work queue (multi-producer multi-consumer)
  - [ ] Isolation: never blocks M:N workers

- [ ] **spawn_blocking API**
  - [ ] Submit to blocking pool (FIFO queue)
  - [ ] Return Future that resolves on completion
  - [ ] Waker integration: notify async task when blocking work done
  - [ ] Add tests: stress test with 100+ blocking tasks

### 7.4 Thread Subsystem (1 week)
**Status**: Ready to implement (Phase 7.4 in plan)

- [ ] **aria.thread Module** (`stdlib/thread.aria` + C++ runtime)
  - [ ] `spawn<T>(func:f) -> Result<JoinHandle<T>>`: Wrapper around pthread_create / CreateThread
  - [ ] `JoinHandle.join() -> Result<T>`: Blocks until thread finishes, returns result
  - [ ] `yield_now()`: sched_yield() or SwitchToThread()
  - [ ] `sleep(int64:milliseconds)`: Sleep thread
  - [ ] `id() -> uint64`: Get thread ID
  - [ ] Platform-specific implementations (Linux pthread, Windows CreateThread)
  - [ ] Add tests: parallel computation (4 threads, CPU-bound work)

### 7.5 Synchronization Primitives (3 weeks)
**Status**: Ready to implement (Phase 7.5 in plan)

- [ ] **Async Mutex** (`src/runtime/async_mutex.cpp`)
  - [ ] Atomic state + wait queue of Wakers (task-aware, never blocks worker thread)
  - [ ] Fast path: Atomic CAS to acquire (spin briefly)
  - [ ] Slow path: Suspend task, register Waker in wait queue
  - [ ] Release: Wake oldest Waker from queue (FIFO fairness)
  - [ ] RAII guard (MutexGuard) with automatic unlock on drop
  - [ ] **Compiler warning**: Detect holding async mutex across await (deadlock risk)
  - [ ] Add tests: fairness (no starvation), async mutex + channels

- [ ] **Sync Mutex** (`src/runtime/sync_mutex.cpp`)
  - [ ] Wrapper around pthread_mutex_t (Linux) / SRWLOCK (Windows)
  - [ ] Blocks thread (not task) - for use in 1:1 threads only
  - [ ] RAII guard with automatic unlock
  - [ ] Add tests: basic locking, tryLock

- [ ] **Channels** (`src/runtime/channel.cpp`)
  - [ ] Go-style CSP (Communicating Sequential Processes)
  - [ ] Lock-free ring buffer for data (bounded capacity)
  - [ ] Send waiters queue (when channel full, backpressure)
  - [ ] Recv waiters queue (when channel empty)
  - [ ] CAS-based index management (top/bottom pointers)
  - [ ] API: `channel<T>(capacity) -> (Sender<T>, Receiver<T>)`
  - [ ] `Sender.send(T) -> Result<void>`: Suspends if full
  - [ ] `Receiver.recv() -> Result<T>`: Suspends if empty
  - [ ] Add tests: SPSC, MPSC, MPMC throughput, backpressure handling

- [ ] **Semaphores** (if needed)
  - [ ] Both async and sync variants
  - [ ] Use cases: rate limiting, resource pools
  - [ ] Add tests

### 7.6 Borrow Checker Integration (2 weeks)
**Status**: Depends on Phase 2 (borrow checker)

- [ ] **Send/Sync Traits** (thread safety enforcement)
  - [ ] Define traits in type system (like Rust)
  - [ ] **Send**: Type can be moved to another thread (TBB types ‚úì, wild pointers ‚úó)
  - [ ] **Sync**: Type's immutable reference can be shared across threads (immutable primitives ‚úì)
  - [ ] Implement for built-in types (TBB types, GC types, wild pointers)
  - [ ] Enforce in spawn/spawn_blocking: `spawn<T: Send>(async func:f) -> Future<T>`
  - [ ] Compiler errors for violating Send/Sync bounds

- [ ] **Cross-await Mutex Check**
  - [ ] Detect holding async mutex across await (static analysis)
  - [ ] Emit compiler warning: "Holding async mutex across await may deadlock"
  - [ ] Suggest alternatives: limit critical sections, use channels instead

- [ ] **Pin Verification for Shared Data**
  - [ ] Ensure GC objects are pinned (#) before sharing via wild pointers across threads
  - [ ] Example: `wild string*:pinned = #shared_data;` then `Mutex::new(pinned)`
  - [ ] Verify pins don't outlive data (borrow checker lifetime analysis)
  - [ ] All checked at compile time (zero runtime cost)

### 7.7 Testing & Optimization (2 weeks)
**Status**: Final phase after all above complete

- [ ] **Unit Tests**
  - [ ] Work-stealing correctness: 1000 tasks, random work distribution
  - [ ] Mutex fairness: 100 threads contending, no starvation
  - [ ] Channel throughput: SPSC (10M msgs/sec target), MPSC, MPMC
  - [ ] Blocking pool stress: 100+ concurrent blocking tasks

- [ ] **Integration Tests**
  - [ ] **C10K test**: 10,000 concurrent connections
    - [ ] Target: <100MB memory (10KB/connection)
    - [ ] Target: <1ms p99 latency
  - [ ] **Mixed CPU/IO workload**: async I/O + spawn_blocking for CPU work
  - [ ] **spawn_blocking stress**: Verify pool grows/shrinks correctly

- [ ] **Benchmarks**
  - [ ] Compare with Tokio (Rust): task creation, context switch, throughput
  - [ ] Compare with Go goroutines: C10K test, mixed workload
  - [ ] Latency histograms: p50, p99, p999 (use perf or similar)

- [ ] **Optimization**
  - [ ] Profile hot paths with perf (Linux) or Instruments (macOS)
  - [ ] NUMA-aware worker placement (pin workers to CPU cores)
  - [ ] Cache-line padding for atomics (prevent false sharing)
  - [ ] Validate zero-cost abstractions (assembly inspection)

### 7.3 Atomics Library (2-3 weeks)
**Status**: Research complete ‚úÖ (research_008), ready to implement  
**Reference**: `/docs/gemini/responses/research_008_atomics_library.txt` (417 lines)

#### 7.3.1 Memory Model Foundation
- [ ] **Adopt C++11/LLVM Memory Model** (`src/runtime/memory_model.md` documentation)
  - [ ] Document happens-before relationships (sequenced-before + synchronizes-with)
  - [ ] Define data race semantics (wild memory = UB, gc memory = logical corruption)
  - [ ] Platform mapping: x86-64 TSO vs ARMv8 weak memory model

- [ ] **Ordering Enum** (`stdlib/sync/atomic.aria`)
  ```aria
  enum Ordering {
      Relaxed,    // No sync, only atomicity (cheapest)
      Acquire,    // Load barrier: subsequent ops can't hoist above
      Release,    // Store barrier: prior ops can't sink below
      AcqRel,     // RMW: Acquire on read, Release on write
      SeqCst      // Global total order (most expensive)
  }
  ```
  - [ ] Validation: Loads can't use Release/AcqRel, Stores can't use Acquire/AcqRel
  - [ ] Documentation: When to use each (counter=Relaxed, flag=Acquire/Release, refcount=AcqRel)

#### 7.3.2 Atomic Types (Standard Integers)
- [ ] **Atomic<T> Generic** (`src/runtime/atomic/atomic.cpp`)
  - [ ] Core methods:
    - [ ] `load(Ordering) -> T`: Atomic read
    - [ ] `store(T, Ordering)`: Atomic write
    - [ ] `swap(T, Ordering) -> T`: Atomic exchange (RMW)
    - [ ] `compare_exchange(current: T, new: T, success: Ordering, failure: Ordering) -> result`
    - [ ] `compare_exchange_weak(...)`: May spuriously fail (efficient for loops)
  - [ ] Arithmetic (for integer types):
    - [ ] `fetch_add(T, Ordering) -> T`: Returns **previous** value
    - [ ] `fetch_sub(T, Ordering) -> T`
    - [ ] `fetch_and/or/xor(T, Ordering) -> T`: Bitwise ops

- [ ] **Specialized Type Aliases** (`stdlib/sync/atomic.aria`)
  ```aria
  type AtomicBool = Atomic<bool>;
  type AtomicInt8 = Atomic<int8>;
  type AtomicInt16 = Atomic<int16>;
  type AtomicInt32 = Atomic<int32>;
  type AtomicInt64 = Atomic<int64>;
  type AtomicUint8 = Atomic<uint8>;
  type AtomicUint16 = Atomic<uint16>;
  type AtomicUint32 = Atomic<uint32>;
  type AtomicUint64 = Atomic<uint64>;
  type AtomicPtr<T> = Atomic<wild T*>;
  ```
  - [ ] Backend: Map to LLVM `atomicrmw` for standard types (efficient hardware paths)

#### 7.3.3 TBB Atomics (Special Handling)
- [ ] **Problem**: Hardware atomics can't enforce sticky error semantics (ERR must stick)
  - [ ] Example: `tbb8` at ERR (-128) + 1 = ERR (not -127)
  - [ ] Hardware LOCK XADD would produce -127 (wrong!)

- [ ] **Solution**: Compiler-Synthesized CAS Loops (`src/backend/codegen_tbb_atomic.cpp`)
  - [ ] `AtomicTBB<T>.fetch_add(delta)` implementation:
    1. Load current value (atomic load)
    2. **Loop**: Calculate new value using TBBLowerer logic (checks ERR, overflow)
    3. CAS: Try to swap old ‚Üí new (compare_exchange_weak)
    4. If CAS fails: Reload and retry (loop)
    5. If CAS succeeds: Return old value
  - [ ] Trade throughput for correctness (consistent with Aria's safety philosophy)

- [ ] **TBB Atomic Aliases**
  ```aria
  type AtomicTBB8 = Atomic<tbb8>;
  type AtomicTBB16 = Atomic<tbb16>;
  type AtomicTBB32 = Atomic<tbb32>;
  type AtomicTBB64 = Atomic<tbb64>;
  ```

#### 7.3.4 Lock-Free Patterns
- [ ] **Arc (Atomically Reference Counted)** (`stdlib/sync/arc.aria`)
  - [ ] `clone()`: `fetch_add(1, Ordering.Relaxed)` (no sync needed while holding ref)
  - [ ] `drop()`: `fetch_sub(1, Ordering.Release)`, if last ref: `fence(Ordering.Acquire)` then free
  - [ ] Integration with borrow checker (ensure data outlives Arc)

- [ ] **Treiber Stack** (lock-free stack example in docs)
  - [ ] Push: CAS loop to update head pointer
  - [ ] Pop: Requires epoch-based reclamation (EBR) or hazard pointers (complex!)
  - [ ] ABA problem mitigation: Tagged pointers (use AtomicUint128 or pack tag in low bits)

- [ ] **Lock-Free Queue** (MPSC or MPMC, if needed)
  - [ ] Options: Ring buffer (bounded), linked list (unbounded)

#### 7.3.5 Testing & Verification
- [ ] **ThreadSanitizer Integration** (`--sanitize=thread` compiler flag)
  - [ ] Instrument all atomic loads/stores (LLVM TSan support)
  - [ ] Detect data races (concurrent R/W or W/W without happens-before)

- [ ] **Stress Tests** (`tests/concurrency/atomics_stress.aria`)
  - [ ] Hammer test: 100 threads, each increment counter 1M times, verify sum = 100M
  - [ ] Ping-pong test: Two threads toggling flag, validate visibility
  - [ ] Arc stress: 1000 clones/drops in parallel, verify refcount correctness

- [ ] **Model Checking** (future work)
  - [ ] Integrate loom-style tool (permute thread schedules, exhaustive state space)

### 7.4 Timers & Clocks
**Status**: Design complete (research_009 ‚úÖ), ready for implementation  
**Timeline**: 3 weeks (data structures, OS integration, async runtime)

#### 7.4.1 Core Data Structures (`src/runtime/time/`)
- [ ] **Hierarchical Timing Wheel** (timer_wheel.h/cpp)
  - [ ] 5-level hashed wheel (TV1-TV5): 256, 64, 64, 64, 64 slots
  - [ ] TimerEntry struct: expiry_nanos (tbb64), coro_handle, prev/next pointers
  - [ ] O(1) insert: Calculate level based on expiry delta, add to linked list
  - [ ] O(1) advance: Process current slot, cascade on wraparound
  - [ ] Per-worker wheels (zero lock contention)
  - [ ] Tests: Insert 10K timers, verify O(1) complexity

- [ ] **Platform Abstractions** (time_platform.h/cpp)
  - [ ] Linux: timerfd_create(CLOCK_MONOTONIC), epoll integration
  - [ ] Windows: CreateWaitableTimerEx(HIGH_RESOLUTION), IOCP integration  
  - [ ] macOS/BSD: kqueue EVFILT_TIMER(NOTE_NSECONDS)
  - [ ] VDSO optimization: Direct TSC/QPC reads (15ns latency)
  - [ ] Tests: Verify nanosecond precision on each platform

#### 7.4.2 Time Types (`stdlib/time.aria`)
- [ ] **Duration struct** (TBB64-based)
  - [ ] Field: tbb64:nanos (symmetric range ¬±292 years)
  - [ ] Constants: NANOSECOND, MICROSECOND, MILLISECOND, SECOND, MINUTE, HOUR
  - [ ] Arithmetic: Add/Sub/Mul/Div with ERR propagation
  - [ ] Tests: Verify overflow ‚Üí ERR (not wrap or panic)

- [ ] **Instant struct** (monotonic time point)
  - [ ] Field: tbb64:ticks (opaque, relative to boot)
  - [ ] now() -> Instant: Read monotonic clock
  - [ ] Instant + Duration -> Instant, Instant - Instant -> Duration
  - [ ] Tests: Verify monotonic guarantee (t2 >= t1 always)

- [ ] **SystemTime struct** (wall-clock, UTC)
  - [ ] Field: tbb64:unix_nanos (since Unix epoch)
  - [ ] now() -> SystemTime: Read system clock
  - [ ] Warning: Never use for durations/timeouts
  - [ ] Tests: Verify distinct from Instant

#### 7.4.3 Async Timer API
- [ ] **sleep(Duration) -> Future<void>**
  - [ ] Insert timer into wheel, suspend coroutine
  - [ ] On expiry: Resume coroutine
  - [ ] Cancellation: Drop Future ‚Üí mark TimerEntry CANCELLED
  - [ ] Tests: sleep(1s), verify 1000-1010ms elapsed

- [ ] **timeout<T>(Duration, Future<T>) -> Result<T>**
  - [ ] Race operation against timer using pick (select)
  - [ ] Return ERR_TIMEOUT if timer wins
  - [ ] Tests: timeout(100ms, slow_op()) verifies timeout, timeout(10s, fast_op()) verifies success

- [ ] **Ticker struct** (periodic events)
  - [ ] every(Duration) -> Ticker: Create periodic timer
  - [ ] next() -> Future<Instant>: Wait for next tick
  - [ ] Tests: Ticker at 100ms, verify 10 ticks in ~1000ms

#### 7.4.4 Reactor Integration
- [ ] **Worker::run() modification** (src/runtime/concurrency/worker.cpp)
  - [ ] Calculate next_timer_expiry from wheel
  - [ ] Pass to epoll_wait/GetQueuedCompletionStatusEx as timeout
  - [ ] On wakeup: Call wheel.advance(now), resume expired coroutines
  - [ ] Tests: 1000 concurrent sleeps, verify all wake correctly

- [ ] **Thundering Herd Mitigation**
  - [ ] Timer coalescing: Align to 10ms boundaries (configurable)
  - [ ] Staggered wakeup: Feed work stealing scheduler gradually
  - [ ] Tests: 10K timers at same expiry, verify CPU doesn't thrash

---

## PHASE 8: Advanced Features
**Goal**: Implement remaining advanced language features  
**Dependencies**: Various phases complete  
**Timeline**: 4-5 weeks  
**Priority**: MEDIUM (nice to have, not blocking beta)

### 8.1 Trait System Completion

#### 8.1.1 Trait Implementation Improvements
- [ ] Review existing research: `/docs/research/trait_system_implementation.md`
- [ ] Enhance trait system (basic version exists)
  - [ ] **Trait resolution improvements**
    - [ ] Better error messages
    - [ ] Overlapping impl detection
    - [ ] Trait coherence checking
  - [ ] **Default methods in traits**
    - [ ] Parse default method implementations
    - [ ] Allow overriding in impls
    - [ ] CodeGen for default methods
  - [ ] **Associated types (if in spec)**
    - [ ] Check spec for associated type syntax
    - [ ] Implement if present
  - [ ] Add tests

#### 8.1.2 Trait Objects (Dynamic Dispatch)
- [ ] Implement trait objects for runtime polymorphism
  - [ ] VTable generation (expand existing vtable.cpp)
  - [ ] Fat pointer representation (trait object = data ptr + vtable ptr)
  - [ ] Dynamic dispatch codegen
  - [ ] Add tests

### 8.2 Safe Navigation Operator (?.) Completion

#### 8.2.1 Safe Navigation CodeGen
- [ ] Complete codegen for `?.` operator (stub exists)
  - [ ] Null check before member access
  - [ ] Short-circuit evaluation
  - [ ] Return null if any intermediate is null
  - [ ] Optimize generated code (avoid redundant checks)
- [ ] Add comprehensive tests
  - [ ] `obj?.field`
  - [ ] `obj?.method()`
  - [ ] `obj?.field?.nested`
  - [ ] Integration with null coalescing: `obj?.field ?? default`

### 8.3 Metaprogramming & Macros
**Status**: Design complete (research_010+011), ready for implementation
**Timeline**: 14 weeks (per research roadmap)

#### 8.3.1 Phase 1: Macro Preprocessor Infrastructure (Weeks 1-3)
- [ ] Extend Preprocessor class with context stack
  - [ ] Implement %push/%pop/%repl directives
  - [ ] Add MacroContext struct (name + symbol table)
  - [ ] Context-local label support (%$label ‚Üí __ctx_ID_label)
  - [ ] %ifctx conditional compilation
- [ ] Token stream manipulation
  - [ ] %rotate directive for argument rotation
  - [ ] Recursive macro expansion with depth limits
  - [ ] Multi-line block capture (%body directive)
- [ ] Verification: Unit tests for nested macros, label uniqueness

#### 8.3.2 Phase 2: CTFE Interpreter Core (Weeks 4-6)
- [ ] Scaffold ComptimeInterpreter class
  - [ ] ComptimeValue variant (int/float/string/type/error)
  - [ ] Virtual Environment (stack of symbol tables)
  - [ ] Evaluator (recursive AST visitor)
- [ ] TBB-Aware Arithmetic
  - [ ] Software ALU for TBB addition/subtraction/multiplication
  - [ ] Sticky error propagation (ERR + X ‚Üí ERR)
  - [ ] Overflow detection for symmetric ranges
  - [ ] Sentinel collision detection
- [ ] Exotic type support
  - [ ] Ternary (trit/tryte) unpacking/logic/repacking
  - [ ] Nonary (nit/nyte) unpacking/logic/repacking
- [ ] Integrate CTFE hook into TypeChecker
- [ ] Verification: TBB constant folding tests

#### 8.3.3 Phase 3: Reflection & Mixins (Weeks 7-8)
- [ ] Type reflection system
  - [ ] Implement @typeInfo(T) intrinsic
  - [ ] Return struct with: fields, size, alignment, is_wild, is_sendable
  - [ ] Support for TBB/ternary/nonary type queries
- [ ] Mixin operator
  - [ ] @mixin(string) feeds code back to Parser
  - [ ] Source map generation for error tracking
  - [ ] AST node provenance annotation
- [ ] Virtual Heap for compile-time allocations
  - [ ] Handle-based memory (not real pointers)
  - [ ] Track wild vs gc allocations
  - [ ] Simulate pointer arithmetic safely
- [ ] Verification: Implement json_serialize<T> generic

#### 8.3.4 Phase 4: High-Level Macro Library (Weeks 9-10)
- [ ] Control flow macros
  - [ ] IF/ELIF/ELSE/ENDIF with context validation
  - [ ] WHILE/ENDWHILE with BREAK/CONTINUE label generation
  - [ ] FOR macro with iteration tracking
- [ ] Data structure templates
  - [ ] Vector<T> adapting to wild vs gc memory
  - [ ] HashMap<K,V> with memory model awareness
  - [ ] Optional<T> and Result<T,E> types
- [ ] Concurrency macros
  - [ ] ACTOR(name) { STATE/MESSAGE } expansion
  - [ ] SPAWN safety checks (@typeInfo(T).is_sendable)
- [ ] Standard library port to use new system

#### 8.3.5 Phase 5: Integration & Testing (Weeks 11-14)
- [ ] Borrow checker integration
  - [ ] Validate # pinning in macro output
  - [ ] Verify $ safe reference usage
- [ ] Threading integration
  - [ ] Actor mailbox generation
  - [ ] Message dispatch switch cases
- [ ] Wildx JIT support
  - [ ] Runtime assembler macros for x86-64 code emission
  - [ ] W^X enforcement in generated code
- [ ] Comprehensive test suite
  - [ ] Macro hygiene tests (label collision prevention)
  - [ ] TBB compile-time arithmetic correctness
  - [ ] Generic specialization tests
  - [ ] Error message provenance verification

### 8.5 Wildx Executable Memory

#### 8.5.1 Wildx Improvements
- [ ] Review existing research: `/docs/research/wildx_memory_regions.md`
- [ ] Enhance wildx support (basic version exists)
  - [ ] W^X enforcement (write XOR execute)
  - [ ] Runtime code generation API
  - [ ] JIT compilation support
  - [ ] Code cache management
- [ ] Add tests

### 8.6 Runtime Assembler (if in spec)

#### 8.6.1 Check Spec for Runtime Assembler
- [ ] Determine if runtime assembler is in spec
- [ ] If yes, implement:
  - [ ] Assembly parsing at runtime
  - [ ] Code generation to wildx memory
  - [ ] Register allocation
  - [ ] Add tests

### 8.7 Enhanced Diagnostics

#### 8.7.1 Error Message Improvements
- [ ] Review existing research: `/docs/research/diagnostic_system_improvements.md`
- [ ] Improve error messages throughout compiler
  - [ ] Add source location highlighting
  - [ ] Add suggestions for common mistakes
  - [ ] Add "did you mean?" for typos
  - [ ] Colorize output (when TTY)
- [ ] Add warning system
  - [ ] Unused variables
  - [ ] Unreachable code
  - [ ] Implicit conversions
  - [ ] Deprecation warnings

### 8.8 Struct Methods Completion

#### 8.8.1 Method Implementation
- [ ] Review existing research: `/docs/research/struct_methods_implementation.md`
- [ ] Complete struct methods (basic version exists)
  - [ ] Parse method syntax
  - [ ] Type check methods
  - [ ] CodeGen for methods (implicit self parameter)
  - [ ] Method chaining support
- [ ] Add tests

---

## PHASE 9: Optimization & Polish
**Goal**: Optimize compiler and generated code  
**Dependencies**: All core features complete  
**Timeline**: 2-3 weeks  
**Priority**: MEDIUM (performance improvements)

### 9.1 Compiler Optimizations

#### 9.1.1 Compilation Speed
- [ ] Profile compiler to find bottlenecks
- [ ] Optimize hot paths
  - [ ] Lexer optimizations
  - [ ] Parser optimizations
  - [ ] Type checker caching
- [ ] Parallel compilation (if not already)
- [ ] Incremental compilation support
- [ ] Add benchmarks

#### 9.1.2 Memory Usage
- [ ] Reduce compiler memory footprint
  - [ ] AST node pooling
  - [ ] String interning
  - [ ] Symbol table optimizations
- [ ] Add memory profiling

### 9.2 Generated Code Optimizations

#### 9.2.1 LLVM Optimization Passes
- [ ] Enable aggressive LLVM optimizations
  - [ ] Inlining
  - [ ] Dead code elimination
  - [ ] Constant propagation
  - [ ] Loop optimizations
  - [ ] Vectorization
- [ ] Profile-guided optimization (PGO) support
- [ ] Link-time optimization (LTO) support

#### 9.2.2 Aria-Specific Optimizations
- [ ] Review existing research:
  - [ ] TBB optimization (`tbb_optimizer.cpp` exists)
  - [ ] Loop optimization (`tbb_loop_optimizer.cpp` exists)
  - [ ] Interprocedural optimization (`tbb_interprocedural.cpp` exists)
- [ ] Enhance existing optimizations
- [ ] Add new optimizations
  - [ ] GC allocation elision
  - [ ] Escape analysis optimizations
  - [ ] Devirtualization (trait dispatch)
- [ ] Add benchmarks

### 9.3 GC Improvements

#### 9.3.1 Generational GC Enhancement
- [ ] Review existing research: `/docs/research/gc_nursery_implementation.md`
- [ ] Complete generational GC (nursery exists)
  - [ ] Implement generation 2 (tenured space)
  - [ ] Implement promotion logic
  - [ ] Add write barriers
  - [ ] Tune GC parameters
- [ ] Add GC profiling tools
- [ ] Add benchmarks

### 9.4 Binary Size Reduction

#### 9.4.1 Size Optimizations
- [ ] Strip unnecessary symbols
- [ ] Remove dead code at link time
- [ ] Compress static data
- [ ] Add size benchmarks

---

## PHASE 10: Testing & Validation
**Goal**: Comprehensive testing for production readiness  
**Dependencies**: All features implemented  
**Timeline**: 4-5 weeks  
**Priority**: CRITICAL (must have for beta)

### 10.1 Unit Test Expansion

#### 10.1.1 Expand Test Coverage
- [ ] Achieve >90% code coverage
  - [ ] Add tests for all lexer tokens
  - [ ] Add tests for all parser rules
  - [ ] Add tests for all type checker rules
  - [ ] Add tests for all codegen paths
- [ ] Add edge case tests
- [ ] Add error condition tests
- [ ] Generate coverage reports

### 10.2 Integration Tests

#### 10.2.1 End-to-End Test Suite
- [ ] Create comprehensive integration tests
  - [ ] Test all language features together
  - [ ] Test all stdlib functions
  - [ ] Test module system
  - [ ] Test async/concurrency
  - [ ] Test interop with C libraries
- [ ] Create realistic example programs
  - [ ] Web server
  - [ ] File processor
  - [ ] Data analyzer
  - [ ] Game engine
- [ ] Run integration tests on all platforms

### 10.3 Performance Benchmarks

#### 10.3.1 Benchmark Suite
- [ ] Create performance benchmarks
  - [ ] Compilation speed
  - [ ] Runtime performance
  - [ ] Memory usage
  - [ ] GC performance
- [ ] Compare with other languages
  - [ ] Rust, Go, C, C++, Zig
- [ ] Identify performance bottlenecks
- [ ] Optimize hot paths
- [ ] Document performance characteristics

### 10.4 Fuzzing & Stress Testing

#### 10.4.1 Fuzzing Infrastructure
- [ ] Set up fuzzing for:
  - [ ] Lexer (random source input)
  - [ ] Parser (malformed programs)
  - [ ] Type checker (type errors)
  - [ ] CodeGen (edge cases)
- [ ] Run fuzzing continuously
- [ ] Fix all crashes and hangs
- [ ] Add regression tests for found bugs

#### 10.4.2 Stress Testing
- [ ] Large codebase compilation
- [ ] Deep recursion tests
- [ ] Memory stress tests
- [ ] Concurrency stress tests
- [ ] Long-running program tests

### 10.5 Cross-Platform Testing

#### 10.5.1 Platform Validation
- [ ] Test on all target platforms
  - [ ] Linux (x86_64, ARM64)
  - [ ] Windows (x86_64)
  - [ ] macOS (x86_64, ARM64)
- [ ] Test on different architectures
- [ ] Test with different LLVM versions
- [ ] Fix platform-specific bugs

### 10.6 Security Audit

#### 10.6.1 Security Review
- [ ] Review for security vulnerabilities
  - [ ] Buffer overflows
  - [ ] Use-after-free
  - [ ] Race conditions
  - [ ] Integer overflows
- [ ] Static analysis tools
- [ ] Third-party security audit (if budget allows)
- [ ] Fix all security issues

---

## PHASE 11: Documentation & Release
**Goal**: Complete documentation and prepare beta release  
**Dependencies**: All features complete and tested  
**Timeline**: 2-3 weeks  
**Priority**: CRITICAL (required for beta release)

### 11.1 Language Documentation

#### 11.1.1 Language Reference Manual
- [ ] Write comprehensive language reference
  - [ ] Type system
  - [ ] Operators
  - [ ] Control flow
  - [ ] Functions and closures
  - [ ] Structs and traits
  - [ ] Generics
  - [ ] Module system
  - [ ] Async/await
  - [ ] Memory management
- [ ] Include examples for every feature
- [ ] Add cross-references
- [ ] Generate HTML/PDF versions

#### 11.1.2 Standard Library Documentation
- [ ] Document all stdlib modules
  - [ ] Function signatures
  - [ ] Parameter descriptions
  - [ ] Return values
  - [ ] Error conditions
  - [ ] Usage examples
- [ ] Generate API documentation (auto-doc tool?)

### 11.2 Tutorials & Guides

#### 11.2.1 Getting Started Guide
- [ ] Write installation guide
- [ ] Write "Hello World" tutorial
- [ ] Write basic language tutorial
  - [ ] Variables and types
  - [ ] Control flow
  - [ ] Functions
  - [ ] Modules
- [ ] Add exercises

#### 11.2.2 Advanced Guides
- [ ] Write advanced topics guides
  - [ ] Async programming
  - [ ] Concurrency
  - [ ] Memory management strategies
  - [ ] Performance optimization
  - [ ] Interfacing with C
  - [ ] Metaprogramming
- [ ] Add real-world examples

### 11.3 Migration & Comparison Guides

#### 11.3.1 For Developers Coming From...
- [ ] Rust migration guide
- [ ] Go migration guide
- [ ] C++ migration guide
- [ ] JavaScript/TypeScript migration guide

#### 11.3.2 Language Comparison
- [ ] Create comparison matrix
  - [ ] Aria vs Rust
  - [ ] Aria vs Go
  - [ ] Aria vs Zig
  - [ ] Aria vs C++
- [ ] Highlight unique features
- [ ] Explain design decisions

### 11.4 Tooling Documentation

#### 11.4.1 Compiler Documentation
- [ ] Document compiler flags
- [ ] Document build system integration
- [ ] Document IDE integration (if any)
- [ ] Document debugging tools

### 11.5 Release Preparation

#### 11.5.1 Beta Release Checklist
- [ ] All CRITICAL and HIGH priority features complete
- [ ] All tests passing
- [ ] Documentation complete
- [ ] Known issues documented
- [ ] Release notes written
- [ ] Version number finalized
- [ ] Build artifacts generated
  - [ ] Linux binaries
  - [ ] Windows binaries
  - [ ] macOS binaries
  - [ ] Source tarball
- [ ] Package for distribution
  - [ ] .deb package (Linux)
  - [ ] .rpm package (Linux)
  - [ ] .msi installer (Windows)
  - [ ] Homebrew formula (macOS)
- [ ] Update website
- [ ] Prepare announcement

#### 11.5.2 Beta Release
- [ ] Tag repository: `v0.1.0-beta.1`
- [ ] Create GitHub release
- [ ] Upload binaries
- [ ] Announce on:
  - [ ] Project website
  - [ ] Social media
  - [ ] Mailing lists
  - [ ] Reddit (/r/ProgrammingLanguages)
  - [ ] Hacker News
  - [ ] Lobsters
- [ ] Invite beta testers
- [ ] Set up issue tracker for feedback
- [ ] Prepare for alpha release (after beta testing)

---

## TRACKING & PROGRESS

### Current Status (December 11, 2025)
- **Phase 0**: 0% (research system ready, not started)
- **Phase 1**: 45% (types mostly done, TBB/exotic types pending)
- **Phase 2**: 10% (stubs exist, needs research_001)
- **Phase 3**: 20% (parsing done, visibility/resolution pending)
- **Phase 4**: 15% (parsing done, monomorphization pending)
- **Phase 5**: 5% (some functions exist)
- **Phase 6**: 0% (not started)
- **Phase 7**: 20% (async exists, threading/atomics pending)
- **Phase 8**: 30% (traits exist, other features partial)
- **Phase 9**: 5% (some optimizations exist)
- **Phase 10**: 10% (basic tests exist)
- **Phase 11**: 5% (README exists)

### Estimated Timeline
- **Optimistic**: 6 months (with parallel work, aggressive schedule)
- **Realistic**: 9-10 months (with research integration, testing)
- **Conservative**: 12 months (with thorough testing, polish)

### Parallel Tracks Possible
1. **Research Track**: Run Gemini research tasks in background
2. **Implementation Track**: Implement features with existing research
3. **Testing Track**: Write tests as features are implemented
4. **Documentation Track**: Document features as they stabilize

### Critical Path
Phase 0 ‚Üí Phase 1 ‚Üí Phase 2 ‚Üí Phase 4 ‚Üí Phase 6 ‚Üí Phase 10 ‚Üí Phase 11

Phases 3, 5, 7, 8, 9 can run in parallel once dependencies are met.

---

**Last Updated**: December 11, 2025  
**Next Review**: After research_001, research_002, research_003 complete
