# ARIA COMPILER - PRODUCTION-READY BETA ROADMAP
**Target**: Production-Quality Beta (Ready for Alpha Testing)  
**Current Version**: v0.0.9 (Clean Architecture)  
**Date Created**: December 11, 2025  
**Estimated Timeline**: 6-12 months (with parallel research/implementation)

---

## ðŸ“‹ TABLE OF CONTENTS

1. [Phase 0: Research Foundation](#phase-0-research-foundation)
2. [Phase 1: Core Type System Completion](#phase-1-core-type-system-completion)
3. [Phase 2: Memory Safety & Borrow Checking](#phase-2-memory-safety--borrow-checking)
4. [Phase 3: Module System & Visibility](#phase-3-module-system--visibility)
5. [Phase 4: Generics & Monomorphization](#phase-4-generics--monomorphization)
6. [Phase 5: Standard Library - Core](#phase-5-standard-library---core)
7. [Phase 6: Standard Library - I/O](#phase-6-standard-library---io)
8. [Phase 7: Standard Library - Concurrency](#phase-7-standard-library---concurrency)
9. [Phase 8: Advanced Features](#phase-8-advanced-features)
10. [Phase 9: Optimization & Polish](#phase-9-optimization--polish)
11. [Phase 10: Testing & Validation](#phase-10-testing--validation)
12. [Phase 11: Documentation & Release](#phase-11-documentation--release)

---

## PHASE 0: Research Foundation
**Goal**: Fill critical knowledge gaps via Gemini research  
**Timeline**: 1-2 weeks (parallel to Phase 1 implementation)  
**Status**: Research system ready, tasks defined

### 0.1 Critical Research (BLOCKING)
- [ ] **research_001: Borrow Checker Implementation**
  - [ ] Upload source compilations to Gemini (9 files)
  - [ ] Review response document
  - [ ] Extract lifetime analysis algorithm
  - [ ] Extract borrow checking rules
  - [ ] Extract integration strategy with Appendage Theory
  - [ ] Document findings in `/docs/research/borrow_checker_design.md`

- [x] **research_002: Balanced Ternary Arithmetic** âœ… COMPLETE + IMPLEMENTED
  - [x] Upload source compilations to Gemini (7 files)
  - [x] Review response document (54KB received)
  - [x] Extract ternary arithmetic algorithms
  - [x] Extract trit/tryte packing strategy (10 trits in uint16)
  - [x] Extract binaryâ†”ternary conversion algorithms
  - [x] Document: `/docs/gemini/responses/research_002_balanced_ternary_arithmetic.txt`
  - [x] **IMPLEMENTATION**: Phases 1-6 complete on `dev/balanced-ternary` branch
    * Phase 1: Type system (TypeKind::TRIT, TRYTE)
    * Phase 2: Runtime (561 lines) - TernaryOps class, packing/unpacking
    * Phase 3: LLVM codegen (456 lines) - TernaryLowerer class
    * Phase 4: Testing (20/20 passing) - Full arithmetic validation
    * Phase 5: Documentation (640 lines) - STATUS.md + FINAL_REPORT.md
    * Phase 6: Partial (backend done, BLOCKED on parser expression support)

- [x] **research_003: Balanced Nonary Arithmetic** âœ… COMPLETE + IMPLEMENTED (Dec 11, 2025)
  - [x] Upload source compilations to Gemini (7 files)
  - [x] Review response document (59KB received)
  - [x] Extract nonary arithmetic algorithms
    * **Key Finding**: Biased-Radix Packing (value + 29524)
    * Addition: `A + B - bias` (3-5 cycles)
    * Comparison: Works directly on packed values (monotonic!)
    * Performance: 50-70% of native int16 with safety
  - [x] Extract nit/nyte packing strategy (5 nits in uint16)
    * 9^5 = 59,049 values â†’ 90.1% efficiency in uint16
    * 6,487 spare code points â†’ ERR sentinel for free!
    * Zero = 0x7354, ERR = 0xFFFF
  - [x] Extract binaryâ†”nonary conversion algorithms
    * SIMD-friendly operations (8 nytes per SSE register)
  - [x] Document findings: `/docs/gemini/responses/research_003_balanced_nonary_arithmetic.txt`
  - [x] **IMPLEMENTATION**: Complete on `main` branch (v0.0.12)
    * Runtime: 360 lines (NonaryOps class) - biased-radix packing
    * Codegen: 242 lines (NonaryLowerer class) - LLVM integration
    * C Runtime: 91 lines - external linkage wrappers
    * Testing: 26/26 passing - full coverage
    * Documentation: BALANCED_NONARY_STATUS.md
    * Timeline: 3.5 hours (as predicted)

### 0.2 High-Priority Research (Important but not blocking)
- [x] **research_004: File I/O Library Design** âœ… COMPLETE (Dec 11, 2025)
  - [x] Upload compilations (8 files)
  - [x] Review response document (933 lines received)
  - [x] Extract API design
    * **Key Finding**: Multi-layered I/O with RAII-compliant File struct
    * Builder pattern for file operations
    * TBB-integrated error handling (sticky ERR propagation)
    * Hybrid async runtime (io_uring on Linux, IOCP on Windows)
  - [x] Extract error handling patterns
    * Result types: {err, val} for all I/O operations
    * TBB types for offsets/sizes (overflow â†’ ERR)
    * Structured error objects (not just error codes)
  - [x] Extract async integration strategy
    * Zero-copy optimizations with wild buffers
    * Memory-mapped files for high-throughput
    * defer for deterministic resource cleanup
  - [x] Document: `/docs/gemini/responses/research_004_file_io_library.txt`

- [x] **research_005: Process Management Library** âœ… COMPLETE (Dec 11, 2025)
  - [x] Upload compilations
  - [x] Review response document (397 lines received)
  - [x] Extract process API design
    * **Key Finding**: Builder pattern (Command struct)
    * Deprecate fork() for posix_spawn (thread-safe)
    * Windows: CreateProcess + Job Objects + IOCP
  - [x] Extract IPC mechanisms
    * Stdio enum (Inherit, Null, Piped)
    * Fluent API: cmd.arg().env().stdin(Piped)
    * pidfd on Linux 5.3+ (stable, epoll-compatible)
  - [x] Extract cross-platform strategy
    * Unix: posix_spawn (avoids fork deadlocks)
    * Linux: pidfd_open for stable process handles
    * Windows: Job Objects for lifecycle management
    * RAII Child struct (prevents zombie processes)
  - [x] Document: `/docs/gemini/responses/research_005_process_management.txt`

- [x] **research_006: Modern I/O Streams (6-stream system)** âœ… COMPLETE (Dec 11, 2025)
  - [x] Upload compilations
  - [x] Review response document (388 lines received)
  - [x] Extract stream purpose analysis
    * **Key Finding**: 6-stream topology replaces 3-stream Unix model
    * stdin/stdout/stderr: Text (UTF-8) - line buffered
    * stddbg (FD 3): Diagnostic telemetry - async ring buffered
    * stddati (FD 4): Binary data in - block buffered
    * stddato (FD 5): Binary data out - block buffered
  - [x] Extract implementation strategy
    * Linux: FDs 3-5 via fcntl + dup2 + process inheritance
    * Windows: STARTUPINFOEX + env var passing (__ARIA_STREAMS)
    * Named pipes for persistent IPC
    * Zero-copy optimizations (splice() on Linux)
  - [x] Understand stddbg/stddati/stddato rationale
    * Separation of concerns: text vs binary, errors vs debug
    * Prevents stdout corruption in pipelines
    * Enables ML/blockchain apps (binary tensor streaming)
    * 33% bandwidth savings (no Base64 encoding needed)
  - [x] Document: `/docs/gemini/responses/research_006_modern_streams.txt`

- [x] **research_007: Threading Library** âœ… COMPLETE (Dec 11, 2025)
  - [x] Upload compilations
  - [x] Review response document (comprehensive design spec)
  - [x] Extract threading model design
    * **Key Finding**: Hybrid M:N + 1:1 threading model
    * M:N: Task runtime with work-stealing scheduler (async/await)
    * 1:1: Thread subsystem for CPU-bound work (aria.thread)
    * Bridge: spawn_blocking prevents colored function problem
  - [x] Extract synchronization primitives
    * Async Mutex: Task-aware (suspends coroutine, not thread)
    * Sync Mutex: Thread-blocking (pthread_mutex_t wrapper)
    * Channels: Go-style MPSC with bounded/unbounded modes
    * Semaphores: Both async and sync variants
  - [x] Extract async/thread integration strategy
    * Work-stealing: Chase-Lev lock-free deques
    * Global injection queue for external tasks
    * Fairness: Check global queue every 61 ticks
    * Task: Stackless coroutines (~200-500 bytes)
    * Thread: OS threads (pthread/CreateThread)
  - [x] Document: `/docs/gemini/responses/research_007_threading_library.txt`

### 0.3 Medium-Priority Research (Nice to have)
- [x] **research_008: Atomics library** âœ… COMPLETE (Dec 11, 2025)
  * **Memory Model**: Adopts C++11/LLVM standard for compatibility
    - Sequenced-before, Synchronizes-with, Happens-before relationships
    - Data races in wild memory = UB, in gc memory = logical corruption
  * **Five Memory Orderings**: Relaxed, Acquire, Release, AcqRel, SeqCst
    - Explicit ordering required (no defaults, forces consideration)
    - Maps to x86-64 TSO and ARMv8 weak memory model instructions
  * **API Design**: Based on Rust's std::sync::atomic (explicit methods, not operators)
    - `Atomic<T>`, specialized aliases (AtomicInt64, AtomicBool, AtomicPtr, etc.)
    - Core methods: load, store, swap, compare_exchange, fetch_add/sub/and/or/xor
  * **TBB Challenge**: Hardware atomics incompatible with sticky error semantics
    - Standard types (int/uint): Use hardware fetch-and-add (LOCK XADD, LDADD)
    - TBB types (tbb8/16/32/64): Compiler-synthesized CAS loops to preserve ERR stickiness
  * **Lock-Free Patterns**: Arc (reference counting), Treiber Stack, ABA mitigation
  * **Platform Specifics**:
    - x86-64 TSO: Many atomics "free" (MOV sufficient), SeqCst needs MFENCE
    - ARMv8: LDAR/STLR for acquire/release, DMB/DSB for full barriers
  * **Testing Strategy**: ThreadSanitizer integration, torture tests, model checking
  * **Reference**: `/docs/gemini/responses/research_008_atomics_library.txt` (417 lines)
- [x] **research_009: Timer/Clock Library** âœ… COMPLETE (Dec 11, 2025)
  * **Core Design**: Hierarchical Timing Wheel (5-level hashed wheel, O(1) insert/cancel)
  * **Key Innovations**:
    - TBB64 temporal calculus: Symmetric time arithmetic eliminates overflow bugs
    - Duration/Instant types with ERR sentinel for safe time math
    - Monotonic time enforcement (never use wall-clock for durations)
    - Per-worker wheels (zero lock contention, NUMA-friendly)
  * **Platform Integration**:
    - Linux: timerfd + epoll (nanosecond precision via VDSO)
    - Windows: Waitable Timers + IOCP (QueryPerformanceCounter)
    - macOS/BSD: kqueue EVFILT_TIMER (mach_absolute_time)
  * **Async Support**:
    - sleep(), timeout(), Ticker (periodic events)
    - Appendage Theory enforcement for timer callbacks
    - Cancellation via Future drop (zombie timer mitigation)
  * **Performance**: VDSO usage (15ns clock reads), cache-friendly wheel structure
  * **Reference**: `/docs/gemini/responses/research_009_timer_clock_library.txt` (502 lines)
- [x] **research_010+011: Macro Preprocessor & Comptime Metaprogramming System** âœ… COMPLETE (Dec 12, 2025)
  * **Scope**: Two-phase metaprogramming architecture (NASM-style textual macros + Zig-style semantic comptime)
  * **Phase 1 - Macro Preprocessor** (Textual/Syntactic):
    - **Context Stack Management**: %push/%pop/%repl/%ifctx for nested macro states
    - **Label Hygiene**: Context-local labels (%$label) prevent symbol collision
    - **Token Manipulation**: %rotate for variadic argument processing
    - **Multi-line Capture**: %body directive for DSL block capture
    - **Recursive Expansion**: Support for self-referential macros with depth limits
  * **Phase 2 - Comptime Execution Engine** (Semantic):
    - **CTFE Interpreter**: Tree-walking VM operating on typed AST
    - **TBB-Aware ALU**: Native sticky error propagation for compile-time TBB arithmetic
    - **Exotic Type Support**: Ternary/nonary unpacking and logic emulation
    - **Types as Values**: @typeInfo() reflection, type:T first-class parameter
    - **Virtual Heap**: Sandboxed memory arena simulating wild/gc allocation at compile-time
  * **Bridge Mechanism**:
    - **@mixin Operator**: Injects generated code strings back into parser
    - **Source Maps**: Full provenance tracking for error messages (file/line/macro stack)
  * **High-Level Library** (Macro-Implemented):
    - Control flow: IF/ELIF/ELSE/ENDIF, WHILE/ENDWHILE with BREAK/CONTINUE
    - ACTOR macro: Generates struct + message enum + mailbox loop
    - Memory-aware generics: Vector<T> adapts to wild vs gc allocation
  * **Integration**:
    - Borrow checker: Validates # pinning, $ safe references in macro output
    - Threading: SPAWN safety checks (@typeInfo(T).is_sendable)
    - Atomics: Macro-generated CAS loops for TBB types
  * **Timeline**: 14-week implementation roadmap detailed
  * **Reference**: `/docs/gemini/responses/research_010-011_macro_comptime.txt` (comprehensive 600+ line report)

### 0.4 Remaining Core Research (Pending)
- [ ] **research_012: Standard Integer and Unsigned Integer Types**
  * **Scope**: Design int1-512 and uint8-512 types (non-TBB standard integers)
  * **Coverage**:
    - int1, int2, int4, int8, int16, int32, int64, int128, int256, int512
    - uint8, uint16, uint32, uint64, uint128, uint256, uint512
  * **Key Questions**:
    - Memory layout and alignment for wide types (128/256/512-bit)
    - LLVM IR mappings (native vs multi-register representation)
    - Overflow behavior (wrap, trap, or saturate?)
    - Comparison with TBB types (when to use which?)
    - Literal syntax (suffixes: i8, u16, i128, etc.)
    - Conversion rules (implicit vs explicit casts)
    - SIMD opportunities for wide integer operations
- [ ] **research_013: Floating-Point Types (Extended Precision)**
  * **Scope**: Design flt32, flt64, flt128, flt256, flt512 types
  * **Coverage**:
    - flt32 (IEEE-754 binary32), flt64 (IEEE-754 binary64)
    - flt128 (IEEE-754 binary128 / quadruple precision)
    - flt256, flt512 (software-emulated extended precision)
  * **Key Questions**:
    - Platform support (hardware vs software implementation)
    - NaN/Infinity handling (match IEEE-754 or custom?)
    - Rounding modes (nearest, toward zero, up, down)
    - Subnormal number support
    - Fast-math optimizations vs strict IEEE compliance
    - Conversion from/to TBB types (ERR â†’ NaN mapping?)
    - Performance: SIMD (AVX-512 for flt32/64), software for 128+
- [ ] **research_014: Composite Types - Part 1 (Object, Dynamic, Boolean)**
  * **Scope**: Design obj, dyn, and bool types
  * **obj (Object/Dictionary)**:
    - Key-value map with heterogeneous values
    - Memory layout (hash table? tree? inline small objects?)
    - Type safety (typed vs untyped keys/values)
    - GC integration (reference tracking for nested objects)
    - JSON compatibility (serialization/deserialization)
  * **dyn (Dynamic/Variant)**:
    - Tagged union holding any type
    - Type tag storage (enum discriminant)
    - Pattern matching integration (pick statement)
    - Runtime type queries (@typeInfo at runtime?)
    - Performance vs safety tradeoffs
  * **bool (Boolean)**:
    - Representation (1-bit logical, 8-bit physical?)
    - Truthiness rules (only true/false, or 0/non-zero like C?)
    - Integration with ternary logic (trit type)?
    - Conversion from TBB ERR (error â†’ false?)
- [ ] **research_015: Composite Types - Part 2 (Vectors, Structs, Strings)**
  * **Scope**: Design vec2, vec3, vec9, struct, string types
  * **vec2, vec3, vec9 (SIMD Vectors)**:
    - Element type support (int, uint, flt, tbb?)
    - SIMD instruction mapping (SSE, AVX, AVX-512, NEON)
    - Swizzling support (vec3.xyz, vec3.yzx)
    - Geometric operations (dot, cross, normalize)
    - vec9 (balanced nonary 3Ã—3 matrix? or 9-element vector?)
  * **struct**:
    - Field alignment and padding rules
    - Packed vs aligned structs
    - Memory model (always GC? support wild struct?)
    - Method definitions (attached functions?)
    - Inheritance or composition model
  * **string**:
    - Encoding (UTF-8 native? ASCII? UCS-2?)
    - Small String Optimization (SSO) threshold
    - Immutability (Rust String vs &str model?)
    - String concatenation (operator+ vs builder pattern?)
    - Integration with template literals (`...`)
    - GC vs wild string allocation
- [ ] **research_016: Functional Types (Result, Func, Array)**
  * **Scope**: Design result, func, array types
  * **result<T, E>**:
    - Error handling model ({err, val} struct)
    - Monadic operations (map, flatMap, unwrap_or)
    - Integration with ? operator (unwrap shorthand)
    - ERR sentinel propagation from TBB
    - Pattern matching in pick statements
  * **func (Function Pointers/Closures)**:
    - Closure capture semantics (by-value, by-reference, wild pointers)
    - Function signature representation in type system
    - Calling convention (C ABI vs Aria native?)
    - Async function representation (Future/Promise?)
    - Integration with comptime (functions as values?)
  * **array<T, N> and T[]**:
    - Fixed-size (stack) vs dynamic (heap) arrays
    - Bounds checking (always? debug-only? never?)
    - Slicing syntax (arr[2..5], arr[...10])
    - Memory model (GC vs wild arrays)
    - Multi-dimensional arrays (arr[10][20] vs tensor?)
    - Integration with SIMD (vectorized operations)
- [ ] **research_017: Advanced Mathematical Types (Tensor, Matrix)**
  * **Scope**: Design tensor and matrix types
  * **tensor<T, Shape>**:
    - N-dimensional array representation
    - Shape encoding (compile-time or runtime dimensions?)
    - Stride calculation and memory layout (row-major, column-major, custom)
    - Broadcasting rules (NumPy-style or custom?)
    - SIMD/GPU acceleration hooks
    - Integration with ML libraries
  * **matrix<T, Rows, Cols>**:
    - Specialized 2D tensor with linear algebra operations
    - Matrix multiplication (naive, Strassen, BLAS integration)
    - Decomposition (LU, QR, SVD)
    - Sparse matrix support
    - Relationship to vec2/vec3 (matrix-vector multiplication)
    - Fixed-size vs dynamic-size matrices

### 0.5 Control Flow Constructs Research
- [ ] **research_018: Looping Constructs (while, for, loop, till)**
  * **Scope**: Detailed semantics and codegen for loop types
  * **while (condition) { body }**:
    - Standard conditional loop
    - Loop variable hoisting
    - Optimization: loop invariant code motion
  * **for (init; condition; update) { body }**:
    - C-style three-part loop
    - Scoping rules for loop variable
    - Iterator protocol (for-each style: for (item in collection))
  * **loop(start, stop, step) { body }**:
    - Aria-specific counted loop
    - Automatic $ iteration variable
    - Step direction detection (positive vs negative)
    - Optimization: loop unrolling thresholds
  * **till(limit, step) { body }**:
    - Simplified counted loop (start=0 or start=limit depending on step)
    - $ variable semantics (0-based indexing)
    - Comparison with loop construct
- [ ] **research_019: Conditional Constructs (if/else, when/then/end, pick)**
  * **Scope**: Detailed semantics for conditionals and pattern matching
  * **if (cond) { } else { }**:
    - Standard branching
    - Short-circuit evaluation
    - Integration with safe navigation (?.)
    - Optimization: branch prediction hints
  * **when (cond) { body } then { success } end { failure }**:
    - Completion-aware loop with handlers
    - 'then' runs after normal completion
    - 'end' runs if loop never executed or broke early
    - State tracking mechanism
  * **pick (value) { cases }**:
    - Pattern matching switch
    - Case types: exact, range (.., ...), comparison (<, >, <=, >=)
    - Destructuring patterns ({ field: value }, [a, b, c])
    - Wildcard (*) and unreachable (!)
    - fall(label) explicit fallthrough
    - Exhaustiveness checking
- [ ] **research_020: Control Transfer (break, continue, return, defer)**
  * **Scope**: Jump semantics and cleanup handling
  * **break / continue**:
    - Loop exit and iteration skip
    - Labeled break/continue (for nested loops)
    - Interaction with defer blocks
  * **return**:
    - Early function exit
    - Implicit result wrapping ({err: NULL, val: X})
    - Defer execution before return
  * **defer**:
    - RAII-style cleanup registration
    - Execution order (LIFO stack)
    - Interaction with wild memory (aria.free in defer)
    - Panic/unwind safety

### 0.6 Memory Management Research
- [ ] **research_021: Garbage Collection System**
  * **Scope**: Complete GC architecture and integration
  * **GC Algorithm**:
    - Generational design (nursery + mature space)
    - Minor GC (young generation, copying collector)
    - Major GC (full heap, mark-sweep-compact or mark-region)
    - Fragmented nursery design (per-worker arenas)
  * **Root Tracking**:
    - Shadow stack implementation
    - Conservative stack scanning fallback
    - Global roots and static data
  * **Write Barriers**:
    - Incremental/concurrent GC support
    - Remembered set for cross-generation pointers
  * **Pinning Integration**:
    - # operator marks objects non-movable
    - Pin counting mechanism
    - Interaction with compaction
  * **Performance**:
    - Allocation fast path (bump pointer in nursery)
    - GC pause time targets (sub-millisecond minor, <10ms major)
    - Throughput optimization
  * **Platform Specifics**:
    - Linux: mmap/madvise for memory management
    - Windows: VirtualAlloc/VirtualFree
    - macOS: vm_allocate/vm_deallocate
- [ ] **research_022: Wild and Wildx Memory (Manual Management)**
  * **Scope**: Manual memory allocation and executable memory
  * **wild (Manual Heap)**:
    - Opt-out of GC via wild keyword
    - aria.alloc() / aria.free() API
    - Integration with Mimalloc allocator
    - Leak detection (static analysis + runtime tracking)
    - Pointer arithmetic with @ operator
    - Appendage Theory (wild ptrs to GC objects require pinning)
  * **wildx (Executable Memory)**:
    - JIT code generation target
    - W^X enforcement (write XOR execute)
    - Temporal window: allocate â†’ write â†’ seal â†’ execute
    - RAII guard for security (wildx_guard.c)
    - Platform syscalls: mprotect, VirtualProtect, mach_vm_protect
    - Integration with runtime assembler
  * **Operators**:
    - @ (address-of): Get raw pointer to variable
    - * (dereference): Read value from pointer
    - -> (member access): Pointer member dereference
    - # (pin): Prevent GC movement of target object
    - $ (safe reference): Borrow checker safe reference (immutable or mutable $mut)
- [ ] **research_023: Runtime Assembler (Wildx Code Generation)**
  * **Scope**: JIT compilation and x86-64 code emission
  * **Architecture**:
    - Assembler DSL in Aria (macro-based or comptime-based?)
    - Instruction encoding (x86-64 machine code generation)
    - Register allocation (simple or full coloring?)
    - Label resolution and relocation
  * **Instruction Set**:
    - Basic arithmetic (ADD, SUB, MUL, DIV, IMUL, IDIV)
    - Bitwise (AND, OR, XOR, NOT, SHL, SHR, SAR)
    - Control flow (JMP, JZ, JNZ, CALL, RET)
    - Memory (MOV, LEA, PUSH, POP)
    - SIMD (SSE, AVX, AVX-512 for vector operations)
  * **Safety**:
    - Wildx guard integration (automatic sealing)
    - Bounds checking (prevent writing outside allocated region)
    - Control flow integrity (no arbitrary jumps outside function)
  * **Use Cases**:
    - Regex engine compilation
    - Expression evaluators
    - High-performance parsers
    - DSL interpreters

### 0.7 Operators Research
- [ ] **research_024: Arithmetic and Bitwise Operators**
  * **Scope**: All arithmetic, bitwise, and compound assignment operators
  * **Arithmetic**: +, -, *, /, %, ++, --, unary -, unary +
  * **Bitwise**: &, |, ^, ~, <<, >>
  * **Compound Assignment**: +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=
  * **TBB Integration**: Sticky error propagation for all operations
  * **Overflow Handling**: wrap vs trap vs saturate per type
  * **Optimization**: Strength reduction, constant folding
- [ ] **research_025: Comparison and Logical Operators**
  * **Scope**: Comparison, logical, and short-circuit operators
  * **Comparison**: ==, !=, <, >, <=, >=, <=> (spaceship)
  * **Logical**: &&, ||, ! (short-circuit evaluation)
  * **Ternary**: is cond : true_val : false_val
  * **TBB Comparison**: How to compare ERR sentinel?
  * **Ternary Logic**: Integration with trit type (3-valued logic)
  * **Optimization**: Branch prediction, conditional move
- [ ] **research_026: Special Operators (Memory, Safety, Pipeline)**
  * **Scope**: Aria-specific special operators
  * **Memory Operators**:
    - @ (address-of): &x in C, but for wild pointers
    - * (dereference): *ptr, read from pointer
    - -> (member access): ptr->field
    - # (pin): Prevent GC movement (#gc_obj)
    - $ (safe reference): Borrow checker reference ($x or $mut x)
  * **Safety Operators**:
    - ? (unwrap): Extract value from result, or use default
    - ?. (safe navigation): Short-circuit on null
    - ?? (null coalesce): Provide default for null
  * **Pipeline Operators**:
    - |> (forward pipeline): data |> transform
    - <| (backward pipeline): transform <| data
  * **Range Operators**:
    - .. (inclusive range): 0..10 (0 to 10)
    - ... (exclusive range): 0...10 (0 to 9)
  * **Iteration**:
    - $ (iteration variable): Automatic in till/loop constructs
  * **Template Interpolation**:
    - &{ } (interpolation): Inside ` backtick strings

### 0.8 Language Infrastructure Research
- [ ] **research_027: Generics and Templates (Monomorphization System)**
  * **Scope**: Zero-cost generic programming via monomorphization (C++/Rust style)
  * **Generic Functions**: func<T, U>:name = *T(*U:param) { body }
  * **Monomorphization**: Compile-time type instantiation (no erasure)
  * **Type Inference**: Automatic type parameter deduction
  * **Constraints**: Trait bounds and type requirements
  * **Integration**:
    - Interaction with wild vs gc memory
    - TBB types in generic contexts (preserving ERR)
    - Borrow checker compatibility
    - Comptime evaluation for constraints
  * **Advanced Features**:
    - Associated types
    - Higher-kinded types
    - Const generics (array<T, N>)
    - Variadic generics
    - Specialization
- [ ] **research_028: Module System (use, mod, pub, extern)**
  * **Scope**: Complete module system for code organization
  * **use (Imports)**: use std.io, use math.*, use "./file.aria" as alias
  * **mod (Module Definitions)**: mod name { ... } and nested hierarchies
  * **pub (Visibility)**: pub func, pub const, pub struct
  * **extern (FFI)**: extern "libc" { func:malloc = void*(uint64:size); }
  * **Key Features**:
    - Import resolution algorithm (absolute, relative, search paths)
    - Circular import detection
    - Visibility levels (pub, pub(crate), pub(super), private)
    - FFI type mappings (Aria â†” C types)
    - Conditional compilation (use cfg(target_os = "linux"))
  * **Integration**:
    - File/directory structure conventions
    - Package manifest format
    - Symbol resolution
    - Incremental compilation with modules
- [ ] **research_029: Async/Await System (Coroutines and Futures)**
  * **Scope**: Zero-cost async/await with stackless coroutines
  * **async Functions**: async func:name = result(params) { await expr; }
  * **await Keyword**: Suspend execution until Future completes
  * **Future<T>**: Type representing pending computation
  * **Coroutines**: Stackless state machine transformation
  * **Integration**:
    - Async runtime using research_007 work-stealing executor
    - I/O integration with research_005 (io_uring, IOCP)
    - Borrow checker lifetime constraints
    - Error handling with result type
  * **Advanced Features**:
    - Async blocks and closures
    - Select/join combinators
    - Cancellation semantics (drop Future)
    - Async iterators/streams
    - Timeout support
- [ ] **research_030: Const and Compile-Time Evaluation**
  * **Scope**: Compile-time constants and const evaluation
  * **const Variables**: const int:VALUE = 42;
  * **const Functions**: Pure, deterministic functions evaluated at compile-time
  * **const Generics**: Generic parameters as compile-time constants
  * **const Expressions**: Arithmetic, logical, function calls at compile-time
  * **Integration**:
    - Relationship with comptime from research_010
    - Const propagation optimization
    - Memory model (data segment, inlining)
  * **Advanced Features**:
    - Const assertions (static_assert)
    - Const pattern matching
    - Const slices/strings

---

## PHASE 1: Core Type System Completion
**Goal**: Implement all spec-defined types with full codegen  
**Dependencies**: Research 002, 003 for exotic types  
**Timeline**: 3-4 weeks  
**Priority**: CRITICAL (language syntax completion)

### 1.1 TBB (Twisted Balanced Binary) Types âœ… COMPLETE
**Status**: Codegen, TypeChecker, and Tests complete
**Location**: src/backend/codegen_tbb.cpp, src/frontend/sema/tbb_checker.cpp, tests/tbb/
**Test Results**: 26/26 passing

#### 1.1.1 TBB Type Checker Implementation âœ…
- [x] Created `TBBTypeChecker` in `src/frontend/sema/tbb_checker.cpp` (113 lines)
  - [x] Implemented symmetric range validation
    - [x] tbb8: [-127, +127], ERR = -128
    - [x] tbb16: [-32767, +32767], ERR = -32768
    - [x] tbb32: [-2147483647, +2147483647], ERR = INT32_MIN
    - [x] tbb64: symmetric range, ERR = INT64_MIN
  - [x] Implemented literal validation (reject out-of-range constants)
  - [x] Implemented ERR literal checking (context-dependent type)
  - [x] Added comprehensive tests in `tests/tbb/test_tbb_ops.cpp`

#### 1.1.2 TBB Arithmetic CodeGen - Sticky Error Propagation âœ…
- [x] Extended CodeGen with TBB operations in `codegen_tbb.cpp` (247 lines)
  - [x] **Addition with overflow detection**
    - [x] Check if either operand is ERR â†’ return ERR (sticky)
    - [x] Perform addition with LLVM overflow intrinsics
    - [x] Check if result exceeds symmetric range â†’ return ERR
    - [x] Emit LLVM IR: `llvm.sadd.with.overflow`
  - [x] **Subtraction with overflow detection**
    - [x] Check ERR propagation
    - [x] Perform subtraction with overflow check
    - [x] Emit LLVM IR: `llvm.ssub.with.overflow`
  - [x] **Multiplication with overflow detection**
    - [x] Check ERR propagation
    - [x] Perform multiplication with overflow check
    - [x] Emit LLVM IR: `llvm.smul.with.overflow`
  - [x] **Division with error checking**
    - [x] Check ERR propagation
    - [x] Check division by zero â†’ return ERR
    - [x] Handle MIN / -1 overflow â†’ return ERR
  - [x] **Modulo operation**
    - [x] Same error propagation rules implemented
  - [x] **Negation safety**
    - [x] Special case: -ERR = ERR (sticky)
    - [x] Check if negation would overflow â†’ ERR
    - [x] Example: tbb8(-127) negates to +127 (safe!)
  - [x] **Tests validate all operations**: 26/26 passing
    - [ ] No overflow possible with symmetric range
  - [ ] Add comprehensive tests in `tests/codegen/test_tbb_arithmetic.cpp`
    - [ ] Test sticky error propagation: ERR + 5 = ERR
    - [ ] Test overflow detection: tbb8(100) + tbb8(50) = ERR
    - [ ] Test symmetric negation: -127 â†’ +127
    - [ ] Test chained operations: (ERR + 5) * 10 = ERR

#### 1.1.3 TBB Comparison Operations
- [ ] Implement TBB comparison in `ExprCodeGen`
  - [ ] ERR comparisons: ERR == ERR â†’ true, ERR != anything â†’ true
  - [ ] Normal comparisons work as expected
  - [ ] Document comparison semantics

#### 1.1.4 TBB-Regular Type Interactions
- [ ] Define implicit/explicit conversion rules
  - [ ] int32 â†’ tbb32: check range, emit ERR if out of bounds
  - [ ] tbb32 â†’ int32: check for ERR, handle appropriately
  - [ ] Document conversion semantics

### 1.2 Exotic Types (Balanced Ternary/Nonary) - NON-NEGOTIABLE
**Status**: Tokens/Parser done, waiting on research  
**Dependencies**: research_002, research_003

#### 1.2.1 Trit/Tryte Implementation (After research_002)
- [ ] Review research findings from Gemini
- [ ] Create `TernaryArithmetic` class in `src/backend/ternary_arithmetic.cpp`
  - [ ] Implement ternary addition algorithm
  - [ ] Implement ternary subtraction algorithm
  - [ ] Implement ternary multiplication algorithm
  - [ ] Implement ternary division algorithm
  - [ ] Implement comparison operations
- [ ] Create packing/unpacking functions
  - [ ] `packTryte()`: Pack 10 trits into uint16
  - [ ] `unpackTryte()`: Extract 10 trits from uint16
  - [ ] Document bit layout
- [ ] Implement binaryâ†”ternary conversion
  - [ ] `binaryToTernary()`: int â†’ balanced ternary
  - [ ] `ternaryToBinary()`: balanced ternary â†’ int
  - [ ] Handle negative numbers correctly
- [ ] Extend `ExprCodeGen` for trit/tryte operations
  - [ ] Map trit operations to LLVM IR
  - [ ] Map tryte operations (packed representation)
  - [ ] Optimize common operations
- [ ] Add comprehensive tests
  - [ ] Test arithmetic correctness
  - [ ] Test packing/unpacking
  - [ ] Test conversions
  - [ ] Test edge cases

#### 1.2.2 Nit/Nyte Implementation âœ… COMPLETE (v0.0.12 - Dec 11, 2025)
**Research Status**: âœ… Received Dec 11, 2025 (59KB report)
**Implementation Status**: âœ… COMPLETE (3.5 hours)

**Key Implementation Details**:
- Biased-Radix Packing: `stored = value + 29524`
- Zero = 0x7354, Min = 0x0000, Max = 0xE6A8, ERR = 0xFFFF
- Optimized arithmetic: Direct bias operations
- Comparison: O(1) unsigned less-than (monotonic encoding)
- Performance: 50-70% of native int16 with safety guarantees
- SIMD-ready: 8 nytes per SSE register

**Files Implemented**:
- [x] `src/backend/nonary_ops.{h,cpp}` - Runtime operations (360 lines)
- [x] `src/backend/codegen_nonary.{h,cpp}` - LLVM codegen (242 lines)
- [x] `src/backend/nonary_runtime.cpp` - C linkage wrappers (91 lines)
- [x] `docs/BALANCED_NONARY_STATUS.md` - Complete documentation

**Operations Implemented**:
- [x] Create runtime library with NonaryOps class
  - [x] Implement `aria_nyte_add(uint16_t a, uint16_t b)` with bias logic
  - [x] Implement `aria_nyte_sub(uint16_t a, uint16_t b)`
  - [x] Implement `aria_nyte_mul(uint16_t a, uint16_t b)` with 64-bit intermediate
  - [x] Implement `aria_nyte_div(uint16_t a, uint16_t b)` with zero check
  - [x] Implement `aria_nyte_mod(uint16_t a, uint16_t b)` modulo operation
  - [x] Implement `aria_nyte_negate(uint16_t a)` negation
  - [x] Add sticky ERR propagation to all operations
- [x] Create packing/unpacking functions
  - [x] `packNyte()`: Pack value into biased uint16 (value + 29524)
  - [x] `unpackNyte()`: Extract value from biased uint16 (stored - 29524)
  - [x] `isValidNyte()`: Check if uint16 is valid nyte (â‰¤ 0xE6A8)
  - [x] Document bias = 29524, range [-29524, +29524]
- [x] Implement binaryâ†”nonary string conversion
  - [x] `unpackValue()`: Extract int32 value (stored - 29524)
  - [x] `packValue()`: Pack int32 with range check
  - [x] `toString()`: Convert to balanced nonary digits (-4..+4)
  - [x] `nitToString()`: Format individual nit values
- [x] Extend codegen for nit/nyte operations
  - [x] NonaryLowerer class with LLVM IR generation
  - [x] Runtime function declarations
  - [x] Map nit to i8 (native), nyte to i16 (packed)
  - [x] Use optimized comparison (direct uint16 compare)
- [x] Add comprehensive tests (26/26 passing)
  - [x] Test biased arithmetic correctness
  - [x] Test ERR sentinel propagation (sticky errors)
  - [x] Test edge cases (min/max values, overflow â†’ ERR)
  - [x] Test comparison operations (monotonic encoding)

### 1.3 Vector Types (vec2, vec3, vec4) âœ… COMPLETE (v0.0.13 - Dec 11, 2025)
**Status**: Runtime + SIMD codegen complete
**Implementation Time**: ~2 hours
**Test Results**: 25/25 passing

**Files Implemented**:
- [x] `src/backend/vector_ops.{h,cpp}` - Runtime operations (Vec2/3/4, DVec2/3/4, IVec2/3/4)
- [x] `src/backend/codegen_vector.{h,cpp}` - LLVM SIMD codegen (VectorLowerer class)
- [x] `src/backend/vector_runtime.cpp` - C linkage wrappers
- [x] `tests/vector/test_vector_ops.cpp` - 25 comprehensive tests

**Operations Implemented**:
- [x] Vector arithmetic (add, sub, mul, div, scale, negate)
- [x] Vector operations (dot product, cross product, length, normalize, distance)
- [x] Component access (extract/insert elements)
- [x] Swizzling (shufflevector for efficient reordering)
- [x] SIMD optimization (LLVM fixed-size vectors, fmul/fadd/fsub)
- [x] Comparison (component-wise with epsilon tolerance)

**SIMD Features**:
- [x] Uses LLVM FixedVectorType for hardware acceleration
- [x] Horizontal add for dot product
- [x] LLVM sqrt/fabs intrinsics
- [x] Shufflevector for swizzling (zero-cost abstraction)

**Test Coverage**:
- [x] Vec2/3/4 construction and arithmetic (8 tests)
- [x] Vector operations: dot, cross, length, normalize (9 tests)
- [x] Edge cases: zero vectors, perpendicular, self-cross (8 tests)
- All tests passing with float precision tolerance

### 1.4 Compound Types âœ… COMPLETE (v0.0.14 - Dec 11, 2025)

#### 1.4.1 Tensor Type Implementation âœ…
**Status**: Runtime complete, 22/22 tests passing
**Implementation Time**: ~10 minutes

**Files Implemented**:
- [x] `src/backend/tensor_ops.h` - Template-based tensor class (320 lines)
- [x] `tests/tensor/test_tensor_ops.cpp` - Comprehensive tests (22/22 passing)

**Operations Implemented**:
- [x] N-dimensional array construction (1D, 2D, 3D, arbitrary rank)
- [x] Row-major memory layout (C-style, cache-friendly)
- [x] Multi-dimensional indexing with stride calculation
- [x] Reshape (constant size, view change)
- [x] Transpose (2D tensors)
- [x] Element-wise arithmetic (add, sub, mul, scale)
- [x] Matrix multiplication (optimized inner loop)
- [x] Reductions (sum, mean)
- [x] Type specializations (TensorF32, TensorF64, TensorI32, TensorI64)

**Test Coverage**:
- [x] Construction: 1D/2D/3D tensors, fill values, from data (5 tests)
- [x] Indexing: Multi-dimensional access, row-major layout (4 tests)
- [x] Reshape: 2Dâ†”1D, arbitrary dimensions (3 tests)
- [x] Transpose: 2D matrix transposition (1 test)
- [x] Arithmetic: Element-wise ops, scalar multiply (4 tests)
- [x] Matrix multiplication: 2x2, 2x3Ã—3x2 (2 tests)
- [x] Reductions: sum, mean (2 tests)
- [x] Integer tensors: TensorI32 operations (1 test)

#### 1.4.2 Matrix Type Implementation
- [ ] Define `MatrixType` in AST
  - [ ] Support NxM matrices
  - [ ] Specialized 2D tensor representation
- [ ] Implement matrix operations
  - [ ] Matrix addition/subtraction
  - [ ] Matrix multiplication (optimized)
  - [ ] Transpose
  - [ ] Determinant
  - [ ] Inverse
- [ ] CodeGen for matrices
  - [ ] Use BLAS/LAPACK when available
  - [ ] Optimize memory access patterns
  - [ ] SIMD acceleration
- [ ] Add tests

### 1.5 System Types for Standard Library

#### 1.5.1 Binary Type
- [ ] Define `BinaryType` for raw byte data
- [ ] Implement binary operations
- [ ] Add serialization/deserialization
- [ ] CodeGen and tests

#### 1.5.2 Buffer Type
- [ ] Define `BufferType` for memory buffers
- [ ] Implement buffer operations (read, write, resize)
- [ ] Add bounds checking
- [ ] CodeGen and tests

#### 1.5.3 Stream Type
- [ ] Define `StreamType` for I/O streams
- [ ] Implement stream operations (read, write, seek, close)
- [ ] Add buffering support
- [ ] CodeGen and tests

#### 1.5.4 Process Type
- [ ] Define `ProcessType` for OS processes
- [ ] Implement process operations (spawn, wait, kill, communicate)
- [ ] Add platform-specific implementations
- [ ] CodeGen and tests

#### 1.5.5 Pipe Type
- [ ] Define `PipeType` for IPC
- [ ] Implement pipe operations (read, write, close)
- [ ] Add bidirectional pipe support
- [ ] CodeGen and tests

---

## PHASE 2: Memory Safety & Borrow Checking
**Goal**: Implement Rust-style borrow checker for wild memory safety  
**Dependencies**: research_001 MUST be complete  
**Timeline**: 4-6 weeks  
**Priority**: CRITICAL (core safety feature)

### 2.1 Lifetime Analysis System
**Status**: Stubs exist, need full implementation  
**Reference**: `/docs/research/wildx_memory_regions.md` (Appendage Theory)

#### 2.1.1 Lifetime Annotation Framework
- [ ] After receiving research_001 response, extract lifetime algorithm
- [ ] Create `LifetimeAnalyzer` class in `src/frontend/sema/lifetime_analyzer.cpp`
  - [ ] Define lifetime representation
    - [ ] Named lifetimes: 'a, 'b, 'static
    - [ ] Anonymous lifetimes (inferred)
    - [ ] Lifetime bounds and constraints
  - [ ] Implement lifetime inference
    - [ ] Function parameter lifetimes
    - [ ] Return value lifetime elision
    - [ ] Struct field lifetimes
  - [ ] Build lifetime dependency graph
    - [ ] Track lifetime relationships
    - [ ] Detect lifetime conflicts
    - [ ] Validate lifetime hierarchies
  - [ ] Add tests for lifetime inference

#### 2.1.2 Borrow Checker Core
- [ ] Implement `BorrowChecker` class (expand existing stub)
  - [ ] **Borrow rules implementation**
    - [ ] Rule 1: Multiple immutable borrows allowed
    - [ ] Rule 2: Only one mutable borrow at a time
    - [ ] Rule 3: No mutable borrow while immutable borrows exist
    - [ ] Rule 4: Borrows must not outlive referent
  - [ ] **Borrow tracking**
    - [ ] Track active borrows per scope
    - [ ] Track borrow kind (immutable vs mutable)
    - [ ] Track borrow lifetime
  - [ ] **Validation logic**
    - [ ] Check for conflicting borrows
    - [ ] Check for use-after-free
    - [ ] Check for dangling references
  - [ ] **Error reporting**
    - [ ] Clear borrow conflict messages
    - [ ] Show conflicting borrow locations
    - [ ] Suggest fixes (e.g., scope reduction)
  - [ ] Add comprehensive tests
    - [ ] Test basic borrow rules
    - [ ] Test complex borrowing patterns
    - [ ] Test error messages

#### 2.1.3 Pinning Operator (#) Implementation
- [ ] Implement `#` (pin) operator semantics
  - [ ] Parse pinning expressions
  - [ ] Type check pinned values
  - [ ] Generate pinning metadata
- [ ] Integrate with GC
  - [ ] Mark pinned objects in GC header
  - [ ] Prevent GC from moving pinned objects
  - [ ] Auto-unpin when scope ends
- [ ] CodeGen for pinning
  - [ ] Emit pin markers in LLVM IR
  - [ ] Generate cleanup code (unpin on scope exit)
  - [ ] Handle pinning errors
- [ ] Add tests
  - [ ] Test pinning GC objects
  - [ ] Test pinning in closures
  - [ ] Test pinning with async

#### 2.1.4 Appendage Theory Integration
- [ ] Review `/docs/research/wildx_memory_regions.md`
- [ ] Implement GC body + wild appendages model
  - [ ] Track appendages attached to GC objects
  - [ ] Enforce borrow rules for appendages
  - [ ] Cleanup appendages when body is collected
- [ ] Add lifetime tracking for appendages
  - [ ] Appendage lifetime tied to body lifetime
  - [ ] Prevent dangling appendage references
- [ ] CodeGen for appendages
  - [ ] Emit appendage registration
  - [ ] Emit cleanup code
- [ ] Add tests

### 2.2 Escape Analysis
**Status**: Stub exists, needs implementation

#### 2.2.1 Escape Analysis Pass
- [ ] Expand `EscapeAnalyzer` class
  - [ ] Implement control flow analysis
  - [ ] Track value flow through program
  - [ ] Identify values that escape function scope
  - [ ] Identify values that escape to heap
- [ ] Integration with memory allocation
  - [ ] Auto-promote stackâ†’heap when necessary
  - [ ] Warn about unnecessary heap allocations
  - [ ] Suggest stack allocation when safe
- [ ] Add tests

### 2.3 Safe Reference ($) Operator
**Status**: Token exists, needs full implementation

#### 2.3.1 Safe Reference Implementation
- [ ] Implement `$` operator semantics
  - [ ] Safe references can't dangle
  - [ ] Enforced by borrow checker
  - [ ] Used in till loops and safe contexts
- [ ] Type checking for safe references
- [ ] CodeGen for safe references
- [ ] Add tests

---

## PHASE 3: Module System & Visibility
**Goal**: Implement complete module system with imports and visibility  
**Dependencies**: None (can run parallel to Phase 1/2)  
**Timeline**: 3-4 weeks  
**Priority**: HIGH (necessary for stdlib organization)

### 3.1 Module Resolution

#### 3.1.1 Module Path Resolution
- [ ] Review existing research: `/docs/research/module_system_implementation.md`
- [ ] Implement `ModuleResolver` class in `src/frontend/module_resolver.cpp`
  - [ ] **Path resolution strategies**
    - [ ] Relative imports: `use "./local.aria"`
    - [ ] Absolute imports: `use "/usr/lib/aria/module"`
    - [ ] Standard library imports: `use std.io`
    - [ ] Selective imports: `use std.collections.{array, map}`
    - [ ] Wildcard imports: `use math.*`
  - [ ] **Module search paths**
    - [ ] Current directory
    - [ ] Project source directory
    - [ ] Standard library path ($ARIA_LIB)
    - [ ] User-defined paths (ARIA_PATH environment variable)
  - [ ] **File resolution**
    - [ ] .aria file extension handling
    - [ ] Directory modules (module.aria or mod.aria in directory)
    - [ ] Index file support
  - [ ] Add tests for path resolution

#### 3.1.2 Module Dependency Graph
- [ ] Implement dependency tracking
  - [ ] Build directed acyclic graph (DAG) of modules
  - [ ] Detect circular dependencies â†’ error
  - [ ] Topological sort for compilation order
- [ ] Handle module initialization order
  - [ ] Ensure dependencies initialized before dependents
  - [ ] Generate static initializer calls
- [ ] Add tests
  - [ ] Test simple dependencies
  - [ ] Test complex dependency chains
  - [ ] Test circular dependency detection

### 3.2 Module Definition (mod keyword)

#### 3.2.1 Module Declaration
- [ ] Implement module declaration parsing (already done)
- [ ] Type checking for modules
  - [ ] Validate module names (no conflicts)
  - [ ] Check for duplicate definitions
  - [ ] Validate nested modules
- [ ] CodeGen for modules
  - [ ] Generate module namespace
  - [ ] Emit module metadata
  - [ ] Handle nested modules
- [ ] Add tests

### 3.3 Visibility Control (pub keyword)

#### 3.3.1 Visibility Rules Implementation
- [ ] Implement visibility checker in type checker
  - [ ] Private by default (no `pub`)
  - [ ] Public when `pub` specified
  - [ ] Check access violations
    - [ ] Can't access private items from outside module
    - [ ] Can access public items from anywhere
  - [ ] Nested module visibility rules
    - [ ] Parent can access child's private items
    - [ ] Child can access parent's private items
    - [ ] Siblings need `pub` for access
- [ ] Add visibility to all declarations
  - [ ] Functions
  - [ ] Structs
  - [ ] Traits
  - [ ] Impls
  - [ ] Constants
  - [ ] Type aliases
- [ ] Generate clear error messages for visibility violations
- [ ] Add tests

### 3.4 Import System (use keyword)

#### 3.4.1 Import Declaration Processing
- [ ] Implement import resolution
  - [ ] Simple imports: `use std.io`
  - [ ] Selective imports: `use std.{io, fs}`
  - [ ] Aliased imports: `use "./utils.aria" as utils`
  - [ ] Wildcard imports: `use math.*`
- [ ] Build import table for each module
- [ ] Resolve imported symbols
  - [ ] Map import names to module symbols
  - [ ] Handle name conflicts â†’ error
  - [ ] Support nested imports
- [ ] CodeGen for imports
  - [ ] Link imported modules
  - [ ] Generate import metadata
- [ ] Add tests

### 3.5 External C Integration (extern keyword)

#### 3.5.1 C FFI Implementation
- [ ] Implement `extern` block parsing (already done)
- [ ] Type mapping: Aria â†” C
  - [ ] int8 â†” int8_t
  - [ ] int32 â†” int32_t
  - [ ] string â†” char*
  - [ ] pointers â†” pointers
  - [ ] arrays â†” arrays
- [ ] Call convention handling
  - [ ] Default C calling convention
  - [ ] Platform-specific conventions (cdecl, stdcall, etc.)
- [ ] Symbol resolution
  - [ ] Dynamic library loading
  - [ ] Static library linking
- [ ] CodeGen for extern functions
  - [ ] Emit LLVM external declarations
  - [ ] Generate wrapper functions if needed
  - [ ] Handle varargs (printf, etc.)
- [ ] Add tests
  - [ ] Test calling libc functions
  - [ ] Test external libraries

### 3.6 Conditional Compilation

#### 3.6.1 cfg() Attribute System
- [ ] Implement conditional compilation attributes
  - [ ] Platform detection: `cfg(target_os = "linux")`
  - [ ] Feature flags: `cfg(feature = "networking")`
  - [ ] Architecture: `cfg(target_arch = "x86_64")`
- [ ] Parse cfg attributes
- [ ] Evaluate cfg conditions at compile time
- [ ] Remove disabled code from compilation
- [ ] Add tests

---

## PHASE 4: Generics & Monomorphization
**Goal**: Zero-cost generic programming via monomorphization  
**Dependencies**: Type system complete (Phase 1)  
**Timeline**: 4-5 weeks  
**Priority**: HIGH (core abstraction mechanism)

### 4.1 Generic Type Parameters

#### 4.1.1 Type Parameter Parsing & Validation
- [ ] Review existing research: `/docs/research/generics_monomorphization_implementation.md`
- [ ] Enhance generic function parsing (basic parsing exists)
  - [ ] Parse type parameter lists: `<T, U, V>`
  - [ ] Parse type parameter constraints (bounds)
  - [ ] Parse where clauses (if needed)
- [ ] Type checking for generics
  - [ ] Validate type parameter names (no conflicts)
  - [ ] Check constraint satisfaction
  - [ ] Validate generic function bodies
    - [ ] Ensure `*T` used correctly
    - [ ] Check operations valid for generic types
  - [ ] Handle recursive generic definitions
- [ ] Add tests

#### 4.1.2 Type Inference System
- [ ] Implement type inference for generic calls
  - [ ] Infer type arguments from function arguments
  - [ ] Infer from return type context
  - [ ] Infer from multiple sources (unification)
- [ ] Implement unification algorithm
  - [ ] Unify type variables
  - [ ] Detect unification failures â†’ error
  - [ ] Generate clear error messages
- [ ] Add tests
  - [ ] Test simple inference: `max(1, 2)` â†’ `max<int32>`
  - [ ] Test complex inference: nested generics
  - [ ] Test inference failures

### 4.2 Monomorphization Pass

#### 4.2.1 Monomorphization Implementation
- [ ] Create `MonomorphizationPass` in `src/backend/monomorphization.cpp` (stub exists)
  - [ ] **Collect generic instantiations**
    - [ ] Scan AST for generic function calls
    - [ ] Record (function, type args) pairs
    - [ ] Handle transitive instantiations (generic calls generic)
  - [ ] **Generate specialized versions**
    - [ ] Clone function AST
    - [ ] Substitute type parameters with concrete types
      - [ ] Replace `*T` with concrete type
      - [ ] Update all type references
    - [ ] Rename specialized function (mangling)
      - [ ] Example: `max<int32>` â†’ `max_int32`
      - [ ] Handle multiple type parameters
  - [ ] **Deduplication**
    - [ ] Cache generated specializations
    - [ ] Reuse existing specializations
    - [ ] Avoid duplicate codegen
  - [ ] **Update call sites**
    - [ ] Replace generic calls with specialized calls
    - [ ] Update function references
- [ ] Add comprehensive tests
  - [ ] Test simple generics: `identity<T>`
  - [ ] Test multiple type parameters: `convert<T,U>`
  - [ ] Test generic structs (if supported)
  - [ ] Test transitive instantiation
  - [ ] Test large-scale monomorphization (compile time impact)

### 4.3 Generic Structs (if in spec)

#### 4.3.1 Generic Struct Support
- [ ] Check spec for generic struct syntax
- [ ] If supported, implement:
  - [ ] Parse generic struct definitions
  - [ ] Type check generic structs
  - [ ] Monomorphize struct definitions
  - [ ] Generate specialized struct types
  - [ ] Update field access codegen
- [ ] Add tests

### 4.4 Generic Traits (if in spec)

#### 4.4.1 Generic Trait Support
- [ ] Check spec for generic trait syntax
- [ ] If supported, implement:
  - [ ] Parse generic trait definitions
  - [ ] Type check generic traits
  - [ ] Monomorphize trait impls
  - [ ] Update trait dispatch
- [ ] Add tests

---

## PHASE 5: Standard Library - Core
**Goal**: Implement essential stdlib functions per spec  
**Dependencies**: Type system (Phase 1), Module system (Phase 3)  
**Timeline**: 3-4 weeks  
**Priority**: HIGH (basic functionality)

### 5.1 Memory Management Functions

#### 5.1.1 Allocator Functions
- [ ] Implement in `stdlib/memory.aria` or `src/runtime/stdlib/memory.cpp`
  - [ ] `aria.alloc(size: uint64) -> result<void*, string>`
    - [ ] Wrapper around mimalloc
    - [ ] Return error on allocation failure
    - [ ] Add tests
  - [ ] `aria.free(ptr: void*)`
    - [ ] Wrapper around free
    - [ ] Null pointer handling
    - [ ] Add tests
  - [ ] `aria.gc_alloc(size: uint64) -> result<void*, string>`
    - [ ] Allocate in GC nursery
    - [ ] Register with GC
    - [ ] Add tests
  - [ ] `aria.alloc_buffer(size: uint64) -> result<buffer, string>`
    - [ ] Specialized buffer allocation
    - [ ] Add metadata (size, capacity)
    - [ ] Add tests
  - [ ] `aria.alloc_string(size: uint64) -> result<string, string>`
    - [ ] String-specific allocation
    - [ ] UTF-8 handling
    - [ ] Add tests
  - [ ] `aria.alloc_array(elem_size: uint64, count: uint64) -> result<array, string>`
    - [ ] Array allocation with size info
    - [ ] Bounds checking metadata
    - [ ] Add tests

### 5.2 String Functions

#### 5.2.1 Basic String Operations
- [ ] Implement in `stdlib/string.aria`
  - [ ] `string.length() -> int64`
  - [ ] `string.concat(other: string) -> string`
  - [ ] `string.substring(start: int64, end: int64) -> string`
  - [ ] `string.indexOf(substr: string) -> int64`
  - [ ] `string.split(delimiter: string) -> array<string>`
  - [ ] `string.trim() -> string`
  - [ ] `string.toUpper() -> string`
  - [ ] `string.toLower() -> string`
  - [ ] Add comprehensive tests

### 5.3 Array Functions

#### 5.3.1 Functional Array Operations
- [ ] Implement in `stdlib/array.aria`
  - [ ] `filter<T>(arr: *T[], pred: func(*T) -> bool) -> *T[]`
    - [ ] Filter elements by predicate
    - [ ] Use generics for type safety
    - [ ] Add tests
  - [ ] `transform<T,U>(arr: *T[], f: func(*T) -> *U) -> *U[]`
    - [ ] Map function over array
    - [ ] Support type transformation
    - [ ] Add tests (also called `map`)
  - [ ] `reduce<T,U>(arr: *T[], f: func(*U, *T) -> *U, init: *U) -> *U`
    - [ ] Fold array into single value
    - [ ] Generic accumulator type
    - [ ] Add tests
  - [ ] `sort<T>(arr: *T[], cmp: func(*T, *T) -> int) -> *T[]`
    - [ ] Generic sorting with comparator
    - [ ] Use quicksort or mergesort
    - [ ] Add tests
  - [ ] `reverse<T>(arr: *T[]) -> *T[]`
    - [ ] Reverse array in-place or return new
    - [ ] Add tests
  - [ ] `unique<T>(arr: *T[]) -> *T[]`
    - [ ] Remove duplicates
    - [ ] Preserve order
    - [ ] Add tests

### 5.4 Math Functions

#### 5.4.1 Basic Math Operations
- [ ] Implement in `stdlib/math.aria`
  - [ ] `Math.round(x: flt64) -> flt64`
  - [ ] `Math.floor(x: flt64) -> flt64`
  - [ ] `Math.ceil(x: flt64) -> flt64`
  - [ ] `Math.abs(x: flt64) -> flt64`
  - [ ] `Math.sqrt(x: flt64) -> flt64`
  - [ ] `Math.pow(x: flt64, y: flt64) -> flt64`
  - [ ] `Math.sin(x: flt64) -> flt64`
  - [ ] `Math.cos(x: flt64) -> flt64`
  - [ ] `Math.tan(x: flt64) -> flt64`
  - [ ] Add comprehensive tests

### 5.5 System Diagnostics

#### 5.5.1 Diagnostic Functions
- [ ] Implement in `stdlib/system.aria`
  - [ ] `getMemoryUsage() -> obj`
    - [ ] Return heap usage, GC stats, etc.
    - [ ] Add tests
  - [ ] `getActiveConnections() -> int64`
    - [ ] Count active network connections
    - [ ] Add tests

---

## PHASE 6: Standard Library - I/O
**Goal**: Implement file I/O, streams, and process management  
**Dependencies**: research_004, research_005, research_006  
**Timeline**: 4-5 weeks  
**Priority**: HIGH (critical for real applications)

### 6.1 File I/O System
**Status**: Awaiting research_004

#### 6.1.1 Basic File Operations
- [ ] After research_004 complete, review API design
- [ ] Implement in `stdlib/io/file.aria` or `src/runtime/io/file.cpp`
  - [ ] **readFile(path: string) -> result<string, string>**
    - [ ] Open file (error handling)
    - [ ] Read entire contents
    - [ ] Return error result on failure
    - [ ] Platform-specific implementations
      - [ ] Linux: use open/read/close
      - [ ] Windows: use CreateFile/ReadFile/CloseHandle
    - [ ] Add tests
      - [ ] Test successful reads
      - [ ] Test file not found
      - [ ] Test permission denied
      - [ ] Test large files
  - [ ] **writeFile(path: string, content: string) -> result<void, string>**
    - [ ] Create/truncate file
    - [ ] Write content
    - [ ] Error handling (disk full, permissions, etc.)
    - [ ] Add tests
  - [ ] **readJSON(path: string) -> result<obj, string>**
    - [ ] Read file
    - [ ] Parse JSON
    - [ ] Return structured object
    - [ ] Add JSON parser if not exists
    - [ ] Add tests
  - [ ] **readCSV(path: string) -> result<array<array<string>>, string>**
    - [ ] Read file
    - [ ] Parse CSV
    - [ ] Handle quoted fields, escaping
    - [ ] Add tests

#### 6.1.2 Stream-Based File I/O
- [ ] **openFile(path: string, mode: string) -> result<stream, string>**
  - [ ] Modes: "r" (read), "w" (write), "a" (append), "r+" (read/write)
  - [ ] Return stream object
  - [ ] Error handling
  - [ ] Add tests
- [ ] Implement `stream` type operations
  - [ ] `stream.read(size: int64) -> result<string, string>`
  - [ ] `stream.readLine() -> result<string, string>`
  - [ ] `stream.write(data: string) -> result<void, string>`
  - [ ] `stream.seek(offset: int64, whence: int) -> result<void, string>`
  - [ ] `stream.tell() -> result<int64, string>`
  - [ ] `stream.close() -> result<void, string>`
  - [ ] Add tests for all operations

### 6.2 Modern I/O Streams (6-Stream System) âœ… RESEARCH COMPLETE
**Status**: âœ… Research complete (research_006, 388 lines)
**Reference**: `/docs/IO_STREAMS_IMPLEMENTATION_PLAN.md` (detailed 8-week plan)
**Dependencies**: Phase 5 (file I/O), Phase 7 (async runtime)
**Timeline**: 8 weeks

**Key Design**: Replaces 3-stream Unix model with semantic separation:
- **Text Plane** (stdin/stdout/stderr): Human interaction, line-buffered, UTF-8
- **Data Plane** (stddati/stddato): Binary pipelines, block-buffered, zero-copy
- **Observability** (stddbg): Diagnostics, async ring-buffered, drop-on-full

#### 6.2.1 Runtime Stream Infrastructure (2 weeks)
- [ ] Create `src/runtime/stream.cpp` with base Stream trait
  - [ ] Text I/O: `write()`, `writeLine()`, `readLine()` (UTF-8 enforced)
  - [ ] Binary I/O: `writeBytes()`, `readBytes()`, `readInto()` (wild buffers)
  - [ ] TBB I/O: `writeTBB8/16/32/64()`, `readTBB8/16/32/64()` (sentinel-safe)
  - [ ] Utility: `flush()`, `close()`, `isatty()`
- [ ] Create DebugStream specialization for stddbg
  - [ ] `log(level, msg, data)`, `warn()`, `error()` methods
  - [ ] Structured logging (JSON lines or custom format)
- [ ] Create DataStream specialization for stddati/stddato
  - [ ] Binary protocol support
  - [ ] Endianness handling (Network Byte Order default)
- [ ] Create buffering implementations in `src/runtime/io_buffers.cpp`
  - [ ] LineBuffer: 1-4KB, flush on newline (text streams)
  - [ ] BlockBuffer: 64KB+, dynamic sizing (data streams)
  - [ ] AsyncRingBuffer: SPSC lock-free, drop-on-full (stddbg)

#### 6.2.2 Platform-Specific Backends (2 weeks)
- [ ] Create `src/runtime/io_linux.cpp`
  - [ ] Initialize FDs 3-5 using `fcntl(F_GETFD)` validation
  - [ ] Default provisioning: stddbgâ†’/dev/null or $ARIA_LOG_FILE
  - [ ] Process spawning: `dup2()` for pipe wiring to FDs 3-5
  - [ ] Zero-copy: `splice()` syscall for stddatiâ†’stddato
  - [ ] Conditional compilation: `cfg(target_os = "linux")`
- [ ] Create `src/runtime/io_windows.cpp`
  - [ ] Initialize HANDLEs via `CreatePipe()` for anonymous pipes
  - [ ] Handle passing: env var `__ARIA_STREAMS=DBG:<val>;IN:<val>;OUT:<val>`
  - [ ] Runtime reconstruction: parse env var, cast to HANDLEs
  - [ ] Named pipes: `\\.\pipe\aria-debug-*` for persistent IPC
  - [ ] Conditional compilation: `cfg(target_os = "windows")`
- [ ] Create `src/runtime/io_init.cpp`
  - [ ] Global singleton initialization for all 6 streams
  - [ ] Platform detection and backend selection
  - [ ] Early runtime initialization (before main)

#### 6.2.3 High-Level API (1 week)
- [ ] Implement global stream objects in `std.io` module
  - [ ] `io.stdin`: Stream (FD 0, text, line-buffered)
  - [ ] `io.stdout`: Stream (FD 1, text, line-buffered)
  - [ ] `io.stderr`: Stream (FD 2, text, line-buffered)
  - [ ] `io.stddbg`: DebugStream (FD 3, structured, async ring)
  - [ ] `io.stddati`: DataStream (FD 4, binary, block-buffered)
  - [ ] `io.stddato`: DataStream (FD 5, binary, block-buffered)
- [ ] Implement cross-platform normalization
  - [ ] Line ending: `\r\n`â†’`\n` on input, `\n`â†’`\r\n` on Windows output
  - [ ] UTF-8 validation: enforce on text streams, reject invalid sequences
  - [ ] Binary streams: no normalization, raw bytes
- [ ] Thread safety
  - [ ] Mutex locking per stream (atomic writes)
  - [ ] Buffer pinning: `#` operator for GC-managed buffers during syscalls
  - [ ] Wild memory: zero-copy I/O without pinning overhead

#### 6.2.4 Process Integration (1 week)
- [ ] Enhance `spawn()` API in `src/runtime/process/`
  - [ ] Stream redirection configuration:
    ```aria
    spawn("./processor", {
      stdin: io.stdin,
      stdout: io.stdout,
      stderr: io.stderr,
      stddbg: openFile("debug.log", "w"),
      stddati: pipe_reader,
      stddato: pipe_writer
    });
    ```
  - [ ] Pipe wiring for FDs 3-5 (Linux: dup2, Windows: STARTUPINFOEX)
  - [ ] Handle inheritance (Windows: bInheritHandle=TRUE)
- [ ] Create `createPipe()` utility
  - [ ] Return pipe with read/write ends
  - [ ] Compatible with stream interface
  - [ ] Support for complex pipelines

#### 6.2.5 Async Integration (1 week)
- [ ] Register FDs 3-5 with event loop
  - [ ] Linux: `epoll` for all file descriptors
  - [ ] macOS: `kqueue`
  - [ ] Windows: `IOCP` for HANDLEs
- [ ] Implement async methods on Stream trait
  - [ ] `readAsync(size)`: suspend coroutine if no data
  - [ ] `writeAsync(data)`: suspend if buffer full
  - [ ] Coroutine resumption on data available (epoll signal)
- [ ] Backpressure management
  - [ ] Stop reading from FD if ring buffer fills
  - [ ] Kernel pipe/socket buffer fills â†’ sender throttles
  - [ ] Automatic flow control prevents OOM

#### 6.2.6 Testing & Documentation (1 week)
- [ ] Unit tests in `tests/io/`
  - [ ] `test_text_io.cpp`: line buffering, UTF-8 validation, newline normalization
  - [ ] `test_binary_io.cpp`: zero-copy, raw bytes, no corruption
  - [ ] `test_debug_stream.cpp`: structured logging, async buffering
  - [ ] `test_tbb_serialization.cpp`: sentinel-safe TBB read/write
  - [ ] `test_pipelines.cpp`: multi-process stddatoâ†’stddati chains
- [ ] Integration tests
  - [ ] ML pipeline simulation: binary tensors + text progress + debug logs
  - [ ] Stress tests: async I/O with high concurrency
  - [ ] Cross-platform: Ubuntu + Windows validation
- [ ] Documentation
  - [ ] API reference: `/docs/stdlib/io_streams.md`
  - [ ] Usage examples: text I/O, binary pipelines, debug logging
  - [ ] Migration guide: 3-stream â†’ 6-stream transition

#### 6.2.7 Security Hardening
- [ ] Implement stddbg secure mode
  - [ ] Environment variable: `ARIA_SECURE_MODE=1` â†’ redirect to /dev/null
  - [ ] Compile-time stripping: `cfg(release)` removes stddbg calls
- [ ] WildX protection
  - [ ] Type system: forbid passing `wildx` pointers to stream writes
  - [ ] Compiler error: security violation at compile time

### 6.3 Process Management
**Status**: Awaiting research_005

#### 6.3.1 Process Creation & Control
- [ ] After research_005 complete, review API design
- [ ] Implement in `stdlib/process.aria` or `src/runtime/process/`
  - [ ] **spawn(command: string, args: array<string>) -> result<process, string>**
    - [ ] Platform-specific implementations
      - [ ] Unix: fork + exec
      - [ ] Windows: CreateProcess
    - [ ] Return process handle
    - [ ] Error handling (command not found, permission denied)
    - [ ] Add tests
  - [ ] **fork() -> result<obj, string>**
    - [ ] Unix-specific (stub on Windows)
    - [ ] Return {is_child: bool, child_pid: int}
    - [ ] Add tests
  - [ ] **exec(command: string, args: array<string>) -> result<void, string>**
    - [ ] Replace current process
    - [ ] Platform-specific
    - [ ] Add tests
  - [ ] **wait(pid: int) -> result<int, string>**
    - [ ] Wait for process completion
    - [ ] Return exit code
    - [ ] Add tests

#### 6.3.2 Inter-Process Communication
- [ ] **createPipe() -> result<pipe, string>**
  - [ ] Create bidirectional pipe
  - [ ] Platform-specific (pipe() on Unix, CreatePipe on Windows)
  - [ ] Return pipe object with read/write ends
  - [ ] Add tests
- [ ] Implement `pipe` type operations
  - [ ] `pipe.read() -> result<string, string>`
  - [ ] `pipe.write(data: string) -> result<void, string>`
  - [ ] `pipe.close()` - close both ends
  - [ ] Add tests

### 6.4 HTTP Client (if in spec)

#### 6.4.1 Basic HTTP Support
- [ ] Check if `httpGet()` is in spec
- [ ] If yes, implement:
  - [ ] `httpGet(url: string) -> result<obj, string>`
    - [ ] Use libcurl or platform HTTP API
    - [ ] Return response object {status, headers, body}
    - [ ] Add tests

---

## PHASE 7: Standard Library - Concurrency
**Goal**: Implement threading, async improvements, atomics  
**Dependencies**: research_007 âœ…, research_008, research_009, Phase 2 (borrow checker)  
**Timeline**: 14 weeks (~3.5 months)  
**Priority**: MEDIUM-HIGH (important for performance)  
**Implementation Plan**: `/docs/THREADING_IMPLEMENTATION_PLAN.md` (755 lines)

**Architecture Overview** (from research_007):
- **Hybrid M:N + 1:1 Threading Model**: Explicit choice between lightweight async tasks and OS threads
- **Work-Stealing Scheduler**: Chase-Lev lock-free deques, O(1) local operations
- **Two-Layer API**:
  - `aria.task` (M:N): Async/await with work-stealing (200-500 bytes/task, millions concurrent)
  - `aria.thread` (1:1): Direct OS threads for CPU-bound work (~8MB/thread, ~10K max)
- **Blocking Bridge**: `spawn_blocking()` offloads sync work to dedicated thread pool
- **Thread Safety**: Enforced via Send/Sync traits integrated with Appendage Theory

### 7.1 Work-Stealing Scheduler (3 weeks)
**Status**: Ready to implement (Phase 7.1 in plan)

- [ ] **Chase-Lev Deque** (`src/runtime/work_stealing_deque.{h,cpp}`)
  - [ ] Implement lock-free deque (owner push/pop bottom, thieves steal top)
  - [ ] Atomic operations: CAS on last item prevents ABA problem
  - [ ] LIFO for owner (cache locality), FIFO for thieves (load balancing)
  - [ ] Dynamic buffer resize (rare, grows 2x)
  - [ ] Unit tests: push, pop, steal, concurrent stress test
  - [ ] Validate with ThreadSanitizer (no data races)

- [ ] **Worker Threads** (`src/runtime/worker_thread.cpp`)
  - [ ] Implement scheduler loop (spawn N workers, N = num_cores)
  - [ ] Local deque per worker (hot path, cache-friendly)
  - [ ] Steal logic: random victim selection (prevents pathological patterns)
  - [ ] Check global queue every 61 ticks (fairness, borrowed from Go)
  - [ ] Park/unpark mechanism (condvar, reduces CPU when idle)

- [ ] **Global Injection Queue** (`src/runtime/global_queue.cpp`)
  - [ ] MPMC lock-free queue (or mutex-based fallback)
  - [ ] Integration with worker loop (checked periodically for fairness)
  - [ ] Used for external task submission (spawn from non-worker threads)

### 7.2 Task Runtime API (2 weeks)
**Status**: Ready to implement (Phase 7.2 in plan)

- [ ] **aria.task Module** (`stdlib/task.aria` + C++ runtime)
  - [ ] `spawn<T>(async func:f) -> Future<T>`: Create task, push to local deque, eager execution
  - [ ] `spawn_blocking<T>(func:f) -> Future<T>`: Offload to blocking pool, prevents worker stalling
  - [ ] `yield_now()`: Cooperative yield, task suspended and re-enqueued
  - [ ] `block_on<T>(Future<T>:fut) -> Result<T>`: Entry point, drives scheduler from sync code
  - [ ] `id() -> uint64`: Get current task ID
  - [ ] Add tests: 10K concurrent tasks, mixed CPU/IO workloads

- [ ] **CoroutineFrame Layout** (LLVM backend integration)
  - [ ] State machine for async functions (LLVM 20.1.2 already supports coroutines)
  - [ ] Waker registration for resumption (when future resolves)
  - [ ] Result storage for completed tasks
  - [ ] Integration with work-stealing scheduler

### 7.3 Blocking Thread Pool (1 week)
**Status**: Ready to implement (Phase 7.3 in plan)

- [ ] **BlockingPool Class** (`src/runtime/blocking_pool.cpp`)
  - [ ] Dynamic thread pool: starts with N threads (num_cores)
  - [ ] Grows on demand (max 512 threads), shrinks after idle timeout (60s)
  - [ ] MPMC work queue (multi-producer multi-consumer)
  - [ ] Isolation: never blocks M:N workers

- [ ] **spawn_blocking API**
  - [ ] Submit to blocking pool (FIFO queue)
  - [ ] Return Future that resolves on completion
  - [ ] Waker integration: notify async task when blocking work done
  - [ ] Add tests: stress test with 100+ blocking tasks

### 7.4 Thread Subsystem (1 week)
**Status**: Ready to implement (Phase 7.4 in plan)

- [ ] **aria.thread Module** (`stdlib/thread.aria` + C++ runtime)
  - [ ] `spawn<T>(func:f) -> Result<JoinHandle<T>>`: Wrapper around pthread_create / CreateThread
  - [ ] `JoinHandle.join() -> Result<T>`: Blocks until thread finishes, returns result
  - [ ] `yield_now()`: sched_yield() or SwitchToThread()
  - [ ] `sleep(int64:milliseconds)`: Sleep thread
  - [ ] `id() -> uint64`: Get thread ID
  - [ ] Platform-specific implementations (Linux pthread, Windows CreateThread)
  - [ ] Add tests: parallel computation (4 threads, CPU-bound work)

### 7.5 Synchronization Primitives (3 weeks)
**Status**: Ready to implement (Phase 7.5 in plan)

- [ ] **Async Mutex** (`src/runtime/async_mutex.cpp`)
  - [ ] Atomic state + wait queue of Wakers (task-aware, never blocks worker thread)
  - [ ] Fast path: Atomic CAS to acquire (spin briefly)
  - [ ] Slow path: Suspend task, register Waker in wait queue
  - [ ] Release: Wake oldest Waker from queue (FIFO fairness)
  - [ ] RAII guard (MutexGuard) with automatic unlock on drop
  - [ ] **Compiler warning**: Detect holding async mutex across await (deadlock risk)
  - [ ] Add tests: fairness (no starvation), async mutex + channels

- [ ] **Sync Mutex** (`src/runtime/sync_mutex.cpp`)
  - [ ] Wrapper around pthread_mutex_t (Linux) / SRWLOCK (Windows)
  - [ ] Blocks thread (not task) - for use in 1:1 threads only
  - [ ] RAII guard with automatic unlock
  - [ ] Add tests: basic locking, tryLock

- [ ] **Channels** (`src/runtime/channel.cpp`)
  - [ ] Go-style CSP (Communicating Sequential Processes)
  - [ ] Lock-free ring buffer for data (bounded capacity)
  - [ ] Send waiters queue (when channel full, backpressure)
  - [ ] Recv waiters queue (when channel empty)
  - [ ] CAS-based index management (top/bottom pointers)
  - [ ] API: `channel<T>(capacity) -> (Sender<T>, Receiver<T>)`
  - [ ] `Sender.send(T) -> Result<void>`: Suspends if full
  - [ ] `Receiver.recv() -> Result<T>`: Suspends if empty
  - [ ] Add tests: SPSC, MPSC, MPMC throughput, backpressure handling

- [ ] **Semaphores** (if needed)
  - [ ] Both async and sync variants
  - [ ] Use cases: rate limiting, resource pools
  - [ ] Add tests

### 7.6 Borrow Checker Integration (2 weeks)
**Status**: Depends on Phase 2 (borrow checker)

- [ ] **Send/Sync Traits** (thread safety enforcement)
  - [ ] Define traits in type system (like Rust)
  - [ ] **Send**: Type can be moved to another thread (TBB types âœ“, wild pointers âœ—)
  - [ ] **Sync**: Type's immutable reference can be shared across threads (immutable primitives âœ“)
  - [ ] Implement for built-in types (TBB types, GC types, wild pointers)
  - [ ] Enforce in spawn/spawn_blocking: `spawn<T: Send>(async func:f) -> Future<T>`
  - [ ] Compiler errors for violating Send/Sync bounds

- [ ] **Cross-await Mutex Check**
  - [ ] Detect holding async mutex across await (static analysis)
  - [ ] Emit compiler warning: "Holding async mutex across await may deadlock"
  - [ ] Suggest alternatives: limit critical sections, use channels instead

- [ ] **Pin Verification for Shared Data**
  - [ ] Ensure GC objects are pinned (#) before sharing via wild pointers across threads
  - [ ] Example: `wild string*:pinned = #shared_data;` then `Mutex::new(pinned)`
  - [ ] Verify pins don't outlive data (borrow checker lifetime analysis)
  - [ ] All checked at compile time (zero runtime cost)

### 7.7 Testing & Optimization (2 weeks)
**Status**: Final phase after all above complete

- [ ] **Unit Tests**
  - [ ] Work-stealing correctness: 1000 tasks, random work distribution
  - [ ] Mutex fairness: 100 threads contending, no starvation
  - [ ] Channel throughput: SPSC (10M msgs/sec target), MPSC, MPMC
  - [ ] Blocking pool stress: 100+ concurrent blocking tasks

- [ ] **Integration Tests**
  - [ ] **C10K test**: 10,000 concurrent connections
    - [ ] Target: <100MB memory (10KB/connection)
    - [ ] Target: <1ms p99 latency
  - [ ] **Mixed CPU/IO workload**: async I/O + spawn_blocking for CPU work
  - [ ] **spawn_blocking stress**: Verify pool grows/shrinks correctly

- [ ] **Benchmarks**
  - [ ] Compare with Tokio (Rust): task creation, context switch, throughput
  - [ ] Compare with Go goroutines: C10K test, mixed workload
  - [ ] Latency histograms: p50, p99, p999 (use perf or similar)

- [ ] **Optimization**
  - [ ] Profile hot paths with perf (Linux) or Instruments (macOS)
  - [ ] NUMA-aware worker placement (pin workers to CPU cores)
  - [ ] Cache-line padding for atomics (prevent false sharing)
  - [ ] Validate zero-cost abstractions (assembly inspection)

### 7.3 Atomics Library (2-3 weeks)
**Status**: Research complete âœ… (research_008), ready to implement  
**Reference**: `/docs/gemini/responses/research_008_atomics_library.txt` (417 lines)

#### 7.3.1 Memory Model Foundation
- [ ] **Adopt C++11/LLVM Memory Model** (`src/runtime/memory_model.md` documentation)
  - [ ] Document happens-before relationships (sequenced-before + synchronizes-with)
  - [ ] Define data race semantics (wild memory = UB, gc memory = logical corruption)
  - [ ] Platform mapping: x86-64 TSO vs ARMv8 weak memory model

- [ ] **Ordering Enum** (`stdlib/sync/atomic.aria`)
  ```aria
  enum Ordering {
      Relaxed,    // No sync, only atomicity (cheapest)
      Acquire,    // Load barrier: subsequent ops can't hoist above
      Release,    // Store barrier: prior ops can't sink below
      AcqRel,     // RMW: Acquire on read, Release on write
      SeqCst      // Global total order (most expensive)
  }
  ```
  - [ ] Validation: Loads can't use Release/AcqRel, Stores can't use Acquire/AcqRel
  - [ ] Documentation: When to use each (counter=Relaxed, flag=Acquire/Release, refcount=AcqRel)

#### 7.3.2 Atomic Types (Standard Integers)
- [ ] **Atomic<T> Generic** (`src/runtime/atomic/atomic.cpp`)
  - [ ] Core methods:
    - [ ] `load(Ordering) -> T`: Atomic read
    - [ ] `store(T, Ordering)`: Atomic write
    - [ ] `swap(T, Ordering) -> T`: Atomic exchange (RMW)
    - [ ] `compare_exchange(current: T, new: T, success: Ordering, failure: Ordering) -> result`
    - [ ] `compare_exchange_weak(...)`: May spuriously fail (efficient for loops)
  - [ ] Arithmetic (for integer types):
    - [ ] `fetch_add(T, Ordering) -> T`: Returns **previous** value
    - [ ] `fetch_sub(T, Ordering) -> T`
    - [ ] `fetch_and/or/xor(T, Ordering) -> T`: Bitwise ops

- [ ] **Specialized Type Aliases** (`stdlib/sync/atomic.aria`)
  ```aria
  type AtomicBool = Atomic<bool>;
  type AtomicInt8 = Atomic<int8>;
  type AtomicInt16 = Atomic<int16>;
  type AtomicInt32 = Atomic<int32>;
  type AtomicInt64 = Atomic<int64>;
  type AtomicUint8 = Atomic<uint8>;
  type AtomicUint16 = Atomic<uint16>;
  type AtomicUint32 = Atomic<uint32>;
  type AtomicUint64 = Atomic<uint64>;
  type AtomicPtr<T> = Atomic<wild T*>;
  ```
  - [ ] Backend: Map to LLVM `atomicrmw` for standard types (efficient hardware paths)

#### 7.3.3 TBB Atomics (Special Handling)
- [ ] **Problem**: Hardware atomics can't enforce sticky error semantics (ERR must stick)
  - [ ] Example: `tbb8` at ERR (-128) + 1 = ERR (not -127)
  - [ ] Hardware LOCK XADD would produce -127 (wrong!)

- [ ] **Solution**: Compiler-Synthesized CAS Loops (`src/backend/codegen_tbb_atomic.cpp`)
  - [ ] `AtomicTBB<T>.fetch_add(delta)` implementation:
    1. Load current value (atomic load)
    2. **Loop**: Calculate new value using TBBLowerer logic (checks ERR, overflow)
    3. CAS: Try to swap old â†’ new (compare_exchange_weak)
    4. If CAS fails: Reload and retry (loop)
    5. If CAS succeeds: Return old value
  - [ ] Trade throughput for correctness (consistent with Aria's safety philosophy)

- [ ] **TBB Atomic Aliases**
  ```aria
  type AtomicTBB8 = Atomic<tbb8>;
  type AtomicTBB16 = Atomic<tbb16>;
  type AtomicTBB32 = Atomic<tbb32>;
  type AtomicTBB64 = Atomic<tbb64>;
  ```

#### 7.3.4 Lock-Free Patterns
- [ ] **Arc (Atomically Reference Counted)** (`stdlib/sync/arc.aria`)
  - [ ] `clone()`: `fetch_add(1, Ordering.Relaxed)` (no sync needed while holding ref)
  - [ ] `drop()`: `fetch_sub(1, Ordering.Release)`, if last ref: `fence(Ordering.Acquire)` then free
  - [ ] Integration with borrow checker (ensure data outlives Arc)

- [ ] **Treiber Stack** (lock-free stack example in docs)
  - [ ] Push: CAS loop to update head pointer
  - [ ] Pop: Requires epoch-based reclamation (EBR) or hazard pointers (complex!)
  - [ ] ABA problem mitigation: Tagged pointers (use AtomicUint128 or pack tag in low bits)

- [ ] **Lock-Free Queue** (MPSC or MPMC, if needed)
  - [ ] Options: Ring buffer (bounded), linked list (unbounded)

#### 7.3.5 Testing & Verification
- [ ] **ThreadSanitizer Integration** (`--sanitize=thread` compiler flag)
  - [ ] Instrument all atomic loads/stores (LLVM TSan support)
  - [ ] Detect data races (concurrent R/W or W/W without happens-before)

- [ ] **Stress Tests** (`tests/concurrency/atomics_stress.aria`)
  - [ ] Hammer test: 100 threads, each increment counter 1M times, verify sum = 100M
  - [ ] Ping-pong test: Two threads toggling flag, validate visibility
  - [ ] Arc stress: 1000 clones/drops in parallel, verify refcount correctness

- [ ] **Model Checking** (future work)
  - [ ] Integrate loom-style tool (permute thread schedules, exhaustive state space)

### 7.4 Timers & Clocks
**Status**: Design complete (research_009 âœ…), ready for implementation  
**Timeline**: 3 weeks (data structures, OS integration, async runtime)

#### 7.4.1 Core Data Structures (`src/runtime/time/`)
- [ ] **Hierarchical Timing Wheel** (timer_wheel.h/cpp)
  - [ ] 5-level hashed wheel (TV1-TV5): 256, 64, 64, 64, 64 slots
  - [ ] TimerEntry struct: expiry_nanos (tbb64), coro_handle, prev/next pointers
  - [ ] O(1) insert: Calculate level based on expiry delta, add to linked list
  - [ ] O(1) advance: Process current slot, cascade on wraparound
  - [ ] Per-worker wheels (zero lock contention)
  - [ ] Tests: Insert 10K timers, verify O(1) complexity

- [ ] **Platform Abstractions** (time_platform.h/cpp)
  - [ ] Linux: timerfd_create(CLOCK_MONOTONIC), epoll integration
  - [ ] Windows: CreateWaitableTimerEx(HIGH_RESOLUTION), IOCP integration  
  - [ ] macOS/BSD: kqueue EVFILT_TIMER(NOTE_NSECONDS)
  - [ ] VDSO optimization: Direct TSC/QPC reads (15ns latency)
  - [ ] Tests: Verify nanosecond precision on each platform

#### 7.4.2 Time Types (`stdlib/time.aria`)
- [ ] **Duration struct** (TBB64-based)
  - [ ] Field: tbb64:nanos (symmetric range Â±292 years)
  - [ ] Constants: NANOSECOND, MICROSECOND, MILLISECOND, SECOND, MINUTE, HOUR
  - [ ] Arithmetic: Add/Sub/Mul/Div with ERR propagation
  - [ ] Tests: Verify overflow â†’ ERR (not wrap or panic)

- [ ] **Instant struct** (monotonic time point)
  - [ ] Field: tbb64:ticks (opaque, relative to boot)
  - [ ] now() -> Instant: Read monotonic clock
  - [ ] Instant + Duration -> Instant, Instant - Instant -> Duration
  - [ ] Tests: Verify monotonic guarantee (t2 >= t1 always)

- [ ] **SystemTime struct** (wall-clock, UTC)
  - [ ] Field: tbb64:unix_nanos (since Unix epoch)
  - [ ] now() -> SystemTime: Read system clock
  - [ ] Warning: Never use for durations/timeouts
  - [ ] Tests: Verify distinct from Instant

#### 7.4.3 Async Timer API
- [ ] **sleep(Duration) -> Future<void>**
  - [ ] Insert timer into wheel, suspend coroutine
  - [ ] On expiry: Resume coroutine
  - [ ] Cancellation: Drop Future â†’ mark TimerEntry CANCELLED
  - [ ] Tests: sleep(1s), verify 1000-1010ms elapsed

- [ ] **timeout<T>(Duration, Future<T>) -> Result<T>**
  - [ ] Race operation against timer using pick (select)
  - [ ] Return ERR_TIMEOUT if timer wins
  - [ ] Tests: timeout(100ms, slow_op()) verifies timeout, timeout(10s, fast_op()) verifies success

- [ ] **Ticker struct** (periodic events)
  - [ ] every(Duration) -> Ticker: Create periodic timer
  - [ ] next() -> Future<Instant>: Wait for next tick
  - [ ] Tests: Ticker at 100ms, verify 10 ticks in ~1000ms

#### 7.4.4 Reactor Integration
- [ ] **Worker::run() modification** (src/runtime/concurrency/worker.cpp)
  - [ ] Calculate next_timer_expiry from wheel
  - [ ] Pass to epoll_wait/GetQueuedCompletionStatusEx as timeout
  - [ ] On wakeup: Call wheel.advance(now), resume expired coroutines
  - [ ] Tests: 1000 concurrent sleeps, verify all wake correctly

- [ ] **Thundering Herd Mitigation**
  - [ ] Timer coalescing: Align to 10ms boundaries (configurable)
  - [ ] Staggered wakeup: Feed work stealing scheduler gradually
  - [ ] Tests: 10K timers at same expiry, verify CPU doesn't thrash

---

## PHASE 8: Advanced Features
**Goal**: Implement remaining advanced language features  
**Dependencies**: Various phases complete  
**Timeline**: 4-5 weeks  
**Priority**: MEDIUM (nice to have, not blocking beta)

### 8.1 Trait System Completion

#### 8.1.1 Trait Implementation Improvements
- [ ] Review existing research: `/docs/research/trait_system_implementation.md`
- [ ] Enhance trait system (basic version exists)
  - [ ] **Trait resolution improvements**
    - [ ] Better error messages
    - [ ] Overlapping impl detection
    - [ ] Trait coherence checking
  - [ ] **Default methods in traits**
    - [ ] Parse default method implementations
    - [ ] Allow overriding in impls
    - [ ] CodeGen for default methods
  - [ ] **Associated types (if in spec)**
    - [ ] Check spec for associated type syntax
    - [ ] Implement if present
  - [ ] Add tests

#### 8.1.2 Trait Objects (Dynamic Dispatch)
- [ ] Implement trait objects for runtime polymorphism
  - [ ] VTable generation (expand existing vtable.cpp)
  - [ ] Fat pointer representation (trait object = data ptr + vtable ptr)
  - [ ] Dynamic dispatch codegen
  - [ ] Add tests

### 8.2 Safe Navigation Operator (?.) Completion

#### 8.2.1 Safe Navigation CodeGen
- [ ] Complete codegen for `?.` operator (stub exists)
  - [ ] Null check before member access
  - [ ] Short-circuit evaluation
  - [ ] Return null if any intermediate is null
  - [ ] Optimize generated code (avoid redundant checks)
- [ ] Add comprehensive tests
  - [ ] `obj?.field`
  - [ ] `obj?.method()`
  - [ ] `obj?.field?.nested`
  - [ ] Integration with null coalescing: `obj?.field ?? default`

### 8.3 Metaprogramming & Macros
**Status**: Design complete (research_010+011), ready for implementation
**Timeline**: 14 weeks (per research roadmap)

#### 8.3.1 Phase 1: Macro Preprocessor Infrastructure (Weeks 1-3)
- [ ] Extend Preprocessor class with context stack
  - [ ] Implement %push/%pop/%repl directives
  - [ ] Add MacroContext struct (name + symbol table)
  - [ ] Context-local label support (%$label â†’ __ctx_ID_label)
  - [ ] %ifctx conditional compilation
- [ ] Token stream manipulation
  - [ ] %rotate directive for argument rotation
  - [ ] Recursive macro expansion with depth limits
  - [ ] Multi-line block capture (%body directive)
- [ ] Verification: Unit tests for nested macros, label uniqueness

#### 8.3.2 Phase 2: CTFE Interpreter Core (Weeks 4-6)
- [ ] Scaffold ComptimeInterpreter class
  - [ ] ComptimeValue variant (int/float/string/type/error)
  - [ ] Virtual Environment (stack of symbol tables)
  - [ ] Evaluator (recursive AST visitor)
- [ ] TBB-Aware Arithmetic
  - [ ] Software ALU for TBB addition/subtraction/multiplication
  - [ ] Sticky error propagation (ERR + X â†’ ERR)
  - [ ] Overflow detection for symmetric ranges
  - [ ] Sentinel collision detection
- [ ] Exotic type support
  - [ ] Ternary (trit/tryte) unpacking/logic/repacking
  - [ ] Nonary (nit/nyte) unpacking/logic/repacking
- [ ] Integrate CTFE hook into TypeChecker
- [ ] Verification: TBB constant folding tests

#### 8.3.3 Phase 3: Reflection & Mixins (Weeks 7-8)
- [ ] Type reflection system
  - [ ] Implement @typeInfo(T) intrinsic
  - [ ] Return struct with: fields, size, alignment, is_wild, is_sendable
  - [ ] Support for TBB/ternary/nonary type queries
- [ ] Mixin operator
  - [ ] @mixin(string) feeds code back to Parser
  - [ ] Source map generation for error tracking
  - [ ] AST node provenance annotation
- [ ] Virtual Heap for compile-time allocations
  - [ ] Handle-based memory (not real pointers)
  - [ ] Track wild vs gc allocations
  - [ ] Simulate pointer arithmetic safely
- [ ] Verification: Implement json_serialize<T> generic

#### 8.3.4 Phase 4: High-Level Macro Library (Weeks 9-10)
- [ ] Control flow macros
  - [ ] IF/ELIF/ELSE/ENDIF with context validation
  - [ ] WHILE/ENDWHILE with BREAK/CONTINUE label generation
  - [ ] FOR macro with iteration tracking
- [ ] Data structure templates
  - [ ] Vector<T> adapting to wild vs gc memory
  - [ ] HashMap<K,V> with memory model awareness
  - [ ] Optional<T> and Result<T,E> types
- [ ] Concurrency macros
  - [ ] ACTOR(name) { STATE/MESSAGE } expansion
  - [ ] SPAWN safety checks (@typeInfo(T).is_sendable)
- [ ] Standard library port to use new system

#### 8.3.5 Phase 5: Integration & Testing (Weeks 11-14)
- [ ] Borrow checker integration
  - [ ] Validate # pinning in macro output
  - [ ] Verify $ safe reference usage
- [ ] Threading integration
  - [ ] Actor mailbox generation
  - [ ] Message dispatch switch cases
- [ ] Wildx JIT support
  - [ ] Runtime assembler macros for x86-64 code emission
  - [ ] W^X enforcement in generated code
- [ ] Comprehensive test suite
  - [ ] Macro hygiene tests (label collision prevention)
  - [ ] TBB compile-time arithmetic correctness
  - [ ] Generic specialization tests
  - [ ] Error message provenance verification

### 8.5 Wildx Executable Memory

#### 8.5.1 Wildx Improvements
- [ ] Review existing research: `/docs/research/wildx_memory_regions.md`
- [ ] Enhance wildx support (basic version exists)
  - [ ] W^X enforcement (write XOR execute)
  - [ ] Runtime code generation API
  - [ ] JIT compilation support
  - [ ] Code cache management
- [ ] Add tests

### 8.6 Runtime Assembler (if in spec)

#### 8.6.1 Check Spec for Runtime Assembler
- [ ] Determine if runtime assembler is in spec
- [ ] If yes, implement:
  - [ ] Assembly parsing at runtime
  - [ ] Code generation to wildx memory
  - [ ] Register allocation
  - [ ] Add tests

### 8.7 Enhanced Diagnostics

#### 8.7.1 Error Message Improvements
- [ ] Review existing research: `/docs/research/diagnostic_system_improvements.md`
- [ ] Improve error messages throughout compiler
  - [ ] Add source location highlighting
  - [ ] Add suggestions for common mistakes
  - [ ] Add "did you mean?" for typos
  - [ ] Colorize output (when TTY)
- [ ] Add warning system
  - [ ] Unused variables
  - [ ] Unreachable code
  - [ ] Implicit conversions
  - [ ] Deprecation warnings

### 8.8 Struct Methods Completion

#### 8.8.1 Method Implementation
- [ ] Review existing research: `/docs/research/struct_methods_implementation.md`
- [ ] Complete struct methods (basic version exists)
  - [ ] Parse method syntax
  - [ ] Type check methods
  - [ ] CodeGen for methods (implicit self parameter)
  - [ ] Method chaining support
- [ ] Add tests

---

## PHASE 9: Optimization & Polish
**Goal**: Optimize compiler and generated code  
**Dependencies**: All core features complete  
**Timeline**: 2-3 weeks  
**Priority**: MEDIUM (performance improvements)

### 9.1 Compiler Optimizations

#### 9.1.1 Compilation Speed
- [ ] Profile compiler to find bottlenecks
- [ ] Optimize hot paths
  - [ ] Lexer optimizations
  - [ ] Parser optimizations
  - [ ] Type checker caching
- [ ] Parallel compilation (if not already)
- [ ] Incremental compilation support
- [ ] Add benchmarks

#### 9.1.2 Memory Usage
- [ ] Reduce compiler memory footprint
  - [ ] AST node pooling
  - [ ] String interning
  - [ ] Symbol table optimizations
- [ ] Add memory profiling

### 9.2 Generated Code Optimizations

#### 9.2.1 LLVM Optimization Passes
- [ ] Enable aggressive LLVM optimizations
  - [ ] Inlining
  - [ ] Dead code elimination
  - [ ] Constant propagation
  - [ ] Loop optimizations
  - [ ] Vectorization
- [ ] Profile-guided optimization (PGO) support
- [ ] Link-time optimization (LTO) support

#### 9.2.2 Aria-Specific Optimizations
- [ ] Review existing research:
  - [ ] TBB optimization (`tbb_optimizer.cpp` exists)
  - [ ] Loop optimization (`tbb_loop_optimizer.cpp` exists)
  - [ ] Interprocedural optimization (`tbb_interprocedural.cpp` exists)
- [ ] Enhance existing optimizations
- [ ] Add new optimizations
  - [ ] GC allocation elision
  - [ ] Escape analysis optimizations
  - [ ] Devirtualization (trait dispatch)
- [ ] Add benchmarks

### 9.3 GC Improvements

#### 9.3.1 Generational GC Enhancement
- [ ] Review existing research: `/docs/research/gc_nursery_implementation.md`
- [ ] Complete generational GC (nursery exists)
  - [ ] Implement generation 2 (tenured space)
  - [ ] Implement promotion logic
  - [ ] Add write barriers
  - [ ] Tune GC parameters
- [ ] Add GC profiling tools
- [ ] Add benchmarks

### 9.4 Binary Size Reduction

#### 9.4.1 Size Optimizations
- [ ] Strip unnecessary symbols
- [ ] Remove dead code at link time
- [ ] Compress static data
- [ ] Add size benchmarks

---

## PHASE 10: Testing & Validation
**Goal**: Comprehensive testing for production readiness  
**Dependencies**: All features implemented  
**Timeline**: 4-5 weeks  
**Priority**: CRITICAL (must have for beta)

### 10.1 Unit Test Expansion

#### 10.1.1 Expand Test Coverage
- [ ] Achieve >90% code coverage
  - [ ] Add tests for all lexer tokens
  - [ ] Add tests for all parser rules
  - [ ] Add tests for all type checker rules
  - [ ] Add tests for all codegen paths
- [ ] Add edge case tests
- [ ] Add error condition tests
- [ ] Generate coverage reports

### 10.2 Integration Tests

#### 10.2.1 End-to-End Test Suite
- [ ] Create comprehensive integration tests
  - [ ] Test all language features together
  - [ ] Test all stdlib functions
  - [ ] Test module system
  - [ ] Test async/concurrency
  - [ ] Test interop with C libraries
- [ ] Create realistic example programs
  - [ ] Web server
  - [ ] File processor
  - [ ] Data analyzer
  - [ ] Game engine
- [ ] Run integration tests on all platforms

### 10.3 Performance Benchmarks

#### 10.3.1 Benchmark Suite
- [ ] Create performance benchmarks
  - [ ] Compilation speed
  - [ ] Runtime performance
  - [ ] Memory usage
  - [ ] GC performance
- [ ] Compare with other languages
  - [ ] Rust, Go, C, C++, Zig
- [ ] Identify performance bottlenecks
- [ ] Optimize hot paths
- [ ] Document performance characteristics

### 10.4 Fuzzing & Stress Testing

#### 10.4.1 Fuzzing Infrastructure
- [ ] Set up fuzzing for:
  - [ ] Lexer (random source input)
  - [ ] Parser (malformed programs)
  - [ ] Type checker (type errors)
  - [ ] CodeGen (edge cases)
- [ ] Run fuzzing continuously
- [ ] Fix all crashes and hangs
- [ ] Add regression tests for found bugs

#### 10.4.2 Stress Testing
- [ ] Large codebase compilation
- [ ] Deep recursion tests
- [ ] Memory stress tests
- [ ] Concurrency stress tests
- [ ] Long-running program tests

### 10.5 Cross-Platform Testing

#### 10.5.1 Platform Validation
- [ ] Test on all target platforms
  - [ ] Linux (x86_64, ARM64)
  - [ ] Windows (x86_64)
  - [ ] macOS (x86_64, ARM64)
- [ ] Test on different architectures
- [ ] Test with different LLVM versions
- [ ] Fix platform-specific bugs

### 10.6 Security Audit

#### 10.6.1 Security Review
- [ ] Review for security vulnerabilities
  - [ ] Buffer overflows
  - [ ] Use-after-free
  - [ ] Race conditions
  - [ ] Integer overflows
- [ ] Static analysis tools
- [ ] Third-party security audit (if budget allows)
- [ ] Fix all security issues

---

## PHASE 11: Documentation & Release
**Goal**: Complete documentation and prepare beta release  
**Dependencies**: All features complete and tested  
**Timeline**: 2-3 weeks  
**Priority**: CRITICAL (required for beta release)

### 11.1 Language Documentation

#### 11.1.1 Language Reference Manual
- [ ] Write comprehensive language reference
  - [ ] Type system
  - [ ] Operators
  - [ ] Control flow
  - [ ] Functions and closures
  - [ ] Structs and traits
  - [ ] Generics
  - [ ] Module system
  - [ ] Async/await
  - [ ] Memory management
- [ ] Include examples for every feature
- [ ] Add cross-references
- [ ] Generate HTML/PDF versions

#### 11.1.2 Standard Library Documentation
- [ ] Document all stdlib modules
  - [ ] Function signatures
  - [ ] Parameter descriptions
  - [ ] Return values
  - [ ] Error conditions
  - [ ] Usage examples
- [ ] Generate API documentation (auto-doc tool?)

### 11.2 Tutorials & Guides

#### 11.2.1 Getting Started Guide
- [ ] Write installation guide
- [ ] Write "Hello World" tutorial
- [ ] Write basic language tutorial
  - [ ] Variables and types
  - [ ] Control flow
  - [ ] Functions
  - [ ] Modules
- [ ] Add exercises

#### 11.2.2 Advanced Guides
- [ ] Write advanced topics guides
  - [ ] Async programming
  - [ ] Concurrency
  - [ ] Memory management strategies
  - [ ] Performance optimization
  - [ ] Interfacing with C
  - [ ] Metaprogramming
- [ ] Add real-world examples

### 11.3 Migration & Comparison Guides

#### 11.3.1 For Developers Coming From...
- [ ] Rust migration guide
- [ ] Go migration guide
- [ ] C++ migration guide
- [ ] JavaScript/TypeScript migration guide

#### 11.3.2 Language Comparison
- [ ] Create comparison matrix
  - [ ] Aria vs Rust
  - [ ] Aria vs Go
  - [ ] Aria vs Zig
  - [ ] Aria vs C++
- [ ] Highlight unique features
- [ ] Explain design decisions

### 11.4 Tooling Documentation

#### 11.4.1 Compiler Documentation
- [ ] Document compiler flags
- [ ] Document build system integration
- [ ] Document IDE integration (if any)
- [ ] Document debugging tools

### 11.5 Release Preparation

#### 11.5.1 Beta Release Checklist
- [ ] All CRITICAL and HIGH priority features complete
- [ ] All tests passing
- [ ] Documentation complete
- [ ] Known issues documented
- [ ] Release notes written
- [ ] Version number finalized
- [ ] Build artifacts generated
  - [ ] Linux binaries
  - [ ] Windows binaries
  - [ ] macOS binaries
  - [ ] Source tarball
- [ ] Package for distribution
  - [ ] .deb package (Linux)
  - [ ] .rpm package (Linux)
  - [ ] .msi installer (Windows)
  - [ ] Homebrew formula (macOS)
- [ ] Update website
- [ ] Prepare announcement

#### 11.5.2 Beta Release
- [ ] Tag repository: `v0.1.0-beta.1`
- [ ] Create GitHub release
- [ ] Upload binaries
- [ ] Announce on:
  - [ ] Project website
  - [ ] Social media
  - [ ] Mailing lists
  - [ ] Reddit (/r/ProgrammingLanguages)
  - [ ] Hacker News
  - [ ] Lobsters
- [ ] Invite beta testers
- [ ] Set up issue tracker for feedback
- [ ] Prepare for alpha release (after beta testing)

---

## TRACKING & PROGRESS

### Current Status (December 11, 2025)
- **Phase 0**: 0% (research system ready, not started)
- **Phase 1**: 45% (types mostly done, TBB/exotic types pending)
- **Phase 2**: 10% (stubs exist, needs research_001)
- **Phase 3**: 20% (parsing done, visibility/resolution pending)
- **Phase 4**: 15% (parsing done, monomorphization pending)
- **Phase 5**: 5% (some functions exist)
- **Phase 6**: 0% (not started)
- **Phase 7**: 20% (async exists, threading/atomics pending)
- **Phase 8**: 30% (traits exist, other features partial)
- **Phase 9**: 5% (some optimizations exist)
- **Phase 10**: 10% (basic tests exist)
- **Phase 11**: 5% (README exists)

### Estimated Timeline
- **Optimistic**: 6 months (with parallel work, aggressive schedule)
- **Realistic**: 9-10 months (with research integration, testing)
- **Conservative**: 12 months (with thorough testing, polish)

### Parallel Tracks Possible
1. **Research Track**: Run Gemini research tasks in background
2. **Implementation Track**: Implement features with existing research
3. **Testing Track**: Write tests as features are implemented
4. **Documentation Track**: Document features as they stabilize

### Critical Path
Phase 0 â†’ Phase 1 â†’ Phase 2 â†’ Phase 4 â†’ Phase 6 â†’ Phase 10 â†’ Phase 11

Phases 3, 5, 7, 8, 9 can run in parallel once dependencies are met.

---

**Last Updated**: December 11, 2025  
**Next Review**: After research_001, research_002, research_003 complete
