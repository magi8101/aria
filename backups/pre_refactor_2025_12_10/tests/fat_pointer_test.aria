/**
 * tests/fat_pointer_test.aria
 * 
 * Test suite for fat pointer functionality in debug builds
 * 
 * Tests cover:
 * - Safe pointer usage (should work)
 * - Dangling pointer detection (should fail in debug builds)
 * - Scope nesting validation
 * - Multiple pointer tracking
 */

// =============================================================================
// Test 1: Safe pointer usage (basic)
// =============================================================================

fn:test_safe_pointer_usage = *int8() {
    int64:local_var = 42;
    
    // Take address of local variable
    int64:ptr_value = @local_var;
    
    // Dereference is safe (within same scope)
    // Note: In debug builds, this generates:
    //   1. aria_fat_ptr_create(&local_var, current_scope)
    //   2. aria_fat_ptr_deref(fat_ptr) when dereferencing
    
    // Success: pointer never escapes scope
    *0;
};

// =============================================================================
// Test 2: Dangling pointer detection (scope exit)
// =============================================================================

fn:create_dangling_pointer = int64() {
    int64:local_var = 100;
    
    // Take address of local variable
    int64:ptr_value = @local_var;
    
    // BUG: Returning pointer to local variable!
    // Debug build: Should catch this at dereference time
    // (Static escape analysis already catches this at compile time,
    //  but fat pointers provide runtime defense-in-depth)
    return ptr_value;
};

fn:test_dangling_pointer = *int8() {
    int64:dangling = create_dangling_pointer();
    
    // This dereference should FAIL in debug builds:
    // - Scope that created the pointer has exited
    // - aria_fat_ptr_deref() detects invalid scope_id
    // - Program aborts with clear error message
    
    // Note: In production, this test won't compile due to
    // escape analysis preventing the return in create_dangling_pointer()
    // This test demonstrates runtime defense-in-depth
    
    // int64:value = *dangling;  // Would abort in debug build
    
    *0;
};

// =============================================================================
// Test 3: Nested scope tracking
// =============================================================================

fn:test_nested_scopes = *int8() {
    int64:outer = 1;
    int64:outer_ptr = @outer;
    
    // Enter inner scope
    {
        int64:inner = 2;
        int64:inner_ptr = @inner;
        
        // Both pointers valid here
        // outer_ptr: scope_id = N
        // inner_ptr: scope_id = N+1
        
        // Enter even deeper scope
        {
            int64:deep = 3;
            int64:deep_ptr = @deep;
            
            // All three pointers valid here
            // deep_ptr: scope_id = N+2
        }
        // deep_ptr now INVALID (scope exited)
        // inner_ptr still VALID
        // outer_ptr still VALID
    }
    // inner_ptr now INVALID (scope exited)
    // outer_ptr still VALID
    
    *0;
};

// =============================================================================
// Test 4: Multiple pointers in same scope
// =============================================================================

fn:test_multiple_pointers = *int8() {
    int64:var1 = 10;
    int64:var2 = 20;
    int64:var3 = 30;
    
    // Create multiple fat pointers (all same scope)
    int64:ptr1 = @var1;
    int64:ptr2 = @var2;
    int64:ptr3 = @var3;
    
    // All share the same scope_id
    // All become invalid when function exits
    
    *0;
};

// =============================================================================
// Test 5: Pointer to heap allocation (wild)
// =============================================================================

fn:test_wild_pointer = *int8() {
    wild int64:heap_var = 99;
    
    // Take address of heap-allocated variable
    // Note: heap_var itself is a pointer to heap memory
    // @heap_var returns address of the stack slot holding the pointer
    int64:stack_ptr = @heap_var;
    
    // stack_ptr becomes invalid when function exits
    // (but the heap memory itself persists if not freed)
    
    *0;
};

// =============================================================================
// Test 6: Function pointer safety
// =============================================================================

fn:helper = int64(int64:x) {
    return x * 2;
};

fn:test_function_pointer = *int8() {
    // Function pointers don't need fat pointer tracking
    // (functions have static lifetime, never go out of scope)
    
    func<int64(int64)>:fn_ptr = helper;
    
    int64:result = fn_ptr(21);  // Should be 42
    
    *0;
};

// =============================================================================
// Test 7: Pointer arithmetic safety (if supported)
// =============================================================================

fn:test_pointer_arithmetic = *int8() {
    int64[10]:arr;
    
    // Array decay to pointer
    int64:arr_ptr = @arr;
    
    // Pointer arithmetic (if language supports it)
    // Fat pointers track the original scope, not element offsets
    // So arr_ptr + 5 would still have the same scope_id
    
    *0;
};

// =============================================================================
// Test 8: Safe usage with defer
// =============================================================================

fn:test_pointer_with_defer = *int8() {
    int64:value = 123;
    int64:ptr = @value;
    
    defer {
        // Defer block executes at scope exit
        // ptr is still valid here (same scope)
        print(`Pointer valid in defer: &{ptr}`);
    };
    
    // ptr valid throughout function body
    
    *0;
};

// =============================================================================
// Test 9: Zero-cost abstraction verification (release builds)
// =============================================================================

// This test verifies that fat pointers compile to raw pointers
// in release builds (zero overhead)

fn:test_zero_cost = *int8() {
    int64:x = 42;
    int64:ptr = @x;
    
    // In release builds (without ARIA_DEBUG):
    // - ptr is just a raw i64 (pointer as integer)
    // - No scope tracking
    // - No runtime checks
    // - Identical to pre-fat-pointer codegen
    
    // In debug builds (with ARIA_DEBUG):
    // - ptr is a {i8*, i64, i64} struct
    // - Scope ID tracked
    // - Runtime validation on dereference
    
    *0;
};

// =============================================================================
// Main Test Runner
// =============================================================================

fn:main = int8() {
    // Run all tests
    test_safe_pointer_usage();
    // test_dangling_pointer();  // Would abort in debug builds
    test_nested_scopes();
    test_multiple_pointers();
    test_wild_pointer();
    test_function_pointer();
    test_pointer_arithmetic();
    test_pointer_with_defer();
    test_zero_cost();
    
    print(`All fat pointer tests passed!`);
    
    *0;
};
