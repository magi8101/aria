; ModuleID = 'aria_module'
source_filename = "aria_module"

%result_uint8 = type { i8, i8 }
%result_int64 = type { i8, i64 }
%result_int8 = type { i8, i8 }

@RAX = internal global i8 0
@RCX = internal global i8 1
@RDX = internal global i8 2
@RBX = internal global i8 3
@RSP = internal global i8 4
@RBP = internal global i8 5
@RSI = internal global i8 6
@RDI = internal global i8 7
@R8 = internal global i8 8
@R9 = internal global i8 9
@R10 = internal global i8 10
@R11 = internal global i8 11
@R12 = internal global i8 12
@R13 = internal global i8 13
@R14 = internal global i8 14
@R15 = internal global i8 15
@0 = private unnamed_addr constant [41 x i8] c"========================================\00", align 1
@1 = private unnamed_addr constant [39 x i8] c"   Aria Runtime Assembler - FINAL     \00", align 1
@2 = private unnamed_addr constant [41 x i8] c"========================================\00", align 1
@3 = private unnamed_addr constant [25 x i8] c"Generating: MOV RDX, RDI\00", align 1
@4 = private unnamed_addr constant [25 x i8] c"Generating: MOV RAX, RDX\00", align 1
@5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@6 = private unnamed_addr constant [47 x i8] c"Successfully generated 6 bytes of x86-64 code!\00", align 1
@7 = private unnamed_addr constant [41 x i8] c"========================================\00", align 1

declare void @puts(ptr)

declare void @print(ptr)

define internal void @__aria_module_init() {
entry:
  ret void
}

define internal %result_uint8 @calc_rex(i8 %w, i8 %r, i8 %x, i8 %b) {
entry:
  %rex = alloca i8, align 1
  %w1 = alloca i8, align 1
  store i8 %w, ptr %w1, align 1
  %r2 = alloca i8, align 1
  store i8 %r, ptr %r2, align 1
  %x3 = alloca i8, align 1
  store i8 %x, ptr %x3, align 1
  %b4 = alloca i8, align 1
  store i8 %b, ptr %b4, align 1
  store i8 64, ptr %rex, align 1
  %0 = load i64, ptr %w1, align 4
  %netmp = icmp ne i64 %0, 0
  br i1 %netmp, label %then, label %ifcont

then:                                             ; preds = %entry
  %1 = load i8, ptr %rex, align 1
  %2 = sext i8 %1 to i64
  br label %ifcont

ifcont:                                           ; preds = %then, %entry
  %3 = load i64, ptr %r2, align 4
  %netmp5 = icmp ne i64 %3, 0
  br i1 %netmp5, label %then6, label %ifcont7

then6:                                            ; preds = %ifcont
  %4 = load i8, ptr %rex, align 1
  %5 = sext i8 %4 to i64
  br label %ifcont7

ifcont7:                                          ; preds = %then6, %ifcont
  %6 = load i64, ptr %x3, align 4
  %netmp8 = icmp ne i64 %6, 0
  br i1 %netmp8, label %then9, label %ifcont10

then9:                                            ; preds = %ifcont7
  %7 = load i8, ptr %rex, align 1
  %8 = sext i8 %7 to i64
  br label %ifcont10

ifcont10:                                         ; preds = %then9, %ifcont7
  %9 = load i64, ptr %b4, align 4
  %netmp11 = icmp ne i64 %9, 0
  br i1 %netmp11, label %then12, label %ifcont13

then12:                                           ; preds = %ifcont10
  %10 = load i8, ptr %rex, align 1
  %11 = sext i8 %10 to i64
  br label %ifcont13

ifcont13:                                         ; preds = %then12, %ifcont10
  %12 = load i8, ptr %rex, align 1
  %result = alloca %result_uint8, align 8
  %err_ptr = getelementptr inbounds %result_uint8, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr = getelementptr inbounds %result_uint8, ptr %result, i32 0, i32 1
  store i8 %12, ptr %val_ptr, align 1
  %result_val = load %result_uint8, ptr %result, align 1
  ret %result_uint8 %result_val
}

define internal %result_uint8 @calc_modrm(i8 %modval, i8 %regval, i8 %rmval) {
entry:
  %rm_bits = alloca i8, align 1
  %reg_shifted = alloca i8, align 1
  %reg_bits = alloca i8, align 1
  %mod_bits = alloca i8, align 1
  %rm_u8 = alloca i8, align 1
  %reg_u8 = alloca i8, align 1
  %mod_u8 = alloca i8, align 1
  %output = alloca i8, align 1
  %modval1 = alloca i8, align 1
  store i8 %modval, ptr %modval1, align 1
  %regval2 = alloca i8, align 1
  store i8 %regval, ptr %regval2, align 1
  %rmval3 = alloca i8, align 1
  store i8 %rmval, ptr %rmval3, align 1
  store i8 0, ptr %output, align 1
  %0 = load i64, ptr %modval1, align 4
  %cast = trunc i64 %0 to i8
  store i8 %cast, ptr %mod_u8, align 1
  %1 = load i64, ptr %regval2, align 4
  %cast4 = trunc i64 %1 to i8
  store i8 %cast4, ptr %reg_u8, align 1
  %2 = load i64, ptr %rmval3, align 4
  %cast5 = trunc i64 %2 to i8
  store i8 %cast5, ptr %rm_u8, align 1
  %3 = load i8, ptr %mod_u8, align 1
  %4 = sext i8 %3 to i64
  %bandtmp = and i64 %4, 3
  %5 = trunc i64 %bandtmp to i8
  store i8 %5, ptr %mod_bits, align 1
  %6 = load i8, ptr %mod_bits, align 1
  %7 = sext i8 %6 to i64
  %shltmp = shl i64 %7, 6
  %8 = trunc i64 %shltmp to i8
  store i8 %8, ptr %output, align 1
  %9 = load i8, ptr %reg_u8, align 1
  %10 = sext i8 %9 to i64
  %bandtmp6 = and i64 %10, 7
  %11 = trunc i64 %bandtmp6 to i8
  store i8 %11, ptr %reg_bits, align 1
  %12 = load i8, ptr %reg_bits, align 1
  %13 = sext i8 %12 to i64
  %shltmp7 = shl i64 %13, 3
  %14 = trunc i64 %shltmp7 to i8
  store i8 %14, ptr %reg_shifted, align 1
  %15 = load i8, ptr %output, align 1
  %16 = load i8, ptr %reg_shifted, align 1
  %17 = load i8, ptr %rm_u8, align 1
  %18 = sext i8 %17 to i64
  %bandtmp8 = and i64 %18, 7
  %19 = trunc i64 %bandtmp8 to i8
  store i8 %19, ptr %rm_bits, align 1
  %20 = load i8, ptr %output, align 1
  %21 = load i8, ptr %rm_bits, align 1
  %22 = load i8, ptr %output, align 1
  %result = alloca %result_uint8, align 8
  %err_ptr = getelementptr inbounds %result_uint8, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr = getelementptr inbounds %result_uint8, ptr %result, i32 0, i32 1
  store i8 %22, ptr %val_ptr, align 1
  %result_val = load %result_uint8, ptr %result, align 1
  ret %result_uint8 %result_val
}

define internal %result_int64 @emit_mov(ptr %buf, i64 %pos, i8 %dst, i8 %src) {
entry:
  %modrm = alloca i8, align 1
  %modrm_result = alloca %result_int64, align 8
  %dst_lower = alloca i8, align 1
  %src_lower = alloca i8, align 1
  %rex = alloca i8, align 1
  %rex_result = alloca %result_int64, align 8
  %b_ext = alloca i8, align 1
  %dst_shifted = alloca i8, align 1
  %r_ext = alloca i8, align 1
  %src_shifted = alloca i8, align 1
  %w = alloca i8, align 1
  %buf1 = alloca ptr, align 8
  store ptr %buf, ptr %buf1, align 8
  %pos2 = alloca i64, align 8
  store i64 %pos, ptr %pos2, align 4
  %dst3 = alloca i8, align 1
  store i8 %dst, ptr %dst3, align 1
  %src4 = alloca i8, align 1
  store i8 %src, ptr %src4, align 1
  store i8 1, ptr %w, align 1
  %0 = load i64, ptr %src4, align 4
  %ashrtmp = ashr i64 %0, 3
  %1 = trunc i64 %ashrtmp to i8
  store i8 %1, ptr %src_shifted, align 1
  %2 = load i8, ptr %src_shifted, align 1
  %3 = sext i8 %2 to i64
  %bandtmp = and i64 %3, 1
  %4 = trunc i64 %bandtmp to i8
  store i8 %4, ptr %r_ext, align 1
  %5 = load i64, ptr %dst3, align 4
  %ashrtmp5 = ashr i64 %5, 3
  %6 = trunc i64 %ashrtmp5 to i8
  store i8 %6, ptr %dst_shifted, align 1
  %7 = load i8, ptr %dst_shifted, align 1
  %8 = sext i8 %7 to i64
  %bandtmp6 = and i64 %8, 1
  %9 = trunc i64 %bandtmp6 to i8
  store i8 %9, ptr %b_ext, align 1
  %10 = load i8, ptr %w, align 1
  %11 = load i8, ptr %r_ext, align 1
  %12 = load i8, ptr %b_ext, align 1
  %calltmp = call %result_uint8 @calc_rex(i8 %10, i8 %11, i8 0, i8 %12)
  store %result_uint8 %calltmp, ptr %rex_result, align 1
  %13 = load %result_int64, ptr %rex_result, align 4
  %temp = alloca %result_int64, align 8
  store %result_int64 %13, ptr %temp, align 4
  %val_ptr = getelementptr inbounds %result_int64, ptr %temp, i32 0, i32 1
  %val = load i64, ptr %val_ptr, align 4
  %cast = trunc i64 %val to i8
  store i8 %cast, ptr %rex, align 1
  %14 = load i64, ptr %src4, align 4
  %bandtmp7 = and i64 %14, 7
  %15 = trunc i64 %bandtmp7 to i8
  store i8 %15, ptr %src_lower, align 1
  %16 = load i64, ptr %dst3, align 4
  %bandtmp8 = and i64 %16, 7
  %17 = trunc i64 %bandtmp8 to i8
  store i8 %17, ptr %dst_lower, align 1
  %18 = load i8, ptr %src_lower, align 1
  %19 = load i8, ptr %dst_lower, align 1
  %calltmp9 = call %result_uint8 @calc_modrm(i8 3, i8 %18, i8 %19)
  store %result_uint8 %calltmp9, ptr %modrm_result, align 1
  %20 = load %result_int64, ptr %modrm_result, align 4
  %temp10 = alloca %result_int64, align 8
  store %result_int64 %20, ptr %temp10, align 4
  %val_ptr11 = getelementptr inbounds %result_int64, ptr %temp10, i32 0, i32 1
  %val12 = load i64, ptr %val_ptr11, align 4
  %cast13 = trunc i64 %val12 to i8
  store i8 %cast13, ptr %modrm, align 1
  %buf_ptr = load ptr, ptr %buf1, align 8
  %21 = load i64, ptr %pos2, align 4
  %22 = load i8, ptr %rex, align 1
  %elem_ptr = getelementptr i8, ptr %buf_ptr, i64 %21
  store i8 %22, ptr %elem_ptr, align 1
  %buf_ptr14 = load ptr, ptr %buf1, align 8
  %23 = load i64, ptr %pos2, align 4
  %addtmp = add i64 %23, 1
  %elem_ptr15 = getelementptr i8, ptr %buf_ptr14, i64 %addtmp
  store i8 -119, ptr %elem_ptr15, align 1
  %buf_ptr16 = load ptr, ptr %buf1, align 8
  %24 = load i64, ptr %pos2, align 4
  %addtmp17 = add i64 %24, 2
  %25 = load i8, ptr %modrm, align 1
  %elem_ptr18 = getelementptr i8, ptr %buf_ptr16, i64 %addtmp17
  store i8 %25, ptr %elem_ptr18, align 1
  %26 = load i64, ptr %pos2, align 4
  %addtmp19 = add i64 %26, 3
  %result = alloca %result_int64, align 8
  %err_ptr = getelementptr inbounds %result_int64, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr20 = getelementptr inbounds %result_int64, ptr %result, i32 0, i32 1
  store i64 %addtmp19, ptr %val_ptr20, align 4
  %result_val = load %result_int64, ptr %result, align 4
  ret %result_int64 %result_val
}

define internal %result_int8 @__user_main() {
entry:
  %r2 = alloca %result_int64, align 8
  %r1 = alloca %result_int64, align 8
  %pos = alloca i64, align 8
  %code = alloca ptr, align 8
  call void @puts(ptr @0)
  call void @puts(ptr @1)
  call void @puts(ptr @2)
  store i64 0, ptr %code, align 4
  store i64 0, ptr %pos, align 4
  call void @puts(ptr @3)
  %0 = load ptr, ptr %code, align 8
  %1 = load i64, ptr %pos, align 4
  %2 = load i64, ptr @RDX, align 4
  %3 = trunc i64 %2 to i8
  %4 = load i64, ptr @RDI, align 4
  %5 = trunc i64 %4 to i8
  %calltmp = call %result_int64 @emit_mov(ptr %0, i64 %1, i8 %3, i8 %5)
  store %result_int64 %calltmp, ptr %r1, align 4
  %6 = load %result_int64, ptr %r1, align 4
  %temp = alloca %result_int64, align 8
  store %result_int64 %6, ptr %temp, align 4
  %val_ptr = getelementptr inbounds %result_int64, ptr %temp, i32 0, i32 1
  %val = load i64, ptr %val_ptr, align 4
  store i64 %val, ptr %pos, align 4
  call void @puts(ptr @4)
  %7 = load ptr, ptr %code, align 8
  %8 = load i64, ptr %pos, align 4
  %9 = load i64, ptr @RAX, align 4
  %10 = trunc i64 %9 to i8
  %11 = load i64, ptr @RDX, align 4
  %12 = trunc i64 %11 to i8
  %calltmp1 = call %result_int64 @emit_mov(ptr %7, i64 %8, i8 %10, i8 %12)
  store %result_int64 %calltmp1, ptr %r2, align 4
  %13 = load %result_int64, ptr %r2, align 4
  %temp2 = alloca %result_int64, align 8
  store %result_int64 %13, ptr %temp2, align 4
  %val_ptr3 = getelementptr inbounds %result_int64, ptr %temp2, i32 0, i32 1
  %val4 = load i64, ptr %val_ptr3, align 4
  store i64 %val4, ptr %pos, align 4
  call void @puts(ptr @5)
  call void @puts(ptr @6)
  call void @puts(ptr @7)
  %result = alloca %result_int8, align 8
  %err_ptr = getelementptr inbounds %result_int8, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr5 = getelementptr inbounds %result_int8, ptr %result, i32 0, i32 1
  store i8 0, ptr %val_ptr5, align 1
  %result_val = load %result_int8, ptr %result, align 1
  ret %result_int8 %result_val
}

define i64 @main() {
entry:
  call void @__aria_module_init()
  %0 = call %result_int8 @__user_main()
  ret i64 0
}
