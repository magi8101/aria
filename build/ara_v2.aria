// Aria Runtime Assembler (ARA) - Working Implementation
// x86-64 machine code generation (simplified without struct returns)

// Register constants
int8:RAX = 0;
int8:RCX = 1;
int8:RDX = 2;
int8:RBX = 3;
int8:RSP = 4;
int8:RBP = 5;
int8:RSI = 6;
int8:RDI = 7;
int8:R8  = 8;
int8:R9  = 9;
int8:R10 = 10;
int8:R11 = 11;
int8:R12 = 12;
int8:R13 = 13;
int8:R14 = 14;
int8:R15 = 15;

// ============================================================================
// REX Prefix Calculation  
// ============================================================================
func:calc_rex = uint8(int8:w, int8:r, int8:x, int8:b) {
    uint8:rex = 0x40;
    
    if (w != 0) {
        rex |= 0x08;
    }
    if (r != 0) {
        rex |= 0x04;
    }
    if (x != 0) {
        rex |= 0x02;
    }
    if (b != 0) {
        rex |= 0x01;
    }
    
    pass(rex);
};

// ============================================================================
// ModR/M Byte Calculation
// ============================================================================
func:calc_modrm = uint8(int8:modval, int8:regval, int8:rmval) {
    uint8:output = 0;
    
    uint8:mod_u8 = (uint8)modval;
    uint8:reg_u8 = (uint8)regval;
    uint8:rm_u8 = (uint8)rmval;
    
    // Split complex expressions to avoid parser issues with parentheses + shift
    uint8:mod_bits = mod_u8 & 0x03;
    output = mod_bits << 6;
    
    uint8:reg_bits = reg_u8 & 0x07;
    uint8:reg_shifted = reg_bits << 3;
    output |= reg_shifted;
    
    uint8:rm_bits = rm_u8 & 0x07;
    output |= rm_bits;
    
    pass(output);
};

// ============================================================================
// Emit MOV instruction (register to register)
// ============================================================================
func:emit_mov = int64(uint8@ :buffer, int64:offset, int8:dst, int8:src) {
    // MOV dst, src
    // Encoding: REX.W + 89 /r
    
    int8:w = 1;
    int8:r_ext = (src >> 3) & 1;
    int8:b_ext = (dst >> 3) & 1;
    
    result:rex_result = calc_rex(w, r_ext, 0, b_ext);
    uint8:rex = (uint8)rex_result.val;
    result:modrm_result = calc_modrm(3, src & 7, dst & 7);
    uint8:modrm = (uint8)modrm_result.val;
    
    buffer[offset] = (int8)rex;
    buffer[offset + 1] = (int8)0x89;
    buffer[offset + 2] = (int8)modrm;
    
    pass(offset + 3);
};

// ============================================================================
// Emit ADD with 8-bit immediate
// ============================================================================
func:emit_add_imm8 = int64(uint8@ :buffer, int64:offset, int8:dst, int8:imm) {
    // ADD dst, imm8
    // Encoding: REX.W + 83 /0 ib
    
    int8:w = 1;
    int8:b_ext = (dst >> 3) & 1;
    
    result:rex_result = calc_rex(w, 0, 0, b_ext);
    uint8:rex = (uint8)rex_result.val;
    result:modrm_result = calc_modrm(3, 0, dst & 7);
    uint8:modrm = (uint8)modrm_result.val;
    
    buffer[offset] = (int8)rex;
    buffer[offset + 1] = (int8)0x83;
    buffer[offset + 2] = (int8)modrm;
    buffer[offset + 3] = imm;
    
    pass(offset + 4);
};

// ============================================================================
// Emit SUB with 8-bit immediate
// ============================================================================
func:emit_sub_imm8 = int64(uint8@ :buffer, int64:offset, int8:dst, int8:imm) {
    // SUB dst, imm8
    // Encoding: REX.W + 83 /5 ib
    
    int8:w = 1;
    int8:b_ext = (dst >> 3) & 1;
    
    result:rex_result = calc_rex(w, 0, 0, b_ext);
    uint8:rex = (uint8)rex_result.val;
    result:modrm_result = calc_modrm(3, 5, dst & 7);
    uint8:modrm = (uint8)modrm_result.val;
    
    buffer[offset] = (int8)rex;
    buffer[offset + 1] = (int8)0x83;
    buffer[offset + 2] = (int8)modrm;
    buffer[offset + 3] = imm;
    
    pass(offset + 4);
};

// ============================================================================
// Emit RET instruction
// ============================================================================
func:emit_ret = int64(uint8@ :buffer, int64:offset) {
    buffer[offset] = (int8)0xC3;
    pass(offset + 1);
};

// ============================================================================
// Main: Generate and display machine code
// ============================================================================
func:main = int8() {
    print("========================================");
    print("  Aria Runtime Assembler - ARA v2.0   ");
    print("========================================");
    print("");
    
    // Allocate executable memory placeholder
    uint8@ :code = 0;
    int64:pos = 0;
    
    // Generate: mov rax, rdi  (move first argument to return register)
    print("MOV RAX, RDI");
    result:mov_result = emit_mov(code, pos, RAX, RDI);
    pos = mov_result.val;
    
    // Generate: add rax, 10
    print("ADD RAX, 10");
    result:add_result = emit_add_imm8(code, pos, RAX, 10);
    pos = add_result.val;
    
    // Generate: sub rax, 5
    print("SUB RAX, 5");
    result:sub_result = emit_sub_imm8(code, pos, RAX, 5);
    pos = sub_result.val;
    
    // Generate: ret
    print("RET");
    result:ret_result = emit_ret(code, pos);
    pos = ret_result.val;
    
    print("");
    print("Code generation successful!");
    print("========================================");
    
    pass(0);
};
