// test_jit_simple.aria
// JIT Compiler Example: Generate x86-64 code to add two numbers
// This demonstrates the complete wildx lifecycle: Allocate -> Write -> Seal -> Execute

func:main = int8() {
    print("=== Aria JIT Compiler Demo ===");
    print("Generating machine code for: add(a, b) = a + b");
    
    // 1. ALLOCATION: Request executable-capable memory
    // Initial state: RW (writable, not executable)
    // We need at least 5 bytes for our simple function
    wildx uint8:code_buffer = 0;
    
    print("Step 1: Allocated executable memory");
    
    // TODO: In future implementation, we'll:
    // 2. Write machine code (x86-64 opcodes)
    // 3. Seal memory (transition RW -> RX)
    // 4. Cast to function pointer and execute
    // 5. Free memory
    
    print("wildx feature working!");
    print("Next: Implement aria.mem.protect_exec() intrinsic");
    
    *0;
};
