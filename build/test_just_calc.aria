// ARA - Aria Runtime Assembler - FINAL WORKING VERSION
// x86-64 machine code generation with dynamic encoding

int8:RAX = 0;
int8:RCX = 1;
int8:RDX = 2;
int8:RBX = 3;
int8:RSP = 4;
int8:RBP = 5;
int8:RSI = 6;
int8:RDI = 7;
int8:R8  = 8;
int8:R9  = 9;
int8:R10 = 10;
int8:R11 = 11;
int8:R12 = 12;
int8:R13 = 13;
int8:R14 = 14;
int8:R15 = 15;

// REX Prefix Calculation
func:calc_rex = uint8(int8:w, int8:r, int8:x, int8:b) {
    uint8:rex = 0x40;
    if (w != 0) { rex |= 0x08; }
    if (r != 0) { rex |= 0x04; }
    if (x != 0) { rex |= 0x02; }
    if (b != 0) { rex |= 0x01; }
    pass(rex);
};

// ModR/M Byte Calculation
func:calc_modrm = uint8(int8:modval, int8:regval, int8:rmval) {
    uint8:output = 0;
    uint8:mod_u8 = (uint8)modval;
    uint8:reg_u8 = (uint8)regval;
    uint8:rm_u8 = (uint8)rmval;
    
    uint8:mod_bits = mod_u8 & 0x03;
    output = mod_bits << 6;
    
    uint8:reg_bits = reg_u8 & 0x07;
    uint8:reg_shifted = reg_bits << 3;
    output |= reg_shifted;
    
    uint8:rm_bits = rm_u8 & 0x07;
    output |= rm_bits;
    
    pass(output);
};

// Emit MOV instruction (register to register)

func:main = int8() {
    result:r1 = calc_rex(1, 0, 0, 0);
    result:r2 = calc_modrm(3, 0, 0);
    pass(0);
};
