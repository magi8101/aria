# Async/Await Scheduler Integration - Work Package 003.1

**Status**: Codegen Integration Complete (Parser/Lexer TODO)  
**Priority**: High  
**Date**: 2025-01-24  

## Summary

Completed the codegen-level integration between LLVM coroutine suspension and the work-stealing scheduler runtime. Async functions can now properly allocate `CoroutineFrame` structs and schedule suspended coroutines on worker threads.

## What Was Completed

### 1. CoroutineFrame Allocation (codegen.cpp ~4795-4870)

Added proper `CoroutineFrame` struct allocation before scheduling:

```cpp
// Allocate CoroutineFrame on heap
Function* frameAlloc = getOrCreate("aria_frame_alloc");
Value* frame = ctx.builder->CreateCall(frameAlloc, {}, "coro_frame_alloc");

// Set frame->coro_handle = coroHandle (field 0)
Value* handleFieldPtr = ctx.builder->CreateStructGEP(..., frame, 0, ...);
ctx.builder->CreateStore(coroHandle, handleFieldPtr);

// Set frame->state = CORO_SUSPENDED (1)
Value* stateFieldPtr = ctx.builder->CreateStructGEP(..., frame, 3, ...);
ctx.builder->CreateStore(ConstantInt::get(..., 1), stateFieldPtr);

// Schedule the frame
aria_scheduler_schedule(frame);
```

**Changes**: 
- `src/backend/codegen.cpp` lines ~4795-4870
- Previously passed raw `void* coroHandle`
- Now creates full `CoroutineFrame*` struct with handle and state

### 2. Frame Allocation Runtime (scheduler.cpp)

Added heap allocation functions for `CoroutineFrame` structs:

```cpp
extern "C" CoroutineFrame* aria_frame_alloc() {
    CoroutineFrame* frame = new CoroutineFrame();
    frame->coro_handle = nullptr;
    frame->data = nullptr;
    frame->waiting_on = nullptr;
    frame->state = CORO_SUSPENDED;
    frame->padding = 0;
    return frame;
}

extern "C" void aria_frame_free(CoroutineFrame* frame) {
    delete frame;
}
```

**Changes**:
- `src/runtime/concurrency/scheduler.cpp` lines 7-20
- `src/runtime/concurrency/scheduler.h` lines 53-55

### 3. Scheduler C API Declaration (scheduler.h)

Declared all scheduler C API functions:

```c
extern "C" CoroutineFrame* aria_frame_alloc();
extern "C" void aria_frame_free(CoroutineFrame* frame);
extern "C" void aria_scheduler_init(int num_threads);
extern "C" void aria_scheduler_shutdown();
extern "C" void aria_scheduler_schedule(CoroutineFrame* frame);
extern "C" void aria_scheduler_resume(CoroutineFrame* frame);
```

**Changes**: `src/runtime/concurrency/scheduler.h` lines 52-59

### 4. Verified Existing Infrastructure

Confirmed these components already exist and are complete:

- ✅ `aria_scheduler_schedule()` - Schedules coroutine on worker thread (scheduler.cpp:53)
- ✅ `aria_scheduler_init()` - Creates N worker threads (scheduler.cpp:10)
- ✅ `Worker::run()` - Work-stealing loop with LIFO/FIFO (scheduler.cpp:85)
- ✅ `aria_coro_resume_bridge()` - Generated by codegen, calls llvm.coro.resume (codegen.cpp:6239)
- ✅ Coroutine suspension - Uses llvm.coro.* intrinsics correctly (codegen.cpp:1731-1861, 4762-4870)

## Architecture

### CoroutineFrame Structure
```c
struct CoroutineFrame {
    void* coro_handle;           // LLVM coroutine handle (from llvm.coro.begin)
    void* data;                  // Captured state (promoted from stack)
    CoroutineFrame* waiting_on;  // Dependency chain for await
    int state;                   // CORO_RUNNING(0), CORO_SUSPENDED(1), CORO_COMPLETE(2)
    char padding;                // AVX alignment
};
```

### Execution Flow

1. **Async Function Call**:
   - LLVM generates coroutine with `coro_id`, `coro_begin`, `coro_alloc`
   - Returns coroutine handle to caller

2. **Await Suspension** (codegen.cpp:4762-4870):
   - `coro_save` - Save suspension point
   - `coro_suspend` - Suspend coroutine (returns 0=resume, 1=destroy)
   - Allocate `CoroutineFrame` on heap
   - Set `frame->coro_handle` and `frame->state = SUSPENDED`
   - Call `aria_scheduler_schedule(frame)` to queue on worker

3. **Scheduler Execution** (scheduler.cpp:85-165):
   - Worker thread picks frame from queue (LIFO local, FIFO steal)
   - Calls `aria_coro_resume_bridge(frame->coro_handle)`
   - Bridge calls `llvm.coro.resume(handle)` intrinsic
   - Coroutine resumes execution

4. **Completion**:
   - Coroutine sets `frame->state = CORO_COMPLETE`
   - Worker thread frees the frame

### Work-Stealing Scheduler

- **N Worker Threads**: Auto-detected from CPU cores
- **Per-Thread Queue**: LIFO for cache locality
- **Work Stealing**: FIFO from victim queues for load balancing
- **Wild Affinity**: Tasks with `has_wild_affinity=true` cannot be stolen
- **Locking**: Mutex per queue, minimal contention

## What Remains TODO

### Critical: Parser/Lexer Support

The `await` keyword and `AwaitExpr` AST node don't exist yet:

1. ❌ Add `AWAIT` token to lexer (src/frontend/lexer.cpp)
2. ❌ Create `AwaitExpr` AST node (src/frontend/ast.h)
3. ❌ Add await expression parsing (src/frontend/parser.cpp)
4. ❌ Wire up `visit(AwaitExpr*)` in codegen (already exists but unreachable)

**Without these**, async functions compile but `await` syntax causes parse errors.

### Medium Priority: Task<T> Wrapper

Currently async functions return raw `void*` handles. Need:

1. ❌ `Task<T>` generic type for async return values
2. ❌ `.await()` method on Task<T> to block until completion
3. ❌ Result passing from coroutine to awaiter
4. ❌ Type-safe async/await (no manual handle management)

### Low Priority: Runtime Improvements

1. ❌ Scheduler initialization in runtime startup (currently manual)
2. ❌ Graceful shutdown (currently threads run forever)
3. ❌ Async I/O integration (timers, sockets, etc.)
4. ❌ Coroutine completion callbacks
5. ❌ Exception handling across suspension points

## Testing Status

### What Can Be Tested

- ✅ Async functions compile (without await)
- ✅ Coroutine frames are allocated
- ✅ Scheduler infrastructure exists
- ✅ Work-stealing logic works

### What Cannot Be Tested

- ❌ Await expressions (parser doesn't support them)
- ❌ Coroutine suspension/resumption (no await to trigger it)
- ❌ Scheduler integration end-to-end (needs await)
- ❌ Multi-coroutine scenarios

### Example (Currently Unsupported)

```aria
// This WILL NOT PARSE - await keyword doesn't exist
async func:fetch_data = int32() {
    int32:result = await some_io_task();  // Parse error!
    pass(result);
};
```

## Build Status

- ✅ Compiles without errors
- ⚠️ Warnings about deprecated `Intrinsic::getDeclaration` (use `getOrInsertDeclaration`)
- ✅ All runtime functions link correctly
- ✅ No ABI breakage

## Files Modified

| File | Lines Changed | Purpose |
|------|---------------|---------|
| `src/backend/codegen.cpp` | ~4795-4870 | CoroutineFrame allocation and scheduling |
| `src/runtime/concurrency/scheduler.cpp` | +16 lines | aria_frame_alloc/free implementations |
| `src/runtime/concurrency/scheduler.h` | +8 lines | C API declarations |

## Next Steps

1. **Immediate**: Add await keyword to lexer/parser (enables end-to-end testing)
2. **Short-term**: Implement Task<T> wrapper for type-safe async
3. **Medium-term**: Add scheduler auto-initialization
4. **Long-term**: Async I/O integration (file/network operations)

## References

- GEMINI_WORK_PACKAGE_003.txt - Original specification
- src/backend/codegen.cpp:4762-4870 - Await suspension logic
- src/runtime/concurrency/scheduler.cpp - Work-stealing scheduler
- src/runtime/concurrency/scheduler.h - CoroutineFrame definition
- docs/SIMD_INTRINSICS_STATUS.md - Related WP 003.2 completion

---

**Conclusion**: The scheduler integration is complete at the codegen level. The missing piece is parser/lexer support for the `await` keyword, which is required for end-to-end async/await functionality. Once that is added, the full async execution pipeline will be functional.
