================================================================================
BUG: Struct Member Access Fails in Codegen
================================================================================
Location: src/backend/codegen.cpp (MemberAccess visitor)
Impact: Cannot access struct fields (e.g., point.x, point.y)
Severity: HIGH
Status: BLOCKED - Parser support complete, codegen needs fix
Date: December 6, 2025

DESCRIPTION:
Struct member access fails during code generation with error:
"Member access on non-struct type"

ROOT CAUSE:
The codegen visitor for MemberAccess doesn't properly track that a variable
has a struct type. When it encounters `p.x`, it doesn't know that `p` is
of type `Point`.

WORKING:
- Struct declaration: const Point = struct { x: int64, y: int64, };
- Struct construction: Point:p = Point{x: 10, y: 20};
- Variable type tracking during declaration

FAILING:
- Member access: int64:val = p.x;

TEST CASE:
```aria
const Point = struct {
    x: int64,
    y: int64,
};

func:main = *int8() {
    Point:p = Point{x: 10, y: 20};
    int64:x_val = p.x;  // FAILS HERE
    return 0;
};
```

ERROR MESSAGE:
"Member access on non-struct type"

FIX REQUIRED:
1. Enhance symbol table to track variable types (not just existence)
2. When visiting VarDecl, store the type: symbols[name] = {type: "Point", ...}
3. When visiting MemberAccess:
   a. Look up the base expression's type
   b. If it's a struct type, use structFieldMaps to find field index
   c. Generate CreateStructGEP with correct index

LOCATION IN CODE:
src/backend/codegen.cpp - visit(MemberAccess* node)

ESTIMATED FIX TIME: 1-2 hours

WORKAROUND:
None - member access is required for struct functionality

RELATED:
- Struct support is otherwise complete
- Parser fully working
- Construction working
- This is purely a codegen type inference issue

--------------------------------------------------------------------------------
