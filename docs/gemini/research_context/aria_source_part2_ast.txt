===================================
ARIA COMPILER SOURCE - PART 2 of 8
Frontend: AST Definitions
===================================

--- src/frontend/ast.h ---
#ifndef ARIA_FRONTEND_AST_H
#define ARIA_FRONTEND_AST_H

#include <memory>
#include <string>
#include <vector>

namespace aria {
namespace frontend {

// Forward Declarations
class AstNode;
class AstVisitor;
class Expression;
class Statement;
class Block;
class VarDecl;
class FuncDecl;
class StructDecl;
class AsyncBlock;
class VarExpr;
class IntLiteral;
class BoolLiteral;
class NullLiteral;
class FloatLiteral;
class StringLiteral;
class TemplateString;
class TernaryExpr;
class BinaryOp;
class UnaryOp;
class CallExpr;
class ReturnStmt;
class ExpressionStmt;
class IfStmt;
class PickStmt;
class PickCase;
class FallStmt;
class WhenLoop;
class TillLoop;
class DeferStmt;
class ForLoop;
class WhileLoop;
class BreakStmt;
class ContinueStmt;
class WhenExpr;
class AwaitExpr;
class SpawnExpr;
class UnwrapExpr;
class ObjectLiteral;
class VectorLiteral;
class ArrayLiteral;
class IndexExpr;
class MemberAccess;
class LambdaExpr;
class CastExpr;
class UseStmt;
class ModDef;
class ExternBlock;
class TraitDecl;
class ImplDecl;

// Base AST Node
// All AST nodes inherit from this class
class AstNode {
public:
    virtual ~AstNode() = default;
    virtual void accept(AstVisitor& visitor) = 0;
};

// Visitor Pattern Interface
// Visitors traverse the AST and perform operations on nodes
class AstVisitor {
public:
    virtual ~AstVisitor() = default;

    // Expressions
    virtual void visit(VarExpr* node) = 0;
    virtual void visit(IntLiteral* node) = 0;
    virtual void visit(FloatLiteral* node) = 0;
    virtual void visit(BoolLiteral* node) = 0;
    virtual void visit(NullLiteral* node) = 0;
    virtual void visit(StringLiteral* node) = 0;
    virtual void visit(TemplateString* node) = 0;
    virtual void visit(TernaryExpr* node) = 0;
    virtual void visit(BinaryOp* node) = 0;
    virtual void visit(UnaryOp* node) = 0;
    virtual void visit(CallExpr* node) = 0;
    virtual void visit(ObjectLiteral* node) { /* default: do nothing */ }
    virtual void visit(MemberAccess* node) { /* default: do nothing */ }
    virtual void visit(VectorLiteral* node) { /* default: do nothing */ }
    virtual void visit(ArrayLiteral* node) { /* default: do nothing */ }
    virtual void visit(IndexExpr* node) { /* default: do nothing */ }
    virtual void visit(UnwrapExpr* node) { /* default: do nothing */ }
    virtual void visit(LambdaExpr* node) { /* default: do nothing */ }
    virtual void visit(CastExpr* node) { /* default: do nothing */ }

    // Statements
    virtual void visit(VarDecl* node) = 0;
    virtual void visit(FuncDecl* node) { /* default: do nothing */ }
    virtual void visit(StructDecl* node) { /* default: do nothing */ }
    virtual void visit(ReturnStmt* node) = 0;
    virtual void visit(ExpressionStmt* node) { /* default: visit expression */ }
    virtual void visit(IfStmt* node) = 0;
    virtual void visit(Block* node) = 0;

    // Control Flow
    virtual void visit(PickStmt* node) = 0;
    virtual void visit(FallStmt* node) { /* default: do nothing */ }
    virtual void visit(TillLoop* node) = 0;
    virtual void visit(WhenLoop* node) = 0;
    virtual void visit(DeferStmt* node) = 0;
    
    // New loop types (Bugs #67-68)
    virtual void visit(ForLoop* node) { /* default: do nothing */ }
    virtual void visit(WhileLoop* node) { /* default: do nothing */ }
    virtual void visit(BreakStmt* node) { /* default: do nothing */ }
    virtual void visit(ContinueStmt* node) { /* default: do nothing */ }
    
    // New expression types (Bugs #69-70)
    virtual void visit(WhenExpr* node) { /* default: do nothing */ }
    virtual void visit(AwaitExpr* node) { /* default: do nothing */ }
    virtual void visit(SpawnExpr* node) { /* default: do nothing */ }
    
    // Async/await support (Bug #70)
    virtual void visit(AsyncBlock* node) { /* default: do nothing */ }
    
    // Module system (Bugs #73-75)
    virtual void visit(UseStmt* node) { /* default: do nothing */ }
    virtual void visit(ModDef* node) { /* default: do nothing */ }
    virtual void visit(ExternBlock* node) { /* default: do nothing */ }
    
    // Trait system (WP 005)
    virtual void visit(TraitDecl* node) { /* default: do nothing */ }
    virtual void visit(ImplDecl* node) { /* default: do nothing */ }
};

// Block Statement
// Represents a sequence of statements
class Block : public AstNode {
public:
    std::vector<std::unique_ptr<AstNode>> statements;

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

} // namespace frontend
} // namespace aria

#endif // ARIA_FRONTEND_AST_H



--- src/frontend/ast/expr.h ---
#ifndef ARIA_FRONTEND_AST_EXPR_H
#define ARIA_FRONTEND_AST_EXPR_H

#include "../ast.h"
#include <string>
#include <memory>
#include <vector>

namespace aria {
namespace frontend {

// Base Expression Class
class Expression : public AstNode {
public:
    virtual ~Expression() = default;
};

// When Expression (Pattern Matching Expression)
// Example: when { x == 1 then 10; x == 2 then 20; end }
struct WhenCase {
    std::unique_ptr<Expression> condition;
    std::unique_ptr<Expression> result;
};

class WhenExpr : public Expression {
public:
    std::vector<WhenCase> cases;
    std::unique_ptr<Expression> else_result;  // Optional else case

    WhenExpr() = default;

    void accept(AstVisitor& visitor) override {
        // visitor.visit(this);
    }
};

// Await Expression (Async/Await)
// Example: await asyncFunction()
class AwaitExpr : public Expression {
public:
    std::unique_ptr<Expression> expression;

    AwaitExpr(std::unique_ptr<Expression> expr)
        : expression(std::move(expr)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Spawn Expression (Concurrent Execution)
// Example: spawn fetchData(url)
// Returns Future<T> where T is the return type of the spawned function
class SpawnExpr : public Expression {
public:
    std::unique_ptr<Expression> expression;  // Usually a CallExpr

    SpawnExpr(std::unique_ptr<Expression> expr)
        : expression(std::move(expr)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Variable Reference Expression
// Example: x, myVar
class VarExpr : public Expression {
public:
    std::string name;

    VarExpr(const std::string& n) : name(n) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Integer Literal Expression
// Example: 42, 0xFF, 512
class IntLiteral : public Expression {
public:
    int64_t value;

    IntLiteral(int64_t v) : value(v) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Float Literal Expression
// Example: 3.14, 1.5e10, 1e-5
class FloatLiteral : public Expression {
public:
    double value;

    FloatLiteral(double v) : value(v) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Boolean Literal Expression
// Example: true, false
class BoolLiteral : public Expression {
public:
    bool value;

    BoolLiteral(bool v) : value(v) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Null Literal Expression
// Example: NULL
class NullLiteral : public Expression {
public:
    NullLiteral() {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// String Literal Expression
// Example: "hello world", "whats up"
class StringLiteral : public Expression {
public:
    std::string value;

    StringLiteral(const std::string& v) : value(v) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Template String Part (for interpolation)
struct TemplatePart {
    enum Type { STRING, EXPR } type;
    std::string string_value;                    // If type == STRING
    std::unique_ptr<Expression> expr_value;      // If type == EXPR
    
    TemplatePart(const std::string& s) 
        : type(STRING), string_value(s) {}
    
    TemplatePart(std::unique_ptr<Expression> e) 
        : type(EXPR), expr_value(std::move(e)) {}
};

// Template String Expression
// Example: `Value is &{val}`, `Result: &{x + y}`
class TemplateString : public Expression {
public:
    std::vector<TemplatePart> parts;

    TemplateString() = default;

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Ternary Expression (is operator)
// Example: is x > 0 : positive : negative
class TernaryExpr : public Expression {
public:
    std::unique_ptr<Expression> condition;
    std::unique_ptr<Expression> true_expr;
    std::unique_ptr<Expression> false_expr;

    TernaryExpr(std::unique_ptr<Expression> cond, 
                std::unique_ptr<Expression> true_val,
                std::unique_ptr<Expression> false_val)
        : condition(std::move(cond)), 
          true_expr(std::move(true_val)), 
          false_expr(std::move(false_val)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Unwrap Expression (? operator)
// Example: test2(3,5) ? -1  // If test2 returns error, use -1 as default
class UnwrapExpr : public Expression {
public:
    std::unique_ptr<Expression> expression;   // Expression that might fail
    std::unique_ptr<Expression> default_value;  // Default if error

    UnwrapExpr(std::unique_ptr<Expression> expr, std::unique_ptr<Expression> def)
        : expression(std::move(expr)), default_value(std::move(def)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Binary Operation Expression
// Example: a + b, x * y
class BinaryOp : public Expression {
public:
    enum OpType {
        ADD, SUB, MUL, DIV, MOD,
        EQ, NE, LT, GT, LE, GE,
        LOGICAL_AND, LOGICAL_OR,
        BITWISE_AND, BITWISE_OR, BITWISE_XOR,
        LSHIFT, RSHIFT,
        ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, STAR_ASSIGN, SLASH_ASSIGN, MOD_ASSIGN,
        AND_ASSIGN, OR_ASSIGN, XOR_ASSIGN, LSHIFT_ASSIGN, RSHIFT_ASSIGN
    };

    OpType op;
    std::unique_ptr<Expression> left;
    std::unique_ptr<Expression> right;

    BinaryOp(OpType o, std::unique_ptr<Expression> l, std::unique_ptr<Expression> r)
        : op(o), left(std::move(l)), right(std::move(r)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Unary Operation Expression
// Example: -x, !flag, ~bits, x++, x--
class UnaryOp : public Expression {
public:
    enum OpType {
        NEG,            // -
        LOGICAL_NOT,    // !
        BITWISE_NOT,    // ~
        POST_INC,       // x++
        POST_DEC,       // x--
        ADDRESS_OF,     // @ (address/pointer operator)
        PIN             // # (memory pinning operator)
    };

    OpType op;
    std::unique_ptr<Expression> operand;

    UnaryOp(OpType o, std::unique_ptr<Expression> opnd)
        : op(o), operand(std::move(opnd)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Function Call Expression
// Example: foo(a, b, c) or max<int8>(5, 10) for generic calls
class CallExpr : public Expression {
public:
    std::string function_name;  // For simple calls: foo()
    std::unique_ptr<Expression> callee;  // For complex calls: p.method(), (get_fn())()
    std::vector<std::unique_ptr<Expression>> arguments;
    std::vector<std::string> type_arguments;  // Generic type args: max<int8, int8>

    // Constructor for simple function calls by name
    CallExpr(const std::string& name) : function_name(name) {}
    
    // Constructor for calls with expression callee (member access, etc.)
    CallExpr(std::unique_ptr<Expression> callee_expr) : callee(std::move(callee_expr)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Object Literal Expression (for Result and anonymous objects)
// Example: { err: NULL, val: 42 }
// Also used for struct constructors: Point{ x: 10, y: 20 }
class ObjectLiteral : public Expression {
public:
    struct Field {
        std::string name;
        std::unique_ptr<Expression> value;
    };
    
    std::vector<Field> fields;
    std::string type_name;  // For struct constructors, stores the struct type name

    ObjectLiteral() = default;

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Member Access Expression
// Example: obj.field, result.err, result.val, p.distance(), Point.origin()
class MemberAccess : public Expression {
public:
    std::unique_ptr<Expression> object;
    std::string member_name;
    bool is_safe;  // true for ?. operator
    bool is_static = false;  // true for Type.member (static method/field access)

    MemberAccess(std::unique_ptr<Expression> obj, const std::string& member, bool safe = false)
        : object(std::move(obj)), member_name(member), is_safe(safe) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Vector Literal Expression (GLSL-style constructors)
// Example: vec4(1.0, 2.0, 3.0, 4.0), vec3(0.0), ivec2(1, 2)
// Supports broadcasting: vec4(1.0) -> <1.0, 1.0, 1.0, 1.0>
// Supports composition: vec4(vec2(1,2), 3, 4) -> <1, 2, 3, 4>
class VectorLiteral : public Expression {
public:
    std::string vector_type;  // The vector type name (vec4, ivec3, etc.)
    std::vector<std::unique_ptr<Expression>> elements;

    VectorLiteral(const std::string& type) : vector_type(type) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Array Literal Expression
// Example: [1, 2, 3, 4, 5]
class ArrayLiteral : public Expression {
public:
    std::vector<std::unique_ptr<Expression>> elements;

    ArrayLiteral() = default;

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Array Index Expression
// Example: arr[i], matrix[x][y]
class IndexExpr : public Expression {
public:
    std::unique_ptr<Expression> array;
    std::unique_ptr<Expression> index;

    IndexExpr(std::unique_ptr<Expression> arr, std::unique_ptr<Expression> idx)
        : array(std::move(arr)), index(std::move(idx)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Cast Expression
// Example: (int64)x, (BinaryFunc)wildx_buffer
class CastExpr : public Expression {
public:
    std::string target_type;  // Type to cast to
    std::unique_ptr<Expression> expression;  // Expression being cast

    CastExpr(const std::string& type, std::unique_ptr<Expression> expr)
        : target_type(type), expression(std::move(expr)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Forward declaration for lambda
struct FuncParam;
class Block;

// Lambda Expression (Anonymous Function)
// Example: int8(int8:a, int8:b) { return { err: NULL, val: a + b }; }
// Example with immediate execution: int8(int8:a){...}(10)
// Example with auto-wrap: *int8(int8:a){ return a; }  // Compiler wraps to {err:NULL, val:a}
class LambdaExpr : public Expression {
public:
    std::string return_type;
    std::vector<FuncParam> parameters;
    std::unique_ptr<Block> body;
    
    // Optional immediate call arguments
    bool is_immediately_invoked = false;
    std::vector<std::unique_ptr<Expression>> call_arguments;
    
    // Auto-wrap flag: if true, compiler wraps return values in {err:NULL, val:...}
    // Set when return type is prefixed with * (e.g., *int8)
    bool auto_wrap = false;
    
    // Async flag: if true, this is an async function (uses coroutines)
    bool is_async = false;
    
    // Closure capture tracking (populated by type checker)
    struct CapturedVariable {
        std::string name;
        std::string type;
        bool is_global;  // true if module-level, false if from parent scope
        
        CapturedVariable(const std::string& n, const std::string& t, bool global)
            : name(n), type(t), is_global(global) {}
    };
    std::vector<CapturedVariable> captured_variables;
    bool needs_heap_environment = false;  // true if captures non-global variables

    LambdaExpr(const std::string& ret_type, std::vector<FuncParam> params, std::unique_ptr<Block> b)
        : return_type(ret_type), parameters(std::move(params)), body(std::move(b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

} // namespace frontend
} // namespace aria

#endif // ARIA_FRONTEND_AST_EXPR_H



--- src/frontend/ast/stmt.h ---
#ifndef ARIA_FRONTEND_AST_STMT_H
#define ARIA_FRONTEND_AST_STMT_H

#include "../ast.h"
#include "expr.h"
#include <string>
#include <memory>
#include <vector>

namespace aria {
namespace frontend {

// Base Statement Class
class Statement : public AstNode {
public:
    virtual ~Statement() = default;
};

// Variable Declaration Statement
// Example: int64:x = 42;
// Generic function example: func<T>:identity = *T(T:x) { return x; };
class VarDecl : public Statement {
public:
    std::string name;
    std::string type;
    std::unique_ptr<Expression> initializer;
    std::vector<std::string> generic_params;  // Generic type parameters (e.g., ["T", "U"])
    bool is_stack = false;
    bool is_wild = false;
    bool is_wildx = false;  // Executable memory for JIT compilation
    bool is_const = false;  // Bug #72: compile-time constant

    VarDecl(const std::string& t, const std::string& n, std::unique_ptr<Expression> init = nullptr)
        : name(n), type(t), initializer(std::move(init)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Return Statement
// Example: return 42;
class ReturnStmt : public Statement {
public:
    std::unique_ptr<Expression> value;

    ReturnStmt(std::unique_ptr<Expression> v)
        : value(std::move(v)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// If Statement
// Example: if (cond) { ... } else { ... }
class IfStmt : public Statement {
public:
    std::unique_ptr<Expression> condition;
    std::unique_ptr<Block> then_block;
    std::unique_ptr<Block> else_block;  // May be nullptr

    IfStmt(std::unique_ptr<Expression> cond, std::unique_ptr<Block> then_b, std::unique_ptr<Block> else_b = nullptr)
        : condition(std::move(cond)), then_block(std::move(then_b)), else_block(std::move(else_b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Expression Statement
// Wraps an expression as a statement (e.g., function call)
class ExpressionStmt : public Statement {
public:
    std::unique_ptr<Expression> expression;

    ExpressionStmt(std::unique_ptr<Expression> expr)
        : expression(std::move(expr)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Function Parameter
struct FuncParam {
    std::string type;
    std::string name;
    std::unique_ptr<Expression> default_value;  // Optional default
    
    FuncParam(const std::string& t, const std::string& n, std::unique_ptr<Expression> def = nullptr)
        : type(t), name(n), default_value(std::move(def)) {}
};

// Struct Field
struct StructField {
    std::string type;
    std::string name;
    
    StructField(const std::string& t, const std::string& n)
        : type(t), name(n) {}
};

// Struct Declaration
// Example: const Point = struct { x: int64, y: int64, };
// With methods: const Point = struct {
//     x: int64,
//     y: int64,
//     func:distance = flt32(self) { pass(sqrt(self.x*self.x + self.y*self.y)); };
// };
class StructDecl : public Statement {
public:
    std::string name;
    std::vector<StructField> fields;
    std::vector<std::unique_ptr<FuncDecl>> methods;  // Changed from VarDecl to FuncDecl for proper method support
    bool is_const = true;  // Structs are typically const type definitions
    
    StructDecl(const std::string& n, std::vector<StructField> f)
        : name(n), fields(std::move(f)) {}
    
    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Function Declaration (Bug #70: async support)
// Example: func:add = int8(int8:a, int8:b) { return {err:NULL, val:a+b}; }
// Example with auto-wrap: func:add = *int8(int8:a, int8:b) { return a+b; }
// Example with generics: func<T>:identity = T(T:x) { return {err:NULL, val:x}; }
class FuncDecl : public Statement {
public:
    std::string name;
    std::vector<std::string> generics;  // Generic type parameters (e.g., ["T", "U"])
    std::vector<FuncParam> parameters;
    std::string return_type;
    std::unique_ptr<Block> body;
    bool is_async = false;  // Bug #70: async function support
    bool is_pub = false;    // public visibility
    bool auto_wrap = false; // Auto-wrap returns in {err:NULL, val:...}
    
    FuncDecl(const std::string& n, std::vector<std::string> gen, std::vector<FuncParam> params, const std::string& ret_type, std::unique_ptr<Block> b)
        : name(n), generics(std::move(gen)), parameters(std::move(params)), return_type(ret_type), body(std::move(b)) {}
    
    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Async Block Statement (Bug #70: async blocks with catch)
// Example: async { ... } catch (err:e) { ... }
class AsyncBlock : public Statement {
public:
    std::unique_ptr<Block> body;
    std::unique_ptr<Block> catch_block;  // May be nullptr
    std::string error_var;               // Variable name for caught error
    
    AsyncBlock(std::unique_ptr<Block> b, std::unique_ptr<Block> catch_b = nullptr, const std::string& err_var = "")
        : body(std::move(b)), catch_block(std::move(catch_b)), error_var(err_var) {}
    
    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Trait Method Signature (WP 005: Trait System)
// Represents a method signature in a trait declaration
struct TraitMethod {
    std::string name;
    std::vector<FuncParam> parameters;
    std::string return_type;
    bool auto_wrap = false;
    
    TraitMethod(const std::string& n, std::vector<FuncParam> params, const std::string& ret)
        : name(n), parameters(std::move(params)), return_type(ret) {}
};

// Trait Declaration (WP 005: Trait System)
// Example: trait:Drawable = { func:draw = void(self); func:area = flt32(self); };
class TraitDecl : public Statement {
public:
    std::string name;
    std::vector<TraitMethod> methods;
    std::vector<std::string> super_traits;  // Trait inheritance (future)
    
    TraitDecl(const std::string& n, std::vector<TraitMethod> m)
        : name(n), methods(std::move(m)) {}
    
    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Trait Implementation (WP 005: Trait System)
// Example: impl:Drawable:for:Circle = { func:draw = void(self) { ... }; func:area = flt32(self) { ... }; };
class ImplDecl : public Statement {
public:
    std::string trait_name;
    std::string type_name;
    std::vector<std::unique_ptr<FuncDecl>> methods;
    
    ImplDecl(const std::string& trait, const std::string& type, std::vector<std::unique_ptr<FuncDecl>> m)
        : trait_name(trait), type_name(type), methods(std::move(m)) {}
    
    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

} // namespace frontend
} // namespace aria

#endif // ARIA_FRONTEND_AST_STMT_H



--- src/frontend/ast/control_flow.h ---
#ifndef ARIA_FRONTEND_AST_CONTROL_FLOW_H
#define ARIA_FRONTEND_AST_CONTROL_FLOW_H

#include "../ast.h"
#include "stmt.h"
#include "expr.h"
#include <memory>
#include <vector>

namespace aria {
namespace frontend {

// Destructuring Pattern for Pick Cases (Bug #64)
// Represents object/array patterns in pick statements
struct DestructurePattern {
    enum PatternType {
        IDENTIFIER,     // Simple binding: x
        OBJECT,         // Object pattern: { key: value }
        ARRAY,          // Array pattern: [a, b, c]
        REST            // Rest pattern: ...rest
    };
    
    PatternType type;
    std::string name;  // For IDENTIFIER and REST
    std::vector<std::pair<std::string, DestructurePattern>> object_fields;  // For OBJECT
    std::vector<DestructurePattern> array_elements;  // For ARRAY
    
    DestructurePattern() : type(IDENTIFIER) {}
    DestructurePattern(PatternType t, const std::string& n = "") : type(t), name(n) {}
};

// Pick Case (Pattern Matching Case)
// Represents a single case in a pick statement
class PickCase {
public:
    enum CaseType {
        EXACT,          // Exact value match: (5)
        LESS_THAN,      // Less than: (<9)
        GREATER_THAN,   // Greater than: (>9)
        LESS_EQUAL,     // Less or equal: (<=9)
        GREATER_EQUAL,  // Greater or equal: (>=9)
        RANGE,          // Range match: (1..10) or (1...10)
        WILDCARD,       // Default case: (*)
        DESTRUCTURE_OBJ,// Object destructuring: ({ key: value })
        DESTRUCTURE_ARR,// Array destructuring: ([a, b, c])
        UNREACHABLE     // Labeled unreachable: label:(!)
    };

    CaseType type;
    std::string label;  // Optional label for fall() targets
    std::unique_ptr<Expression> value_start;
    std::unique_ptr<Expression> value_end;  // For range cases
    std::unique_ptr<Block> body;
    bool is_range_exclusive = false;  // true for ..., false for ..
    std::unique_ptr<DestructurePattern> pattern;  // For destructuring patterns (Bug #64)

    PickCase(CaseType t, std::unique_ptr<Block> b)
        : type(t), body(std::move(b)) {}
};

// Fall Statement (Explicit Fallthrough in pick)
// Example: fall(label);
class FallStmt : public Statement {
public:
    std::string target_label;

    FallStmt(const std::string& label) : target_label(label) {}

    void accept(AstVisitor& visitor) override {
        // visitor.visit(this);
    }
};

// Pick Statement (Pattern Matching)
// Example: pick (x) { 0 => { ... }, <9 => { ... }, _ => { ... } }
class PickStmt : public Statement {
public:
    std::unique_ptr<Expression> selector;
    std::vector<PickCase> cases;

    PickStmt(std::unique_ptr<Expression> sel)
        : selector(std::move(sel)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// When Loop (Loop with Completion Blocks)
// Spec Example: when(condition) { body } then { success } end { failure }
// - Main body executes repeatedly while condition is true
// - 'then' block runs after successful loop completion
// - 'end' block runs if loop never ran or broke early
class WhenLoop : public Statement {
public:
    std::unique_ptr<Expression> condition;
    std::unique_ptr<Block> body;
    std::unique_ptr<Block> then_block;  // Runs after successful completion
    std::unique_ptr<Block> end_block;   // Runs if loop didn't run or broke early

    WhenLoop(std::unique_ptr<Expression> cond, std::unique_ptr<Block> b,
             std::unique_ptr<Block> then_b = nullptr, std::unique_ptr<Block> end_b = nullptr)
        : condition(std::move(cond)), body(std::move(b)), 
          then_block(std::move(then_b)), end_block(std::move(end_b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

} // namespace frontend
} // namespace aria

#endif // ARIA_FRONTEND_AST_CONTROL_FLOW_H



--- src/frontend/ast/loops.h ---
#ifndef ARIA_FRONTEND_AST_LOOPS_H
#define ARIA_FRONTEND_AST_LOOPS_H

#include "../ast.h"
#include "expr.h"
#include <memory>

namespace aria {
namespace frontend {

// Till Loop (Iteration Loop)
// Example: till(100, 1) { ... }
// Iterates from 0 to limit with step, using $ as iterator variable
class TillLoop : public Statement {
public:
    std::unique_ptr<Expression> limit;
    std::unique_ptr<Expression> step;
    std::unique_ptr<Block> body;

    TillLoop(std::unique_ptr<Expression> lim, std::unique_ptr<Expression> stp, std::unique_ptr<Block> b)
        : limit(std::move(lim)), step(std::move(stp)), body(std::move(b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// For Loop (Iterator-based Loop)
// Example: for x in collection { ... }
class ForLoop : public Statement {
public:
    std::string iterator_name;
    std::unique_ptr<Expression> iterable;
    std::unique_ptr<Block> body;

    ForLoop(const std::string& iter, std::unique_ptr<Expression> itbl, std::unique_ptr<Block> b)
        : iterator_name(iter), iterable(std::move(itbl)), body(std::move(b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// While Loop
// Example: while condition { ... }
class WhileLoop : public Statement {
public:
    std::unique_ptr<Expression> condition;
    std::unique_ptr<Block> body;

    WhileLoop(std::unique_ptr<Expression> cond, std::unique_ptr<Block> b)
        : condition(std::move(cond)), body(std::move(b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Break Statement
// Example: break; or break(label);
class BreakStmt : public Statement {
public:
    std::string label;  // Optional label for multi-level breaks

    BreakStmt(const std::string& lbl = "") : label(lbl) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Continue Statement
// Example: continue; or continue(label);
class ContinueStmt : public Statement {
public:
    std::string label;  // Optional label for multi-level continues

    ContinueStmt(const std::string& lbl = "") : label(lbl) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

} // namespace frontend
} // namespace aria

#endif // ARIA_FRONTEND_AST_LOOPS_H



--- src/frontend/ast/defer.h ---
#ifndef ARIA_FRONTEND_AST_DEFER_H
#define ARIA_FRONTEND_AST_DEFER_H

#include "../ast.h"
#include <memory>

namespace aria {
namespace frontend {

// Defer Statement
// Example: defer { cleanup(); }
// Executes the block when the current scope exits
class DeferStmt : public Statement {
public:
    std::unique_ptr<Block> body;

    DeferStmt(std::unique_ptr<Block> b)
        : body(std::move(b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

} // namespace frontend
} // namespace aria

#endif // ARIA_FRONTEND_AST_DEFER_H



--- src/frontend/ast/module.h ---
#ifndef ARIA_FRONTEND_AST_MODULE_H
#define ARIA_FRONTEND_AST_MODULE_H

#include "../ast.h"
#include "stmt.h"
#include <string>
#include <memory>
#include <vector>

namespace aria {
namespace frontend {

// Use Statement (Import)
// Example: use std.io; or use std.io.{read, write};
class UseStmt : public Statement {
public:
    std::string module_path;  // e.g., "std.io"
    std::vector<std::string> imports;  // Empty = import all, otherwise specific items

    UseStmt(const std::string& path, const std::vector<std::string>& imps = {})
        : module_path(path), imports(imps) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Extern Block (Foreign Function Interface)
// Example: extern { fn c_function(int32) -> int32; }
class ExternBlock : public Statement {
public:
    std::vector<std::unique_ptr<Statement>> declarations;

    ExternBlock() = default;

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

// Module Definition
// Example: mod utils { ... }
class ModDef : public Statement {
public:
    std::string name;
    std::unique_ptr<Block> body;

    ModDef(const std::string& n, std::unique_ptr<Block> b)
        : name(n), body(std::move(b)) {}

    void accept(AstVisitor& visitor) override {
        visitor.visit(this);
    }
};

} // namespace frontend
} // namespace aria

#endif // ARIA_FRONTEND_AST_MODULE_H
