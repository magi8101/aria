===================================
ARIA COMPILER SOURCE - PART 4 of 8
Frontend: Parser - Declarations & Statements
===================================

--- src/frontend/parser_decl.cpp ---
// Implementation of Variable Declaration Parsing with Colon Syntax Anchor
#include "parser.h"
#include "ast.h"
#include "ast/stmt.h"

namespace aria {
namespace frontend {

// Parser constructors
Parser::Parser(AriaLexer& lex) : lexer(lex), context() {
    advance(); // Load first token
}

Parser::Parser(AriaLexer& lex, ParserContext ctx) : lexer(lex), context(ctx) {
    advance(); // Load first token
}

void Parser::advance() {
    current = lexer.nextToken();
}

bool Parser::match(TokenType type) {
    if (current.type == type) {
        advance();
        return true;
    }
    return false;
}

Token Parser::expect(TokenType type) {
    if (current.type != type) {
        throw std::runtime_error("Unexpected token");
    }
    Token tok = current;
    advance();
    return tok;
}

Token Parser::consume(TokenType type, const std::string& message) {
    if (current.type != type) {
        throw std::runtime_error(message);
    }
    Token tok = current;
    advance();
    return tok;
}

bool Parser::check(TokenType type) {
    return current.type == type;
}

Token Parser::peek() {
    return current;
}

bool Parser::isType(const Token& token) {
    // Check if token could be a type name
    // This includes built-in types and user-defined types (identifiers)
    switch (token.type) {
        case TOKEN_TYPE_INT8:
        case TOKEN_TYPE_INT16:
        case TOKEN_TYPE_INT32:
        case TOKEN_TYPE_INT64:
        case TOKEN_TYPE_INT128:
        case TOKEN_TYPE_INT256:
        case TOKEN_TYPE_INT512:
        case TOKEN_TYPE_UINT8:
        case TOKEN_TYPE_UINT16:
        case TOKEN_TYPE_UINT32:
        case TOKEN_TYPE_UINT64:
        case TOKEN_TYPE_UINT128:
        case TOKEN_TYPE_UINT256:
        case TOKEN_TYPE_UINT512:
        case TOKEN_TYPE_FLT32:
        case TOKEN_TYPE_FLT64:
        case TOKEN_TYPE_STRING:
        case TOKEN_TYPE_BOOL:
        case TOKEN_TYPE_FUNC:
        case TOKEN_TYPE_RESULT:
        case TOKEN_TYPE_DYN:
        case TOKEN_IDENTIFIER:  // User-defined types (structs, type aliases, function types)
            return true;
        default:
            return false;
    }
}

std::string Parser::parseTypeName() {
    // Parse a complete type name, including built-in types and identifiers
    std::string typeName;
    
    // Check if it's a built-in type keyword (func, result, int8, etc.)
    if (current.type >= TOKEN_TYPE_VOID && current.type <= TOKEN_TYPE_STRING) {
        typeName = current.value;
        advance();
    } else if (current.type == TOKEN_IDENTIFIER) {
        typeName = current.value;
        advance();
    } else {
        throw std::runtime_error("Expected type name");
    }
    
    // Handle pointer suffix (@)
    while (match(TOKEN_AT)) {
        typeName += "@";
    }
    
    // Handle array suffix ([size] or [])
    if (match(TOKEN_LEFT_BRACKET)) {
        typeName += "[";
        if (!check(TOKEN_RIGHT_BRACKET)) {
            Token sizeTok = expect(TOKEN_INT_LITERAL);
            typeName += sizeTok.value;
        }
        expect(TOKEN_RIGHT_BRACKET);
        typeName += "]";
    }
    
    return typeName;
}

// Parses: [const] [wild|wildx|stack|gc] Type:Identifier [= Expression];
// Grammar:
//   VarDecl -> "const"? ( "wild" | "wildx" | "stack" | "gc" )? TypeIdentifier ":" Identifier ( "=" Expression )? ";"
std::unique_ptr<Statement> Parser::parseVarDecl() {
   bool is_const = false;
   bool is_wild = false;
   bool is_wildx = false;
   bool is_stack = false;

   // 1. Check for const keyword (Bug #72)
   if (match(TOKEN_KW_CONST)) {
       is_const = true;
   }

   // 2. Check for Memory Strategy Keywords
   if (match(TOKEN_KW_WILD) || match(TOKEN_WILD)) {
       is_wild = true;
   } else if (match(TOKEN_KW_WILDX) || match(TOKEN_WILDX)) {
       is_wildx = true;
   } else if (match(TOKEN_KW_STACK) || match(TOKEN_STACK)) {
       is_stack = true;
   } else if (match(TOKEN_KW_GC) || match(TOKEN_GC)) {
       // Explicitly gc (default anyway)
   }

   // 3. Parse Type
   std::string type_name;
   if (isTypeToken(current.type)) {
       type_name = current.value;
       advance();
   } else {
       throw std::runtime_error("Expected type in variable declaration");
   }
   
   // Handle array types: int8[256] or int8[]
   if (check(TOKEN_LEFT_BRACKET)) {
       advance(); // consume [
       type_name += "[";
       
       // Check for array size
       if (!check(TOKEN_RIGHT_BRACKET)) {
           Token size_tok = expect(TOKEN_INT_LITERAL);
           type_name += size_tok.value;
       }
       
       expect(TOKEN_RIGHT_BRACKET);
       type_name += "]";
   }
   
   // 4. Expect colon
   expect(TOKEN_COLON);
   
   // 5. Parse variable name
   Token name_tok = expect(TOKEN_IDENTIFIER);
   std::string var_name = name_tok.value;
   
   // 6. Create AST Node
   std::unique_ptr<Expression> initializer = nullptr;
   
   // 7. Handle Optional Assignment
   if (match(TOKEN_ASSIGN)) {
       initializer = parseExpr();
   } else {
       // Validation: Wild pointers MUST be initialized
       if (is_wild && context.strictMode) {
            throw std::runtime_error("Wild variables must be initialized immediately.");
       }
       // Const variables MUST be initialized
       if (is_const) {
            throw std::runtime_error("Const variables must be initialized.");
       }
   }

   auto decl = std::make_unique<VarDecl>(type_name, var_name, std::move(initializer));
   decl->is_wild = is_wild;
   decl->is_wildx = is_wildx;
   decl->is_stack = is_stack;
   decl->is_const = is_const;

   // 8. Terminator
   match(TOKEN_SEMICOLON);  // Optional semicolon

   return decl;
}

} // namespace frontend
} // namespace aria



--- src/frontend/parser_func.cpp ---
/**
 * src/frontend/parser_func.cpp
 * 
 * Aria Compiler - Function and Lambda Parser
 * Version: 0.0.6
 * 
 * Implements parsing logic for first-class functions, closures, and lambdas.
 * Handles the distinction between named function declarations and anonymous lambdas.
 * 
 * Grammar:
 *   FuncDecl -> "func" ("<" Generics ">")? ":" Identifier "=" "(" Params ")" "->" Type Block
 *   Lambda   -> "(" Params ")" "=>" ( Expr | Block )
 * 
 * Dependencies:
 * - parser.h: Base Parser class
 * - ast/expr.h: FuncExpr, LambdaExpr
 * - ast/decl.h: FuncDecl
 */

#include "parser.h"
#include "ast.h"
#include "tokens.h"
#include <vector>
#include <memory>
#include <string>

using namespace aria::frontend;

// Helper: Check if current token is a valid type token
bool Parser::isTypeToken(TokenType type) {
    return type == TOKEN_TYPE_IDENTIFIER ||
           type == TOKEN_TYPE_INT8 || type == TOKEN_TYPE_INT16 || 
           type == TOKEN_TYPE_INT32 || type == TOKEN_TYPE_INT64 ||
           type == TOKEN_TYPE_UINT8 || type == TOKEN_TYPE_UINT16 ||
           type == TOKEN_TYPE_UINT32 || type == TOKEN_TYPE_UINT64 ||
           type == TOKEN_TYPE_BOOL || type == TOKEN_TYPE_VOID ||
           type == TOKEN_TYPE_STRING || type == TOKEN_TYPE_RESULT ||
           type == TOKEN_TYPE_FUNC ||
           type == TOKEN_KW_FUNC ||  // func keyword can be used as type (func:name = ...)
           // Vector types
           type == TOKEN_TYPE_VEC2 || type == TOKEN_TYPE_VEC3 || type == TOKEN_TYPE_VEC4 || type == TOKEN_TYPE_VEC9 ||
           type == TOKEN_TYPE_DVEC2 || type == TOKEN_TYPE_DVEC3 || type == TOKEN_TYPE_DVEC4 ||
           type == TOKEN_TYPE_IVEC2 || type == TOKEN_TYPE_IVEC3 || type == TOKEN_TYPE_IVEC4 ||
           type == TOKEN_TYPE_UVEC2 || type == TOKEN_TYPE_UVEC3 || type == TOKEN_TYPE_UVEC4 ||
           type == TOKEN_TYPE_BVEC2 || type == TOKEN_TYPE_BVEC3 || type == TOKEN_TYPE_BVEC4 ||
           // Matrix types
           type == TOKEN_TYPE_MAT2 || type == TOKEN_TYPE_MAT3 || type == TOKEN_TYPE_MAT4 ||
           type == TOKEN_TYPE_MAT2X3 || type == TOKEN_TYPE_MAT2X4 || type == TOKEN_TYPE_MAT3X2 ||
           type == TOKEN_TYPE_MAT3X4 || type == TOKEN_TYPE_MAT4X2 || type == TOKEN_TYPE_MAT4X3 ||
           type == TOKEN_TYPE_DMAT2 || type == TOKEN_TYPE_DMAT3 || type == TOKEN_TYPE_DMAT4 ||
           type == TOKEN_TYPE_DMAT2X3 || type == TOKEN_TYPE_DMAT2X4 || type == TOKEN_TYPE_DMAT3X2 ||
           type == TOKEN_TYPE_DMAT3X4 || type == TOKEN_TYPE_DMAT4X2 || type == TOKEN_TYPE_DMAT4X3;
}

// Helper: Parse Parameter List: (type:name, type:name)
std::vector<FuncParam> Parser::parseParams() {
    std::vector<FuncParam> params;
    consume(TOKEN_LPAREN, "Expected '(' to begin parameter list");
    
    if (!check(TOKEN_RPAREN)) {
        do {
            // Parse Type (including memory qualifiers and pointer/array suffixes)
            // Note: In Aria, type comes first in params: "int:x", unlike "x int" in Go.
            // Can have optional wild/wildx qualifier: "wild int8@:ptr"
            
            std::string paramType = "";
            
            // Check for memory qualifier (wild, wildx)
            if (current.type == TOKEN_KW_WILD) {
                paramType = "wild ";
                advance();
            } else if (current.type == TOKEN_KW_WILDX) {
                paramType = "wildx ";
                advance();
            }
            
            // Now parse the rest of the type (base type + suffixes)
            paramType += parseTypeName();  // Handles base type and suffixes
            
            consume(TOKEN_COLON, "Expected ':' after type");
            Token nameTok = consume(TOKEN_IDENTIFIER, "Expected parameter name");
            
            params.emplace_back(paramType, nameTok.value, nullptr);
        } while (match(TOKEN_COMMA));
    }
    
    consume(TOKEN_RPAREN, "Expected ')' to end parameter list");
    return params;
}

// Parses: func<T>:name = (args) -> ret {... }
std::unique_ptr<FuncDecl> Parser::parseFuncDecl() {
    consume(TOKEN_KW_FUNC, "Expected 'func' keyword");

    // 1. Generics (Optional)
    // Supports: func<T, U>:name
    std::vector<std::string> generics;
    if (match(TOKEN_LT)) {
        do {
            Token genType = consume(TOKEN_TYPE_IDENTIFIER, "Expected generic type parameter");
            generics.push_back(genType.value);
        } while (match(TOKEN_COMMA));
        consume(TOKEN_GT, "Expected '>' after generics");
    }

    // 2. Name Binding
    consume(TOKEN_COLON, "Expected ':' before function name");
    Token nameToken = consume(TOKEN_IDENTIFIER, "Expected function name");

    // 3. Assignment (Functions are values in Aria)
    // Note: This syntax "func:name =" emphasizes first-class nature.
    // If no assignment, it is a prototype (e.g. inside interface or extern).
    if (match(TOKEN_ASSIGN)) {
        // Definition follows
    } else {
        // Prototype only (extern or interface)
        consume(TOKEN_SEMICOLON, "Expected ';' or '=' for function");
        // Return declarations with null body
        return std::make_unique<FuncDecl>(nameToken.value, generics, std::vector<FuncParam>(), "", nullptr);
    }

    // 4. Return Type (comes BEFORE parameters in new syntax)
    // New syntax: func:test = int8(int8:a, int8:b) { ... }
    std::string returnType = "void";
    if (current.type == TOKEN_TYPE_INT8 || current.type == TOKEN_TYPE_INT16 || 
        current.type == TOKEN_TYPE_INT32 || current.type == TOKEN_TYPE_INT64 ||
        current.type == TOKEN_TYPE_UINT8 || current.type == TOKEN_TYPE_UINT16 ||
        current.type == TOKEN_TYPE_UINT32 || current.type == TOKEN_TYPE_UINT64 ||
        current.type == TOKEN_TYPE_BOOL || current.type == TOKEN_TYPE_VOID ||
        current.type == TOKEN_IDENTIFIER || current.type == TOKEN_TYPE_STRING ||
        current.type == TOKEN_TYPE_RESULT ||
        // Vector types
        current.type == TOKEN_TYPE_VEC2 || current.type == TOKEN_TYPE_VEC3 || current.type == TOKEN_TYPE_VEC4 || current.type == TOKEN_TYPE_VEC9 ||
        current.type == TOKEN_TYPE_DVEC2 || current.type == TOKEN_TYPE_DVEC3 || current.type == TOKEN_TYPE_DVEC4 ||
        current.type == TOKEN_TYPE_IVEC2 || current.type == TOKEN_TYPE_IVEC3 || current.type == TOKEN_TYPE_IVEC4 ||
        current.type == TOKEN_TYPE_UVEC2 || current.type == TOKEN_TYPE_UVEC3 || current.type == TOKEN_TYPE_UVEC4 ||
        current.type == TOKEN_TYPE_BVEC2 || current.type == TOKEN_TYPE_BVEC3 || current.type == TOKEN_TYPE_BVEC4 ||
        // Matrix types
        current.type == TOKEN_TYPE_MAT2 || current.type == TOKEN_TYPE_MAT3 || current.type == TOKEN_TYPE_MAT4 ||
        current.type == TOKEN_TYPE_MAT2X3 || current.type == TOKEN_TYPE_MAT2X4 || current.type == TOKEN_TYPE_MAT3X2 ||
        current.type == TOKEN_TYPE_MAT3X4 || current.type == TOKEN_TYPE_MAT4X2 || current.type == TOKEN_TYPE_MAT4X3 ||
        current.type == TOKEN_TYPE_DMAT2 || current.type == TOKEN_TYPE_DMAT3 || current.type == TOKEN_TYPE_DMAT4 ||
        current.type == TOKEN_TYPE_DMAT2X3 || current.type == TOKEN_TYPE_DMAT2X4 || current.type == TOKEN_TYPE_DMAT3X2 ||
        current.type == TOKEN_TYPE_DMAT3X4 || current.type == TOKEN_TYPE_DMAT4X2 || current.type == TOKEN_TYPE_DMAT4X3) {
        returnType = current.value;
        advance();  // Consume the return type token
    } else {
        throw std::runtime_error("Expected return type before parameter list");
    }

    // 5. Parameters
    std::vector<FuncParam> params = parseParams();

    // 6. Body
    std::unique_ptr<Block> body = parseBlock();

    // 7. Semicolon (End of statement)
    // In Aria v0.0.6, top-level statements end with semicolons.
    match(TOKEN_SEMICOLON);

    auto decl = std::make_unique<FuncDecl>(nameToken.value, generics, std::move(params), returnType, std::move(body));
    
    // TODO: Register in Symbol Table when implemented
    // currentScope->define(decl->name, "func"); 

    return decl;
}

// Parses Lambda: (a, b) => expr
// Called by parseAtom or parsePrefix when logic detects lambda syntax.
std::unique_ptr<Expression> Parser::parseLambda() {
    // Note: Parsing lambdas is tricky because they start with '(', same as grouping.
    // The main parseExpression loop usually dispatches this via lookahead.
    
    // 1. Parameters
    // We reuse the parameter parsing logic, though lambdas might support type inference in v0.1.
    // For v0.0.6, explicit types are required in lambdas too.
    std::vector<FuncParam> params = parseParams();
    
    // 2. Arrow Operator
    consume(TOKEN_LAMBDA_ARROW, "Expected '=>' in lambda");
    
    // 3. Parse return type or infer from body
    std::string return_type = "void";  // Default, will be inferred by type checker
    
    // 4. Body (must be a block for LambdaExpr constructor)
    std::unique_ptr<Block> body;
    if (check(TOKEN_LEFT_BRACE)) {
        // Block Body: (args) => {... }
        body = parseBlock();
    } else {
        // Single expression body: (x) => x + 1
        // Wrap in a block with implicit return
        throw std::runtime_error("Expression-body lambdas not yet supported, use block syntax");
    }
    
    auto lambda = std::make_unique<LambdaExpr>(return_type, std::move(params), std::move(body));
    
    return lambda;
}



--- src/frontend/parser_stmt.cpp ---
// Implementation of Statement Parsing
// Handles: defer statements, block parsing, and loop statements
#include "parser.h"
#include "ast.h"
#include "ast/stmt.h"
#include "ast/defer.h"
#include "ast/loops.h"
#include <memory>
#include <sstream>
#include <stdexcept>
#include <cassert>
#include <cstdio>
#include <iostream>

namespace aria {
namespace frontend {

// Parse top-level program (file contents without { } wrapper)
std::unique_ptr<Block> Parser::parseProgram() {
    auto block = std::make_unique<Block>();
    
    // Parse top-level declarations until EOF
    while (current.type != TOKEN_EOF) {
        // Skip any stray semicolons
        if (match(TOKEN_SEMICOLON)) {
            continue;
        }
        
        // Check for function declaration (fn keyword)
        if (current.type == TOKEN_KW_FUNC) {
            auto func = parseFuncDecl();
            if (func) {
                block->statements.push_back(std::move(func));
            }
            continue;
        }
        
        // Check for public function
        if (current.type == TOKEN_KW_PUB) {
            advance();
            if (current.type == TOKEN_KW_FUNC) {
                auto func = parseFuncDecl();
                if (func) {
                    func->is_pub = true;
                    block->statements.push_back(std::move(func));
                }
            }
            continue;
        }
        
        // Check for async function
        if (current.type == TOKEN_KW_ASYNC) {
            advance();
            if (current.type == TOKEN_KW_FUNC) {
                auto func = parseFuncDecl();
                if (func) {
                    func->is_async = true;
                    block->statements.push_back(std::move(func));
                }
            }
            continue;
        }
        
        // Check for trait declaration: trait:Name = { ... }
        if (current.type == TOKEN_KW_TRAIT) {
            auto traitDecl = parseTraitDecl();
            if (traitDecl) {
                block->statements.push_back(std::move(traitDecl));
            }
            continue;
        }
        
        // Check for impl declaration: impl:Trait:for:Type = { ... }
        if (current.type == TOKEN_KW_IMPL) {
            auto implDecl = parseImplDecl();
            if (implDecl) {
                block->statements.push_back(std::move(implDecl));
            }
            continue;
        }
        
        // Check for struct declaration: const Name = struct { ... }
        if (current.type == TOKEN_KW_CONST || current.type == TOKEN_IDENTIFIER) {
            // Save position to check if this is a struct declaration
            Token saved = current;
            
            // Skip optional const
            if (current.type == TOKEN_KW_CONST) {
                advance();
            }
            
            // Check pattern: Identifier = struct
            if (current.type == TOKEN_IDENTIFIER) {
                Token name = current;
                advance();
                
                if (current.type == TOKEN_ASSIGN) {
                    advance();
                    
                    if (current.type == TOKEN_KW_STRUCT) {
                        // This is a struct declaration! Restore to saved position and parse
                        current = saved;  // Restore position
                        auto structDecl = parseStructDecl();
                        if (structDecl) {
                            block->statements.push_back(std::move(structDecl));
                        }
                        continue;
                    }
                }
            }
            
            // Not a struct, restore position and continue to error handler
            current = saved;
        }
        
        // TODO: type, use, mod, extern declarations
        // For now, treat unrecognized top-level as error
        std::stringstream ss;
        ss << "Unexpected token at top level: " << current.value
           << " (type " << current.type << ") at line " << current.line;
        throw std::runtime_error(ss.str());
    }
    
    return block;
}

std::unique_ptr<Statement> Parser::parseDeferStmt() {
    // defer { ... }
    expect(TOKEN_KW_DEFER);
    
    // Parse the defer body as a block
    auto body = parseBlock();
    
    return std::make_unique<DeferStmt>(std::move(body));
}

// Parse while loop: while (condition) { ... }
std::unique_ptr<Statement> Parser::parseWhileLoop() {
    expect(TOKEN_KW_WHILE);
    expect(TOKEN_LPAREN);
    auto condition = parseExpr();
    expect(TOKEN_RPAREN);
    auto body = parseBlockOrStatement();
    
    return std::make_unique<WhileLoop>(std::move(condition), std::move(body));
}

// Parse for loop: for x in collection { ... }
std::unique_ptr<Statement> Parser::parseForLoop() {
    expect(TOKEN_KW_FOR);
    
    Token iter_token = expect(TOKEN_IDENTIFIER);
    std::string iterator_name = iter_token.value;
    
    expect(TOKEN_KW_IN);
    auto iterable = parseExpr();
    
    auto body = parseBlockOrStatement();
    
    return std::make_unique<ForLoop>(iterator_name, std::move(iterable), std::move(body));
}

// Parse till loop: till(limit, step) { ... }
std::unique_ptr<Statement> Parser::parseTillLoop() {
    expect(TOKEN_KW_TILL);
    expect(TOKEN_LPAREN);
    
    auto limit = parseExpr();
    
    // Step is optional, defaults to 1
    std::unique_ptr<Expression> step = std::make_unique<IntLiteral>(1);
    if (match(TOKEN_COMMA)) {
        step = parseExpr();
    }
    
    expect(TOKEN_RPAREN);
    auto body = parseBlockOrStatement();
    
    return std::make_unique<TillLoop>(std::move(limit), std::move(step), std::move(body));
}

// Parse when loop: when(condition) { ... }
// Note: when is a conditional loop that keeps iterating while condition is true
std::unique_ptr<Statement> Parser::parseWhenLoop() {
    expect(TOKEN_KW_WHEN);
    expect(TOKEN_LPAREN);
    auto condition = parseExpr();
    expect(TOKEN_RPAREN);
    auto body = parseBlockOrStatement();
    
    // For now, treat when loop as while loop (they're semantically similar)
    return std::make_unique<WhileLoop>(std::move(condition), std::move(body));
}

// Parse break statement: break; or break(label);
std::unique_ptr<Statement> Parser::parseBreak() {
    expect(TOKEN_KW_BREAK);
    
    std::string label = "";
    if (match(TOKEN_LPAREN)) {
        Token label_token = expect(TOKEN_IDENTIFIER);
        label = label_token.value;
        expect(TOKEN_RPAREN);
    }
    
    match(TOKEN_SEMICOLON);  // Optional semicolon
    return std::make_unique<BreakStmt>(label);
}

// Parse continue statement: continue; or continue(label);
std::unique_ptr<Statement> Parser::parseContinue() {
    expect(TOKEN_KW_CONTINUE);
    
    std::string label = "";
    if (match(TOKEN_LPAREN)) {
        Token label_token = expect(TOKEN_IDENTIFIER);
        label = label_token.value;
        expect(TOKEN_RPAREN);
    }
    
    match(TOKEN_SEMICOLON);  // Optional semicolon
    return std::make_unique<ContinueStmt>(label);
}

std::unique_ptr<Block> Parser::parseBlock() {
    expect(TOKEN_LBRACE);
    
    auto block = std::make_unique<Block>();
    
    // Parse statements until we hit }
    while (current.type != TOKEN_RBRACE && current.type != TOKEN_EOF) {
        // Check for function declaration
        if (current.type == TOKEN_KW_FUNC || 
            current.type == TOKEN_KW_PUB ||
            current.type == TOKEN_KW_ASYNC) {
            auto func = parseFuncDecl();
            if (func) {
                block->statements.push_back(std::move(func));
            }
            continue;
        }
        
        // Check for struct declaration: const Name = struct { ... }
        if (current.type == TOKEN_KW_CONST || current.type == TOKEN_IDENTIFIER) {
            std::cerr << "DEBUG parseBlock: Checking for struct, current=" << current.value 
                      << " type=" << static_cast<int>(current.type) << std::endl;
            Token saved = current;
            
            if (current.type == TOKEN_KW_CONST) {
                advance();
                std::cerr << "DEBUG: After CONST, current=" << current.value << std::endl;
            }
            
            if (current.type == TOKEN_IDENTIFIER) {
                Token name = current;
                advance();
                std::cerr << "DEBUG: After IDENTIFIER, current=" << current.value << std::endl;
                
                if (current.type == TOKEN_ASSIGN) {
                    advance();
                    std::cerr << "DEBUG: After ASSIGN, current=" << current.value << std::endl;
                    
                    if (current.type == TOKEN_KW_STRUCT) {
                        std::cerr << "DEBUG: Found STRUCT keyword! Calling parseStructDecl()" << std::endl;
                        // This is a struct declaration
                        current = saved;
                        auto structDecl = parseStructDecl();
                        if (structDecl) {
                            block->statements.push_back(std::move(structDecl));
                        }
                        continue;
                    }
                }
            }
            
            // Not a struct, restore and parse as statement
            std::cerr << "DEBUG: Not a struct, restoring position" << std::endl;
            current = saved;
        }
        
        auto stmt = parseStmt();
        if (stmt) {
            block->statements.push_back(std::move(stmt));
        }
    }
    
    expect(TOKEN_RBRACE);
    return block;
}

// Parse either a block {...} or a single statement
// Used for if/else/while/for bodies to allow one-liner syntax
std::unique_ptr<Block> Parser::parseBlockOrStatement() {
    if (current.type == TOKEN_LBRACE) {
        return parseBlock();
    } else {
        // Single statement - wrap it in a block
        auto block = std::make_unique<Block>();
        auto stmt = parseStmt();
        if (stmt) {
            block->statements.push_back(std::move(stmt));
        }
        return block;
    }
}

// Parse variable declaration: type:name = value;
std::unique_ptr<Statement> Parser::parseVarDecl() {
    // Current token should be a type
    if (!isTypeToken(current.type)) {
        std::stringstream ss;
        ss << "Expected type token for variable declaration at line " << current.line;
        throw std::runtime_error(ss.str());
    }
    
    std::string type = current.value;
    advance();
    
    // Parse type suffixes (arrays [], pointers @)
    type = parseTypeSuffixes(type);
    
    // Expect colon
    expect(TOKEN_COLON);
    
    // Expect identifier
    Token name_token = expect(TOKEN_IDENTIFIER);
    std::string name = name_token.value;
    
    // Optional initializer
    std::unique_ptr<Expression> initializer = nullptr;
    if (match(TOKEN_ASSIGN)) {
        initializer = parseExpr();
    }
    
    // Optional semicolon
    match(TOKEN_SEMICOLON);
    
    return std::make_unique<VarDecl>(type, name, std::move(initializer));
}

std::unique_ptr<Statement> Parser::parseStmt() {
    // Handle various statement types
    assert(false && "DEBUG: parseStmt called");
    printf("DEBUG parseStmt: current=%s (type %d)\n", current.value.c_str(), static_cast<int>(current.type));
    fflush(stdout);
    
    // Struct declaration: const Name = struct { ... }
    if (current.type == TOKEN_KW_CONST || current.type == TOKEN_IDENTIFIER) {
        printf("DEBUG parseStmt: Checking struct lookahead\n"); fflush(stdout);
        Token saved = current;
        
        if (current.type == TOKEN_KW_CONST) {
            advance();
            printf("DEBUG parseStmt: After const, current=%s\n", current.value.c_str()); fflush(stdout);
        }
        
        if (current.type == TOKEN_IDENTIFIER) {
            Token name = current;
            advance();
            printf("DEBUG parseStmt: After identifier, current=%s\n", current.value.c_str()); fflush(stdout);
            
            if (current.type == TOKEN_ASSIGN) {
                advance();
                printf("DEBUG parseStmt: After assign, current=%s\n", current.value.c_str()); fflush(stdout);
                
                if (current.type == TOKEN_KW_STRUCT) {
                    // This is a struct declaration
                    printf("DEBUG parseStmt: FOUND STRUCT! Calling parseStructDecl\n"); fflush(stdout);
                    current = saved;
                    return parseStructDecl();
                }
            }
        }
        
        // Not a struct, restore position
        printf("DEBUG parseStmt: Not a struct, restoring\n"); fflush(stdout);
        current = saved;
    }
    
    // Variable declaration: type:name = value;
    if (isTypeToken(current.type)) {
        return parseVarDecl();
    }
    
    // Return statement
    if (match(TOKEN_KW_RETURN)) {
        std::unique_ptr<Expression> retVal = nullptr;
        if (current.type != TOKEN_SEMICOLON && current.type != TOKEN_RBRACE) {
            retVal = parseExpr();
        }
        match(TOKEN_SEMICOLON);  // Optional semicolon
        return std::make_unique<ReturnStmt>(std::move(retVal));
    }
    
    // fail(errorCode) - Syntactic sugar for return {err:errorCode, val:0}
    if (match(TOKEN_KW_FAIL)) {
        expect(TOKEN_LPAREN);
        auto errorCode = parseExpr();
        expect(TOKEN_RPAREN);
        match(TOKEN_SEMICOLON);  // Optional semicolon
        
        // Create: {err: errorCode, val: 0}
        auto obj = std::make_unique<ObjectLiteral>();
        
        ObjectLiteral::Field errField;
        errField.name = "err";
        errField.value = std::move(errorCode);
        obj->fields.push_back(std::move(errField));
        
        ObjectLiteral::Field valField;
        valField.name = "val";
        valField.value = std::make_unique<IntLiteral>(0);
        obj->fields.push_back(std::move(valField));
        
        return std::make_unique<ReturnStmt>(std::move(obj));
    }
    
    // pass(value) - Syntactic sugar for return {err:0, val:value}
    if (match(TOKEN_KW_PASS)) {
        expect(TOKEN_LPAREN);
        auto value = parseExpr();
        expect(TOKEN_RPAREN);
        match(TOKEN_SEMICOLON);  // Optional semicolon
        
        // Create: {err: 0, val: value}
        auto obj = std::make_unique<ObjectLiteral>();
        
        ObjectLiteral::Field errField;
        errField.name = "err";
        errField.value = std::make_unique<IntLiteral>(0);
        obj->fields.push_back(std::move(errField));
        
        ObjectLiteral::Field valField;
        valField.name = "val";
        valField.value = std::move(value);
        obj->fields.push_back(std::move(valField));
        
        return std::make_unique<ReturnStmt>(std::move(obj));
    }
    
    // If statement
    if (match(TOKEN_KW_IF)) {
        expect(TOKEN_LPAREN);
        auto condition = parseExpr();
        expect(TOKEN_RPAREN);
        auto then_block = parseBlockOrStatement();
        
        std::unique_ptr<Block> else_block = nullptr;
        if (match(TOKEN_KW_ELSE)) {
            else_block = parseBlockOrStatement();
        }
        
        return std::make_unique<IfStmt>(std::move(condition), std::move(then_block), std::move(else_block));
    }
    
    // Loop statements
    if (current.type == TOKEN_KW_WHILE) {
        return parseWhileLoop();
    }
    if (current.type == TOKEN_KW_FOR) {
        return parseForLoop();
    }
    if (current.type == TOKEN_KW_TILL) {
        return parseTillLoop();
    }
    if (current.type == TOKEN_KW_WHEN) {
        return parseWhenLoop();
    }
    if (current.type == TOKEN_KW_BREAK) {
        return parseBreak();
    }
    if (current.type == TOKEN_KW_CONTINUE) {
        return parseContinue();
    }
    
    // Pick statement (pattern matching)
    if (current.type == TOKEN_KW_PICK) {
        return parsePickStmt();
    }
    
    // Defer statement
    if (current.type == TOKEN_KW_DEFER) {
        return parseDeferStmt();
    }
    
    // Variable declaration or expression statement
    // Try to parse as expression first
    auto expr = parseExpr();
    match(TOKEN_SEMICOLON);  // Optional semicolon
    return std::make_unique<ExpressionStmt>(std::move(expr));
}

} // namespace frontend
} // namespace aria



--- src/frontend/parser_struct.cpp ---
#include "parser.h"
#include "ast/stmt.h"
#include <stdexcept>
#include <iostream>

namespace aria {
namespace frontend {

// Parse struct declaration
// Grammar: const StructName = struct { field: type, field: type, };
// Example: const Point = struct { x: int64, y: int64, };
std::unique_ptr<StructDecl> Parser::parseStructDecl() {
    // 1. Check for optional 'const' (structs are typically const type definitions)
    bool is_const = false;
    if (match(TOKEN_KW_CONST)) {
        is_const = true;
    }
    
    // 2. Parse struct name (identifier)
    Token name_tok = expect(TOKEN_IDENTIFIER);
    std::string struct_name = name_tok.value;
    
    // 3. Expect assignment operator
    expect(TOKEN_ASSIGN);
    
    // 4. Expect 'struct' keyword
    expect(TOKEN_KW_STRUCT);
    
    // 5. Expect opening brace
    expect(TOKEN_LBRACE);
    
    // 6. Parse fields and methods
    std::vector<StructField> fields;
    std::vector<std::unique_ptr<FuncDecl>> methods;
    
    while (!check(TOKEN_RBRACE) && current.type != TOKEN_EOF) {
        // Peek ahead to determine if this is a field or method
        // Field syntax: name:type,
        // Method syntax: func:name = returnType(...) { ... },
        
        // Check for func:name pattern
        if (current.type == TOKEN_IDENTIFIER && current.value == "func") {
            // This is a method declaration
            advance(); // consume 'func'
            expect(TOKEN_COLON);
            
            // Parse method name
            Token method_name_tok = expect(TOKEN_IDENTIFIER);
            std::string method_name = method_name_tok.value;
            
            expect(TOKEN_ASSIGN);
            
            // Parse return type (handles * prefix for result types)
            std::string return_type = parseTypeName();
            
            // Parse parameter list
            expect(TOKEN_LPAREN);
            std::vector<FuncParam> params;
            
            while (!check(TOKEN_RPAREN) && current.type != TOKEN_EOF) {
                // Check for special 'self' parameter
                if (current.type == TOKEN_IDENTIFIER && current.value == "self") {
                    // self parameter - type is implicitly the struct being defined
                    advance(); // consume 'self'
                    
                    // Add self as first parameter with struct type
                    params.emplace_back(struct_name, "self", nullptr);
                } else {
                    // Regular parameter: type:name
                    Token param_type = current;
                    advance();
                    expect(TOKEN_COLON);
                    Token param_name = expect(TOKEN_IDENTIFIER);
                    
                    params.emplace_back(param_type.value, param_name.value, nullptr);
                }
                
                if (!check(TOKEN_RPAREN)) {
                    expect(TOKEN_COMMA);
                }
            }
            
            expect(TOKEN_RPAREN);
            
            // Parse method body
            auto body = parseBlock();
            
            // Create FuncDecl for the method
            std::vector<std::string> no_generics;  // Methods don't have generic params (struct might)
            auto method_decl = std::make_unique<FuncDecl>(
                method_name,
                no_generics,
                std::move(params),
                return_type,
                std::move(body)
            );
            
            methods.push_back(std::move(method_decl));
            
            // Check if there's a comma (optional trailing comma)
            match(TOKEN_COMMA);
            
            continue;
        }
        
        // Otherwise, parse as a field
        // Parse field name
        Token field_name = expect(TOKEN_IDENTIFIER);
        
        // Expect colon
        expect(TOKEN_COLON);
        
        // Parse field type - can be any type token or identifier (for user-defined types)
        if (current.type < TOKEN_TYPE_VOID || current.type > TOKEN_TYPE_STRING) {
            if (current.type != TOKEN_IDENTIFIER) {
                throw std::runtime_error("Expected type for struct field at line " + 
                                       std::to_string(current.line));
            }
        }
        Token field_type = current;
        advance();  // consume type token
        
        // Handle array types: field: int8[256] or int64[]
        std::string type_name = field_type.value;
        if (check(TOKEN_LBRACKET)) {
            advance(); // consume [
            type_name += "[";
            
            // Check for array size
            if (!check(TOKEN_RBRACKET)) {
                Token size_tok = expect(TOKEN_INT_LITERAL);
                type_name += size_tok.value;
            }
            
            expect(TOKEN_RBRACKET);
            type_name += "]";
        }
        
        // Add field to list
        fields.emplace_back(type_name, field_name.value);
        
        // Expect comma unless this is the last field (next token is })
        if (!check(TOKEN_RBRACE)) {
            expect(TOKEN_COMMA);
        }
    }
    
    // 7. Expect closing brace
    expect(TOKEN_RBRACE);
    
    // 8. Expect semicolon (end of statement)
    expect(TOKEN_SEMICOLON);
    
    // 9. Create and return AST node
    auto decl = std::make_unique<StructDecl>(struct_name, std::move(fields));
    decl->is_const = is_const;
    decl->methods = std::move(methods);  // Add methods to struct
    
    return decl;
}

} // namespace frontend
} // namespace aria



--- src/frontend/parser_trait.cpp ---
// Implementation of Trait System Parsing
// Handles trait declarations and trait implementations
#include "parser.h"
#include "ast.h"
#include "ast/stmt.h"
#include <memory>
#include <sstream>
#include <stdexcept>

namespace aria {
namespace frontend {

// Parse trait declaration
// Syntax: trait:Name = { method_name:(params) -> return_type, ... }
// Or with super traits: trait:Name:SuperTrait1:SuperTrait2 = { ... }
std::unique_ptr<TraitDecl> Parser::parseTraitDecl() {
    // Expect TOKEN_KW_TRAIT
    if (current.type != TOKEN_KW_TRAIT) {
        throw std::runtime_error("Expected 'trait' keyword");
    }
    advance();
    
    // Expect colon
    if (!match(TOKEN_COLON)) {
        throw std::runtime_error("Expected ':' after 'trait'");
    }
    
    // Parse trait name
    if (current.type != TOKEN_IDENTIFIER) {
        throw std::runtime_error("Expected trait name after 'trait:'");
    }
    std::string traitName = current.value;
    advance();
    
    // Parse optional super traits: :SuperTrait1:SuperTrait2
    std::vector<std::string> superTraits;
    while (current.type == TOKEN_COLON && peek().type != TOKEN_ASSIGN) {
        advance(); // consume ':'
        
        if (current.type != TOKEN_IDENTIFIER) {
            throw std::runtime_error("Expected super trait name after ':'");
        }
        
        superTraits.push_back(current.value);
        advance();
    }
    
    // Expect assignment
    if (!match(TOKEN_ASSIGN)) {
        throw std::runtime_error("Expected '=' after trait name");
    }
    
    // Expect opening brace
    if (!match(TOKEN_LBRACE)) {
        throw std::runtime_error("Expected '{' to begin trait body");
    }
    
    // Parse trait methods
    std::vector<TraitMethod> methods;
    while (current.type != TOKEN_RBRACE && current.type != TOKEN_EOF) {
        // Skip commas between method signatures
        if (match(TOKEN_COMMA)) {
            continue;
        }
        
        // Parse method name
        if (current.type != TOKEN_IDENTIFIER) {
            throw std::runtime_error("Expected method name in trait");
        }
        std::string methodName = current.value;
        advance();
        
        // Expect colon before parameters
        if (!match(TOKEN_COLON)) {
            throw std::runtime_error("Expected ':' after method name");
        }
        
        // Parse parameters
        if (!match(TOKEN_LPAREN)) {
            throw std::runtime_error("Expected '(' to begin method parameters");
        }
        
        // Parameter list
        std::vector<FuncParam> params;
        
        // Parse parameter list
        while (current.type != TOKEN_RPAREN && current.type != TOKEN_EOF) {
            // Skip commas
            if (match(TOKEN_COMMA)) {
                continue;
            }
            
            // Parse parameter name
            if (current.type != TOKEN_IDENTIFIER) {
                throw std::runtime_error("Expected parameter name");
            }
            std::string paramName = current.value;
            advance();
            
            // Expect colon
            if (!match(TOKEN_COLON)) {
                throw std::runtime_error("Expected ':' after parameter name");
            }
            
            // Parse parameter type
            std::string paramType = parseTypeName();
            
            // Add parameter (no auto_wrap at param level)
            params.emplace_back(paramType, paramName, nullptr);
        }
        
        // Expect closing paren
        if (!match(TOKEN_RPAREN)) {
            throw std::runtime_error("Expected ')' to end method parameters");
        }
        
        // Parse optional return type
        std::string returnType = "void";
        if (match(TOKEN_ARROW)) {
            returnType = parseTypeName();
        }
        
        // Create TraitMethod
        TraitMethod method(methodName, std::move(params), returnType);
        
        // Check if entire method signature is marked auto_wrap
        if (current.type == TOKEN_IDENTIFIER && current.value == "auto_wrap") {
            method.auto_wrap = true;
            advance();
        }
        
        methods.push_back(std::move(method));
    }
    
    // Expect closing brace
    if (!match(TOKEN_RBRACE)) {
        throw std::runtime_error("Expected '}' to end trait body");
    }
    
    auto trait = std::make_unique<TraitDecl>(traitName, std::move(methods));
    trait->super_traits = std::move(superTraits);
    return trait;
}

// Parse trait implementation
// Syntax: impl:TraitName:for:TypeName = { method implementations }
std::unique_ptr<ImplDecl> Parser::parseImplDecl() {
    // Expect TOKEN_KW_IMPL
    if (current.type != TOKEN_KW_IMPL) {
        throw std::runtime_error("Expected 'impl' keyword");
    }
    advance();
    
    // Expect colon
    if (!match(TOKEN_COLON)) {
        throw std::runtime_error("Expected ':' after 'impl'");
    }
    
    // Parse trait name
    if (current.type != TOKEN_IDENTIFIER) {
        throw std::runtime_error("Expected trait name after 'impl:'");
    }
    std::string traitName = current.value;
    advance();
    
    // Expect :for:
    if (!match(TOKEN_COLON)) {
        throw std::runtime_error("Expected ':for:' in impl declaration");
    }
    
    if (current.type != TOKEN_IDENTIFIER || current.value != "for") {
        throw std::runtime_error("Expected 'for' keyword in impl declaration");
    }
    advance();
    
    if (!match(TOKEN_COLON)) {
        throw std::runtime_error("Expected ':' after 'for'");
    }
    
    // Parse type name
    if (current.type != TOKEN_IDENTIFIER) {
        throw std::runtime_error("Expected type name after 'for:'");
    }
    std::string typeName = current.value;
    advance();
    
    // Expect assignment
    if (!match(TOKEN_ASSIGN)) {
        throw std::runtime_error("Expected '=' after impl declaration");
    }
    
    // Expect opening brace
    if (!match(TOKEN_LBRACE)) {
        throw std::runtime_error("Expected '{' to begin impl body");
    }
    
    // Parse method implementations
    std::vector<std::unique_ptr<FuncDecl>> methods;
    while (current.type != TOKEN_RBRACE && current.type != TOKEN_EOF) {
        // Skip commas
        if (match(TOKEN_COMMA)) {
            continue;
        }
        
        // Parse function declaration (method implementation)
        // Methods in impl blocks are regular function declarations
        if (current.type == TOKEN_KW_FUNC || current.type == TOKEN_IDENTIFIER) {
            auto method = parseFuncDecl();
            if (method) {
                methods.push_back(std::move(method));
            }
        } else {
            throw std::runtime_error("Expected method implementation in impl block");
        }
    }
    
    // Expect closing brace
    if (!match(TOKEN_RBRACE)) {
        throw std::runtime_error("Expected '}' to end impl body");
    }
    
    return std::make_unique<ImplDecl>(traitName, typeName, std::move(methods));
}

} // namespace frontend
} // namespace aria
