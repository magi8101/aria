===================================
ARIA COMPILER SOURCE - PART 5b of 11
Frontend: Trait & Borrow Checking
===================================

--- src/frontend/sema/trait_checker.cpp ---
/**
 * src/frontend/sema/trait_checker.cpp
 *
 * Trait System Type Checking
 * Validates trait declarations and implementations
 */

#include "type_checker.h"
#include "../ast.h"
#include "../ast/stmt.h"
#include <algorithm>
#include <functional>
#include <sstream>

namespace aria {
namespace sema {

// Visit trait declaration
// Register the trait and validate it has no duplicate method names
void TypeChecker::visit(frontend::TraitDecl* node) {
    // Check if trait name is already registered
    if (trait_table.find(node->name) != trait_table.end()) {
        std::stringstream ss;
        ss << "Trait '" << node->name << "' is already defined";
        addError(ss.str());
        return;
    }
    
    // Validate super traits exist
    for (const auto& super_trait_name : node->super_traits) {
        if (trait_table.find(super_trait_name) == trait_table.end()) {
            std::stringstream ss;
            ss << "Super trait '" << super_trait_name << "' not found for trait '" << node->name << "'";
            addError(ss.str());
        }
    }
    
    // Check for duplicate method names in trait
    std::set<std::string> method_names;
    for (const auto& method : node->methods) {
        if (method_names.find(method.name) != method_names.end()) {
            std::stringstream ss;
            ss << "Duplicate method '" << method.name << "' in trait '" << node->name << "'";
            addError(ss.str());
        }
        method_names.insert(method.name);
    }
    
    // Register trait
    trait_table[node->name] = node;
}

// Visit trait implementation
// Validate the impl satisfies all trait requirements
void TypeChecker::visit(frontend::ImplDecl* node) {
    // Check if trait exists
    auto trait_it = trait_table.find(node->trait_name);
    if (trait_it == trait_table.end()) {
        std::stringstream ss;
        ss << "Trait '" << node->trait_name << "' not found in impl";
        addError(ss.str());
        return;
    }
    
    frontend::TraitDecl* trait = trait_it->second;
    
    // Check if type exists (for structs)
    if (!isRegisteredStruct(node->type_name)) {
        // TODO: Also check for primitive types and other type aliases
        // For now, just warn but allow it (could be a primitive or generic)
        // std::stringstream ss;
        // ss << "Type '" << node->type_name << "' not found in impl";
        // addError(ss.str());
    }
    
    // Build a map of implemented methods
    std::map<std::string, frontend::FuncDecl*> impl_methods;
    for (const auto& method : node->methods) {
        impl_methods[method->name] = method.get();
    }
    
    // Collect all required methods from trait and super traits
    std::vector<frontend::TraitMethod> required_methods;
    
    // Helper function to collect methods from a trait and its super traits
    std::function<void(frontend::TraitDecl*)> collect_trait_methods;
    collect_trait_methods = [&](frontend::TraitDecl* t) {
        // Add methods from this trait
        for (const auto& method : t->methods) {
            // Deep copy parameters
            std::vector<frontend::FuncParam> copied_params;
            for (const auto& param : method.parameters) {
                copied_params.emplace_back(param.type, param.name, nullptr);
            }
            required_methods.emplace_back(method.name, std::move(copied_params), method.return_type);
            required_methods.back().auto_wrap = method.auto_wrap;
        }
        
        // Recursively add methods from super traits
        for (const auto& super_name : t->super_traits) {
            auto super_it = trait_table.find(super_name);
            if (super_it != trait_table.end()) {
                collect_trait_methods(super_it->second);
            }
        }
    };
    
    collect_trait_methods(trait);
    
    // Validate all required methods are implemented
    for (const auto& required : required_methods) {
        auto impl_it = impl_methods.find(required.name);
        
        if (impl_it == impl_methods.end()) {
            std::stringstream ss;
            ss << "Missing implementation of method '" << required.name 
               << "' in impl of trait '" << node->trait_name 
               << "' for type '" << node->type_name << "'";
            addError(ss.str());
            continue;
        }
        
        frontend::FuncDecl* impl_method = impl_it->second;
        
        // Validate method signature matches trait signature
        // Check return type
        if (impl_method->return_type != required.return_type) {
            std::stringstream ss;
            ss << "Return type mismatch for method '" << required.name 
               << "' in impl: expected '" << required.return_type 
               << "', got '" << impl_method->return_type << "'";
            addError(ss.str());
        }
        
        // Check parameter count
        if (impl_method->parameters.size() != required.parameters.size()) {
            std::stringstream ss;
            ss << "Parameter count mismatch for method '" << required.name 
               << "' in impl: expected " << required.parameters.size() 
               << ", got " << impl_method->parameters.size();
            addError(ss.str());
            continue;
        }
        
        // Check parameter types
        for (size_t i = 0; i < required.parameters.size(); ++i) {
            if (impl_method->parameters[i].type != required.parameters[i].type) {
                std::stringstream ss;
                ss << "Parameter type mismatch for method '" << required.name 
                   << "' parameter '" << required.parameters[i].name 
                   << "': expected '" << required.parameters[i].type 
                   << "', got '" << impl_method->parameters[i].type << "'";
                addError(ss.str());
            }
        }
        
        // Type check the method body
        if (impl_method->body) {
            visit(impl_method->body.get());
        }
    }
    
    // Check for extra methods not in trait (warn but allow)
    for (const auto& [method_name, method] : impl_methods) {
        bool found = false;
        for (const auto& required : required_methods) {
            if (required.name == method_name) {
                found = true;
                break;
            }
        }
        
        if (!found) {
            // This is allowed - impl can have additional methods
            // Just document it for now
        }
    }
    
    // Register implementation
    impl_table.insert({node->trait_name, node});
}

} // namespace sema
} // namespace aria



--- src/frontend/sema/borrow_checker.h ---
/**
 * src/frontend/sema/borrow_checker.h
 * 
 * Aria Compiler - Borrow Checker Header
 * Version: 0.0.6
 * 
 * Public interface for the Aria borrow checker which enforces:
 * - Lifetime Analysis: Safe References ($) must not outlive Pinned (#) hosts
 * - Wild Safety: Detect Use-After-Free errors for manual memory
 * - Pinning Enforcement: Prevent movement of pinned objects
 * - Type Validation: Ensure strict typing rules
 */

#ifndef ARIA_FRONTEND_SEMA_BORROW_CHECKER_H
#define ARIA_FRONTEND_SEMA_BORROW_CHECKER_H

namespace aria {
namespace frontend {
    // Forward declaration
    class Block;
}

namespace sema {

/**
 * Run borrow checking analysis on the AST.
 * 
 * @param root The root Block node of the AST to analyze
 * @return true if borrow checking passed without errors, false otherwise
 */
bool check_borrow_rules(aria::frontend::Block* root);

} // namespace sema
} // namespace aria

#endif // ARIA_FRONTEND_SEMA_BORROW_CHECKER_H



--- src/frontend/sema/borrow_checker.cpp ---
/**
 * src/frontend/sema/borrow_checker.cpp
 * 
 * Aria Compiler - Borrow Checker Implementation
 * Version: 0.0.7 (Enhanced with Flow-Sensitive Lifetime Analysis)
 * 
 * Implements Aria's "Appendage Theory" memory safety model:
 * - Wild pointers: Must be explicitly freed or deferred
 * - Pinned values (#): Cannot be moved once pinned
 * - Safe references ($): Must not outlive their pinned hosts
 * - Stack allocations: Proper lifetime tracking with scope depth
 * 
 * CRITICAL ENHANCEMENT (v0.0.7):
 * Flow-sensitive lifetime analysis prevents dangling references by tracking:
 * 1. Scope depth for every variable declaration
 * 2. Reference → host relationships with transitive tracking
 * 3. Lifetime rules: host.depth <= ref.depth (host must live longer)
 */

#include "borrow_checker.h"
#include "../ast.h"
#include "../ast/stmt.h"
#include "../ast/expr.h"
#include "../ast/control_flow.h"
#include "../ast/defer.h"
#include "../ast/loops.h"
#include <unordered_set>
#include <unordered_map>
#include <string>
#include <iostream>

namespace aria {
namespace sema {

// Enhanced Borrow Checker Context with Flow-Sensitive Lifetime Analysis
struct BorrowContext {
    // Legacy tracking (maintained for compatibility)
    std::unordered_set<std::string> wild_allocations;  // Track wild allocations needing free
    std::unordered_set<std::string> pinned_values;     // Track pinned values (cannot move)
    std::unordered_set<std::string> deferred_frees;    // Track deferred deallocations
    
    // FLOW-SENSITIVE LIFETIME TRACKING (v0.0.7)
    // Maps variable name → scope depth where it was declared
    // Depth 0 = global, 1 = function body, 2 = inner block, etc.
    std::unordered_map<std::string, int> var_depths;
    
    // Maps safe reference ($) → host variable name
    // Used to track reference origins for lifetime validation
    std::unordered_map<std::string, std::string> reference_origins;
    
    // Current scope depth (incremented on enterScope, decremented on exitScope)
    int current_depth = 0;
    
    // Error tracking
    bool has_errors = false;
    
    void error(const std::string& msg) {
        std::cerr << "Borrow Check Error: " << msg << std::endl;
        has_errors = true;
    }
    
    void warning(const std::string& msg) {
        std::cerr << "Borrow Check Warning: " << msg << std::endl;
    }
    
    // SCOPE MANAGEMENT
    void enterScope() {
        current_depth++;
    }
    
    void exitScope() {
        // Clean up variables declared at this depth
        // They are going out of scope
        for (auto it = var_depths.begin(); it != var_depths.end();) {
            if (it->second == current_depth) {
                // Remove from all tracking maps
                wild_allocations.erase(it->first);
                pinned_values.erase(it->first);
                reference_origins.erase(it->first);
                it = var_depths.erase(it);
            } else {
                ++it;
            }
        }
        current_depth--;
    }
    
    // VARIABLE DECLARATION TRACKING
    void declare(const std::string& name) {
        var_depths[name] = current_depth;
    }
    
    // LIFETIME VALIDATION
    // Check if 'ref' (a safe reference) can safely point to 'host'
    // Rule: host must live at least as long as ref
    // Implementation: host.depth <= ref.depth
    void checkLifetime(const std::string& ref, const std::string& host) {
        // If host is not tracked, it might be global or a parameter
        if (var_depths.find(host) == var_depths.end()) {
            // Assume it's safe (global or function parameter)
            return;
        }
        
        // If ref is not tracked, it's being declared now
        int ref_depth = (var_depths.find(ref) != var_depths.end()) 
                       ? var_depths[ref] 
                       : current_depth;
        
        int host_depth = var_depths[host];
        
        // Appendage Theory Violation: Reference outlives host
        if (host_depth > ref_depth) {
            error("Appendage Theory Violation: Reference '" + ref + 
                  "' (declared at depth " + std::to_string(ref_depth) + 
                  ") refers to host '" + host + 
                  "' (declared at depth " + std::to_string(host_depth) + 
                  ") which has a shorter lifetime. " +
                  "The reference would outlive its host, creating a dangling pointer.");
        }
    }
};

// Forward declarations
void checkStatement(frontend::Statement* stmt, BorrowContext& ctx);
void checkExpression(frontend::Expression* expr, BorrowContext& ctx);

// Check if a variable declaration uses wild allocation
void checkVarDecl(frontend::VarDecl* decl, BorrowContext& ctx) {
    if (!decl) return;
    
    // Register this variable at the current scope depth
    ctx.declare(decl->name);
    
    // Check for wild allocation modifier
    if (decl->is_wild) {
        ctx.wild_allocations.insert(decl->name);
        // Wild allocations should have a corresponding free or defer
        // We'll check this at function exit
    }
    
    // Check for stack allocation
    if (decl->is_stack) {
        // Stack allocations are automatically freed
        // Just verify they're not returned or escaped
    }
    
    // LIFETIME ANALYSIS: Check initializer for reference creation
    if (decl->initializer) {
        // Check if we're creating a safe reference ($) or pinned reference (#)
        if (auto* unary = dynamic_cast<frontend::UnaryOp*>(decl->initializer.get())) {
            // Case 1: Creating a safe reference: const int8$:ref = $var
            // Case 2: Pinning a value: const int8#:pinned = #var
            if (unary->op == frontend::UnaryOp::ADDRESS_OF || 
                unary->op == frontend::UnaryOp::PIN) {
                
                if (auto* target = dynamic_cast<frontend::VarExpr*>(unary->operand.get())) {
                    // Check lifetime: can 'decl->name' (the reference) point to 'target->name' (the host)?
                    ctx.checkLifetime(decl->name, target->name);
                    
                    // Track the reference → host relationship
                    ctx.reference_origins[decl->name] = target->name;
                    
                    // If it's a pin operation, mark the host as pinned
                    if (unary->op == frontend::UnaryOp::PIN) {
                        ctx.pinned_values.insert(target->name);
                    }
                }
            }
        }
        
        // Case 3: Reference assignment from another reference
        // Example: const int8$:ref2 = ref1;
        if (auto* var = dynamic_cast<frontend::VarExpr*>(decl->initializer.get())) {
            // Check if the source is a tracked reference
            if (ctx.reference_origins.count(var->name)) {
                // Transitive dependency: ref2 -> ref1 -> host
                // ref2 must not outlive the ultimate host
                std::string ultimate_host = ctx.reference_origins[var->name];
                ctx.checkLifetime(decl->name, ultimate_host);
                
                // Track the transitive reference
                ctx.reference_origins[decl->name] = ultimate_host;
            }
        }
        
        // General expression checking
        checkExpression(decl->initializer.get(), ctx);
    }
}

// Check expressions for borrow violations
void checkExpression(frontend::Expression* expr, BorrowContext& ctx) {
    if (!expr) return;
    
    // Check for Lambda expressions (function bodies)
    if (auto* lambda = dynamic_cast<frontend::LambdaExpr*>(expr)) {
        // Create a new context for the lambda scope
        BorrowContext lambda_ctx;
        lambda_ctx.current_depth = ctx.current_depth + 1;  // Inherit parent depth
        
        for (auto& stmt : lambda->body->statements) {
            auto* statement = dynamic_cast<frontend::Statement*>(stmt.get());
            if (statement) {
                checkStatement(statement, lambda_ctx);
            }
        }
        
        // Check for unfreed wild allocations in this lambda
        for (const auto& wild_var : lambda_ctx.wild_allocations) {
            if (lambda_ctx.deferred_frees.find(wild_var) == lambda_ctx.deferred_frees.end()) {
                lambda_ctx.warning("Wild allocation '" + wild_var + "' may not be freed. " +
                                 "Consider using 'defer aria.free(" + wild_var + ");'");
            }
        }
        
        // Propagate errors to parent context
        if (lambda_ctx.has_errors) {
            ctx.has_errors = true;
        }
        return;
    }
    
    // Check for pin operator usage
    if (auto* unary = dynamic_cast<frontend::UnaryOp*>(expr)) {
        if (unary->op == frontend::UnaryOp::PIN) {
            // Pin operator creates a pinned reference
            // Track the pinned value
            if (auto* var = dynamic_cast<frontend::VarExpr*>(unary->operand.get())) {
                ctx.pinned_values.insert(var->name);
            }
        }
        checkExpression(unary->operand.get(), ctx);
    }
    
    // Check binary operations
    if (auto* binary = dynamic_cast<frontend::BinaryOp*>(expr)) {
        checkExpression(binary->left.get(), ctx);
        checkExpression(binary->right.get(), ctx);
    }
    
    // Check ternary expressions
    if (auto* ternary = dynamic_cast<frontend::TernaryExpr*>(expr)) {
        checkExpression(ternary->condition.get(), ctx);
        checkExpression(ternary->true_expr.get(), ctx);
        checkExpression(ternary->false_expr.get(), ctx);
    }
    
    // Check function calls - might free wild pointers
    if (auto* call = dynamic_cast<frontend::CallExpr*>(expr)) {
        // Check for aria.free() calls
        if (call->function_name == "aria.free" || call->function_name == "free") {
            // Mark wild allocation as freed
            if (!call->arguments.empty()) {
                if (auto* var = dynamic_cast<frontend::VarExpr*>(call->arguments[0].get())) {
                    ctx.wild_allocations.erase(var->name);
                }
            }
        }
        
        // Check arguments
        for (auto& arg : call->arguments) {
            checkExpression(arg.get(), ctx);
        }
    }
}

// Check statements for borrow violations
void checkStatement(frontend::Statement* stmt, BorrowContext& ctx) {
    if (!stmt) return;
    
    // Variable declarations
    if (auto* decl = dynamic_cast<frontend::VarDecl*>(stmt)) {
        checkVarDecl(decl, ctx);
        return;
    }
    
    // Function declarations - recursively check function body
    if (auto* func = dynamic_cast<frontend::FuncDecl*>(stmt)) {
        if (func->body) {
            // Create a new context for the function scope
            BorrowContext func_ctx;
            func_ctx.enterScope();  // Function body is depth 1
            
            // Function parameters are at function scope (depth 1)
            // We assume they're already tracked by the caller
            
            for (auto& s : func->body->statements) {
                auto* statement = dynamic_cast<frontend::Statement*>(s.get());
                if (statement) {
                    checkStatement(statement, func_ctx);
                }
            }
            
            func_ctx.exitScope();  // Exit function body scope
            
            // Check for unfreed wild allocations in this function
            for (const auto& wild_var : func_ctx.wild_allocations) {
                if (func_ctx.deferred_frees.find(wild_var) == func_ctx.deferred_frees.end()) {
                    func_ctx.warning("Wild allocation '" + wild_var + "' in function '" + 
                                   func->name + "' may not be freed. " +
                                   "Consider using 'defer aria.free(" + wild_var + ");'");
                }
            }
            
            // Propagate errors to parent context
            if (func_ctx.has_errors) {
                ctx.has_errors = true;
            }
        }
        return;
    }
    
    // Expression statements
    if (auto* expr_stmt = dynamic_cast<frontend::ExpressionStmt*>(stmt)) {
        checkExpression(expr_stmt->expression.get(), ctx);
        return;
    }
    
    // Defer statements - register deferred cleanup
    if (auto* defer = dynamic_cast<frontend::DeferStmt*>(stmt)) {
        // Check if defer body contains a free call
        if (defer->body) {
            for (auto& s : defer->body->statements) {
                if (auto* expr_stmt = dynamic_cast<frontend::ExpressionStmt*>(s.get())) {
                    if (auto* call = dynamic_cast<frontend::CallExpr*>(expr_stmt->expression.get())) {
                        if (call->function_name == "aria.free" || call->function_name == "free") {
                            if (!call->arguments.empty()) {
                                if (auto* var = dynamic_cast<frontend::VarExpr*>(call->arguments[0].get())) {
                                    ctx.deferred_frees.insert(var->name);
                                }
                            }
                        }
                    }
                }
            }
        }
        return;
    }
    
    // Return statements - check for escaping stack/wild values
    if (auto* ret = dynamic_cast<frontend::ReturnStmt*>(stmt)) {
        if (ret->value) {
            checkExpression(ret->value.get(), ctx);
        }
        return;
    }
    
    // If statements - scope management for block-local variables
    if (auto* if_stmt = dynamic_cast<frontend::IfStmt*>(stmt)) {
        checkExpression(if_stmt->condition.get(), ctx);
        
        if (if_stmt->then_block) {
            ctx.enterScope();  // Enter 'then' block scope
            for (auto& s : if_stmt->then_block->statements) {
                checkStatement(dynamic_cast<frontend::Statement*>(s.get()), ctx);
            }
            ctx.exitScope();  // Exit 'then' block scope
        }
        
        if (if_stmt->else_block) {
            ctx.enterScope();  // Enter 'else' block scope
            for (auto& s : if_stmt->else_block->statements) {
                checkStatement(dynamic_cast<frontend::Statement*>(s.get()), ctx);
            }
            ctx.exitScope();  // Exit 'else' block scope
        }
        return;
    }
    
    // While loops - scope management for loop-local variables
    if (auto* while_loop = dynamic_cast<frontend::WhileLoop*>(stmt)) {
        checkExpression(while_loop->condition.get(), ctx);
        
        if (while_loop->body) {
            ctx.enterScope();  // Enter loop body scope
            for (auto& s : while_loop->body->statements) {
                checkStatement(dynamic_cast<frontend::Statement*>(s.get()), ctx);
            }
            ctx.exitScope();  // Exit loop body scope
        }
        return;
    }
}

// Main borrow checking function
bool check_borrow_rules(aria::frontend::Block* root) {
    if (!root) return true;
    
    BorrowContext ctx;
    
    // Check all statements in the block
    for (auto& stmt : root->statements) {
        // Statements in Block are AstNode*, need to cast to Statement*
        auto* statement = dynamic_cast<frontend::Statement*>(stmt.get());
        if (statement) {
            checkStatement(statement, ctx);
        }
    }
    
    // After processing all statements, check for unfreed wild allocations
    for (const auto& wild_var : ctx.wild_allocations) {
        // Check if it has a deferred free
        if (ctx.deferred_frees.find(wild_var) == ctx.deferred_frees.end()) {
            ctx.warning("Wild allocation '" + wild_var + "' may not be freed. " +
                       "Consider using 'defer aria.free(" + wild_var + ");'");
        }
    }
    
    // Check for moved pinned values
    // (Would require more sophisticated tracking to detect actual moves)
    
    return !ctx.has_errors;
}

} // namespace sema
} // namespace aria



--- src/frontend/sema/escape_analysis.h ---
#ifndef ARIA_FRONTEND_SEMA_ESCAPE_ANALYSIS_H
#define ARIA_FRONTEND_SEMA_ESCAPE_ANALYSIS_H

#include "../ast.h"

namespace aria {
namespace sema {

// Escape Analysis Result
// Tracks which wild pointers escape their function scope
struct EscapeAnalysisResult {
    bool has_escapes;           // True if any wild pointers escape
    int escaped_count;          // Number of escaped pointers
    bool has_wildx_violations;  // True if wildx (executable memory) pointers escape (SECURITY CRITICAL)
    
    EscapeAnalysisResult() : has_escapes(false), escaped_count(0), has_wildx_violations(false) {}
};

// Run Escape Analysis on AST
// Detects when wild pointers escape function scope (safety violation)
EscapeAnalysisResult run_escape_analysis(frontend::Block* ast);

} // namespace sema
} // namespace aria

#endif // ARIA_FRONTEND_SEMA_ESCAPE_ANALYSIS_H



--- src/frontend/sema/escape_analysis.cpp ---
/**
 * src/frontend/sema/escape_analysis.cpp
 * 
 * Aria Compiler - Escape Analysis Implementation
 * Version: 0.0.6
 * 
 * Implements escape analysis to detect when local values (stack or wild)
 * escape their scope, which could lead to dangling pointers or use-after-free.
 */

#include "escape_analysis.h"
#include "../ast.h"
#include "../ast/stmt.h"
#include "../ast/expr.h"
#include "../ast/control_flow.h"
#include "../ast/defer.h"
#include "../ast/loops.h"
#include <unordered_set>
#include <string>
#include <iostream>

namespace aria {
namespace sema {

// Escape Analysis Context
struct EscapeContext {
    std::unordered_set<std::string> stack_locals;   // Stack-allocated variables
    std::unordered_set<std::string> wild_locals;    // Wild-allocated variables
    std::unordered_set<std::string> wildx_locals;   // WildX (executable) allocated variables - SECURITY CRITICAL
    std::unordered_set<std::string> escaped_vars;   // Variables that have escaped
    int escape_count = 0;
    bool has_errors = false;
    bool has_wildx_violations = false;  // Track critical wildx violations
    
    void warning(const std::string& msg) {
        std::cerr << "Escape Analysis Warning: " << msg << std::endl;
    }
    
    void error(const std::string& msg) {
        std::cerr << "Escape Analysis Error: " << msg << std::endl;
        has_errors = true;
    }
    
    void security_error(const std::string& msg) {
        std::cerr << "\n*** SECURITY VIOLATION ***" << std::endl;
        std::cerr << "WildX Escape Analysis Error: " << msg << std::endl;
        std::cerr << "WildX pointers (executable memory) MUST NOT escape their scope." << std::endl;
        std::cerr << "This is a critical security violation that could enable code injection." << std::endl;
        std::cerr << "*** END SECURITY VIOLATION ***\n" << std::endl;
        has_errors = true;
        has_wildx_violations = true;
    }
};

// Forward declarations
void analyzeStatement(frontend::Statement* stmt, EscapeContext& ctx);
void analyzeExpression(frontend::Expression* expr, EscapeContext& ctx, bool is_escaping);

// Check if expression references a wildx pointer (SECURITY CRITICAL)
bool referencesWildX(frontend::Expression* expr, const EscapeContext& ctx) {
    if (!expr) return false;
    
    // Direct wildx variable reference
    if (auto* var = dynamic_cast<frontend::VarExpr*>(expr)) {
        return ctx.wildx_locals.find(var->name) != ctx.wildx_locals.end();
    }
    
    // Address-of wildx
    if (auto* unary = dynamic_cast<frontend::UnaryOp*>(expr)) {
        if (unary->op == frontend::UnaryOp::ADDRESS_OF) {
            return referencesWildX(unary->operand.get(), ctx);
        }
    }
    
    // Member access on wildx
    if (auto* member = dynamic_cast<frontend::MemberAccess*>(expr)) {
        return referencesWildX(member->object.get(), ctx);
    }
    
    return false;
}

// Check if expression references a local variable that shouldn't escape
bool referencesLocal(frontend::Expression* expr, const EscapeContext& ctx) {
    if (!expr) return false;
    
    // Check for direct variable reference
    if (auto* var = dynamic_cast<frontend::VarExpr*>(expr)) {
        return ctx.stack_locals.find(var->name) != ctx.stack_locals.end() ||
               ctx.wildx_locals.find(var->name) != ctx.wildx_locals.end();
    }
    
    // Check for address-of operator on local
    if (auto* unary = dynamic_cast<frontend::UnaryOp*>(expr)) {
        if (unary->op == frontend::UnaryOp::ADDRESS_OF) {
            return referencesLocal(unary->operand.get(), ctx);
        }
    }
    
    return false;
}

// Analyze variable declaration
void analyzeVarDecl(frontend::VarDecl* decl, EscapeContext& ctx) {
    if (!decl) return;
    
    // Track stack allocations
    if (decl->is_stack) {
        ctx.stack_locals.insert(decl->name);
    }
    
    // Track wildx allocations (SECURITY CRITICAL)
    // WildX = executable memory - highest security concern
    if (decl->is_wildx) {
        ctx.wildx_locals.insert(decl->name);
        // Note: wildx implies wild, but we track separately for stricter checks
    }
    
    // Track wild allocations
    if (decl->is_wild && !decl->is_wildx) {
        ctx.wild_locals.insert(decl->name);
    }
    
    // Analyze initializer
    if (decl->initializer) {
        analyzeExpression(decl->initializer.get(), ctx, false);
    }
}

// Analyze expression for escaping
void analyzeExpression(frontend::Expression* expr, EscapeContext& ctx, bool is_escaping) {
    if (!expr) return;
    
    // Lambda expressions (function bodies)
    if (auto* lambda = dynamic_cast<frontend::LambdaExpr*>(expr)) {
        // Create new scope for lambda
        EscapeContext lambda_ctx;
        for (auto& stmt : lambda->body->statements) {
            auto* statement = dynamic_cast<frontend::Statement*>(stmt.get());
            if (statement) {
                analyzeStatement(statement, lambda_ctx);
            }
        }
        // Propagate errors
        if (lambda_ctx.has_errors) {
            ctx.has_errors = true;
        }
        return;
    }
    
    // Unary operations
    if (auto* unary = dynamic_cast<frontend::UnaryOp*>(expr)) {
        // Address-of operator creates a pointer that could escape
        if (unary->op == frontend::UnaryOp::ADDRESS_OF && is_escaping) {
            // CRITICAL: Check for wildx address leakage
            if (referencesWildX(unary->operand.get(), ctx)) {
                auto* var = dynamic_cast<frontend::VarExpr*>(unary->operand.get());
                if (var) {
                    ctx.security_error("Taking address of wildx pointer '" + var->name + 
                                     "' in escaping context. WildX addresses must never escape.");
                } else {
                    ctx.security_error("Taking address of wildx memory in escaping context. " +
                                     std::string("WildX addresses must never escape."));
                }
                ctx.escape_count++;
            } else if (referencesLocal(unary->operand.get(), ctx)) {
                auto* var = dynamic_cast<frontend::VarExpr*>(unary->operand.get());
                if (var) {
                    ctx.warning("Taking address of stack variable '" + var->name + 
                              "' that may escape its scope");
                    ctx.escaped_vars.insert(var->name);
                    ctx.escape_count++;
                }
            }
        }
        analyzeExpression(unary->operand.get(), ctx, is_escaping);
        return;
    }
    
    // Binary operations
    if (auto* binary = dynamic_cast<frontend::BinaryOp*>(expr)) {
        analyzeExpression(binary->left.get(), ctx, is_escaping);
        analyzeExpression(binary->right.get(), ctx, is_escaping);
        return;
    }
    
    // Cast expressions - check for wildx to dyn casts
    if (auto* cast = dynamic_cast<frontend::CastExpr*>(expr)) {
        // =====================================================================
        // SECURITY CHECK: WildX to dyn type cast
        // =====================================================================
        // Casting wildx to dyn (dynamic/generic type) is forbidden without
        // explicit runtime verification because it enables type confusion
        // attacks on executable memory.
        if (referencesWildX(cast->expression.get(), ctx)) {
            // Check if target type is 'dyn' or contains 'dyn'
            if (cast->target_type.find("dyn") != std::string::npos) {
                ctx.security_error("Casting wildx pointer to 'dyn' type is FORBIDDEN without runtime verification. " +
                                 std::string("This could enable type confusion attacks on executable memory."));
                ctx.escape_count++;
            }
        }
        analyzeExpression(cast->expression.get(), ctx, is_escaping);
        return;
    }
    
    // Ternary expressions
    if (auto* ternary = dynamic_cast<frontend::TernaryExpr*>(expr)) {
        analyzeExpression(ternary->condition.get(), ctx, false);
        analyzeExpression(ternary->true_expr.get(), ctx, is_escaping);
        analyzeExpression(ternary->false_expr.get(), ctx, is_escaping);
        return;
    }
    
    // Function calls
    if (auto* call = dynamic_cast<frontend::CallExpr*>(expr)) {
        // =====================================================================
        // SECURITY CHECK: WildX pointers passed to functions
        // =====================================================================
        // Passing wildx to external functions is dangerous unless the function
        // is explicitly marked as wildx-safe. For now, we ban all escapes.
        for (auto& arg : call->arguments) {
            if (referencesWildX(arg.get(), ctx)) {
                ctx.security_error("Passing wildx pointer to function '" + call->function_name + 
                                 "'. WildX pointers (executable memory) should not be passed to generic functions. " +
                                 "This could enable code injection if the function stores or returns the pointer.");
                ctx.escape_count++;
            }
            // Arguments might escape to the called function
            analyzeExpression(arg.get(), ctx, true);
        }
        return;
    }
}

// Analyze return statement for escaping values
void analyzeReturn(frontend::ReturnStmt* ret, EscapeContext& ctx) {
    if (!ret || !ret->value) return;
    
    // =========================================================================
    // CRITICAL SECURITY CHECK: WildX pointers MUST NEVER escape
    // =========================================================================
    // WildX pointers point to executable memory. Allowing them to escape
    // creates a code injection vector. This is a HARD ERROR, not a warning.
    if (referencesWildX(ret->value.get(), ctx)) {
        if (auto* var = dynamic_cast<frontend::VarExpr*>(ret->value.get())) {
            ctx.security_error("Returning wildx pointer '" + var->name + 
                             "' is FORBIDDEN. WildX pointers (executable memory) must never escape their scope.");
        } else {
            ctx.security_error("Return value contains wildx pointer. " 
                             "WildX pointers (executable memory) must never escape their scope.");
        }
        ctx.escaped_vars.insert("<wildx_return>");
        ctx.escape_count++;
        return;  // Don't perform further checks if wildx violation detected
    }
    
    // Check if returning a stack-allocated variable
    if (auto* var = dynamic_cast<frontend::VarExpr*>(ret->value.get())) {
        if (ctx.stack_locals.find(var->name) != ctx.stack_locals.end()) {
            ctx.error("Returning stack-allocated variable '" + var->name + 
                     "' which will be destroyed after function returns");
            ctx.escaped_vars.insert(var->name);
            ctx.escape_count++;
        }
    }
    
    // Check if returning address of local
    if (referencesLocal(ret->value.get(), ctx)) {
        ctx.warning("Return value may reference local stack variable");
    }
    
    // Analyze the return value expression
    analyzeExpression(ret->value.get(), ctx, true);
}

// Analyze statement for escape violations
void analyzeStatement(frontend::Statement* stmt, EscapeContext& ctx) {
    if (!stmt) return;
    
    // Variable declarations
    if (auto* decl = dynamic_cast<frontend::VarDecl*>(stmt)) {
        analyzeVarDecl(decl, ctx);
        return;
    }
    
    // Return statements - critical for escape analysis
    if (auto* ret = dynamic_cast<frontend::ReturnStmt*>(stmt)) {
        analyzeReturn(ret, ctx);
        return;
    }
    
    // Expression statements
    if (auto* expr_stmt = dynamic_cast<frontend::ExpressionStmt*>(stmt)) {
        analyzeExpression(expr_stmt->expression.get(), ctx, false);
        return;
    }
    
    // If statements
    if (auto* if_stmt = dynamic_cast<frontend::IfStmt*>(stmt)) {
        analyzeExpression(if_stmt->condition.get(), ctx, false);
        if (if_stmt->then_block) {
            for (auto& s : if_stmt->then_block->statements) {
                analyzeStatement(dynamic_cast<frontend::Statement*>(s.get()), ctx);
            }
        }
        if (if_stmt->else_block) {
            for (auto& s : if_stmt->else_block->statements) {
                analyzeStatement(dynamic_cast<frontend::Statement*>(s.get()), ctx);
            }
        }
        return;
    }
    
    // While loops
    if (auto* while_loop = dynamic_cast<frontend::WhileLoop*>(stmt)) {
        analyzeExpression(while_loop->condition.get(), ctx, false);
        if (while_loop->body) {
            for (auto& s : while_loop->body->statements) {
                analyzeStatement(dynamic_cast<frontend::Statement*>(s.get()), ctx);
            }
        }
        return;
    }
    
    // Defer statements
    if (auto* defer = dynamic_cast<frontend::DeferStmt*>(stmt)) {
        if (defer->body) {
            for (auto& s : defer->body->statements) {
                analyzeStatement(dynamic_cast<frontend::Statement*>(s.get()), ctx);
            }
        }
        return;
    }
}

// Main escape analysis function
EscapeAnalysisResult run_escape_analysis(aria::frontend::Block* root) {
    if (!root) {
        EscapeAnalysisResult result;
        return result;
    }
    
    EscapeContext ctx;
    
    // Analyze all statements
    for (auto& stmt : root->statements) {
        auto* statement = dynamic_cast<frontend::Statement*>(stmt.get());
        if (statement) {
            analyzeStatement(statement, ctx);
        }
    }
    
    // Build result
    EscapeAnalysisResult result;
    result.has_escapes = !ctx.escaped_vars.empty();
    result.escaped_count = ctx.escape_count;
    result.has_wildx_violations = ctx.has_wildx_violations;
    
    return result;
}

} // namespace sema
} // namespace aria
