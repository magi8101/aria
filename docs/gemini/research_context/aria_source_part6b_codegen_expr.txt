===================================
ARIA COMPILER SOURCE - PART 6b of 9
Backend: Expression Code Generation
===================================

--- src/backend/codegen_expr.h ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_expr.h
// STATUS: NEW (Refactor Task 10 - Gemini Audit #2)
// PURPOSE: Expression code generation (TBB safety, safe navigation)
////////////////////////////////////////////////////////////////
#ifndef ARIA_BACKEND_CODEGEN_EXPR_H
#define ARIA_BACKEND_CODEGEN_EXPR_H

#include "codegen_fwd.h"
#include "codegen_context.h"
#include "../frontend/ast.h"
#include "../frontend/ast/expr.h"

#include <llvm/IR/Value.h>
#include <llvm/IR/IRBuilder.h>

namespace aria {
namespace backend {

////////////////////////////////////////////////////////////////
// Expression Code Generator
// Handles all expression lowering to LLVM IR
////////////////////////////////////////////////////////////////
class ExprCodeGen {
    CodeGenContext& ctx;

public:
    explicit ExprCodeGen(CodeGenContext& context) : ctx(context) {}

    // Main entry point: Generate code for any expression
    llvm::Value* generate(frontend::Expression* node);

    // Expression-specific generators
    llvm::Value* visitIntLiteral(frontend::IntLiteral* node);
    llvm::Value* visitFloatLiteral(frontend::FloatLiteral* node);
    llvm::Value* visitBoolLiteral(frontend::BoolLiteral* node);
    llvm::Value* visitNullLiteral(frontend::NullLiteral* node);
    llvm::Value* visitStringLiteral(frontend::StringLiteral* node);
    
    llvm::Value* visitVarExpr(frontend::VarExpr* node);
    llvm::Value* visitBinaryOp(frontend::BinaryOp* node);
    llvm::Value* visitUnaryOp(frontend::UnaryOp* node);
    llvm::Value* visitCallExpr(frontend::CallExpr* node);
    llvm::Value* visitIndexExpr(frontend::IndexExpr* node);
    llvm::Value* visitMemberAccess(frontend::MemberAccess* node);
    llvm::Value* visitArrayLiteral(frontend::ArrayLiteral* node);
    llvm::Value* visitVectorLiteral(frontend::VectorLiteral* node);
    llvm::Value* visitObjectLiteral(frontend::ObjectLiteral* node);
    llvm::Value* visitTernary(frontend::TernaryExpr* node);
    llvm::Value* visitUnwrapExpr(frontend::UnwrapExpr* node);
    llvm::Value* visitCastExpr(frontend::CastExpr* node);
    // llvm::Value* visitRangeExpr(frontend::RangeExpr* node);  // TODO: RangeExpr not yet implemented
    llvm::Value* visitTemplateString(frontend::TemplateString* node);
    
    // CallExpr - Complex, being migrated in subsystems
    llvm::Value* visitCallExpr_Syscalls(frontend::CallExpr* node);
    llvm::Value* visitCallExpr_MemberMethod(frontend::CallExpr* node);
    llvm::Value* visitCallExpr_SIMD(frontend::CallExpr* node);
    llvm::Value* visitCallExpr_WildX(frontend::CallExpr* node);
    llvm::Value* visitCallExpr_Standard(frontend::CallExpr* node, 
                                         llvm::Function* callee,
                                         llvm::Value* calleePtr,
                                         llvm::FunctionType* funcType);


    // TBB arithmetic helpers (sticky error propagation)
    llvm::Value* createSafeBinOp(frontend::BinaryOp* node, llvm::Value* lhs, llvm::Value* rhs);
    
    // Helper: Load value with proper indirection handling
    llvm::Value* loadValue(llvm::Value* ptr, bool is_ref);
    
    // Helper: Check if type is TBB (requires sentinel checking)
    bool isTBBType(const std::string& type);
    
    // Helper: Get TBB sentinel value for type
    llvm::Value* getTBBSentinel(const std::string& type);
};

} // namespace backend
} // namespace aria

#endif // ARIA_BACKEND_CODEGEN_EXPR_H



--- src/backend/codegen_expr.cpp ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_expr.cpp
// STATUS: NEW (Refactor Task 10 - Gemini Audit #2)
// PURPOSE: Expression code generation (TBB safety, safe navigation)
////////////////////////////////////////////////////////////////

#include "codegen_expr.h"
#include "codegen_context.h"
#include "../frontend/ast.h"
#include "../frontend/ast/stmt.h"
#include "../frontend/ast/expr.h"
#include <llvm/IR/Intrinsics.h>
#include <llvm/IR/Constants.h>

using namespace llvm;

namespace aria {
namespace backend {

// =============================================================================
// Main Expression Generator Entry Point
// =============================================================================

Value* ExprCodeGen::generate(frontend::Expression* node) {
    if (!node) return nullptr;
    
    // Dispatch to specific handlers based on expression type
    if (auto* lit = dynamic_cast<frontend::IntLiteral*>(node)) {
        return visitIntLiteral(lit);
    }
    if (auto* flit = dynamic_cast<frontend::FloatLiteral*>(node)) {
        return visitFloatLiteral(flit);
    }
    if (auto* blit = dynamic_cast<frontend::BoolLiteral*>(node)) {
        return visitBoolLiteral(blit);
    }
    if (auto* nlit = dynamic_cast<frontend::NullLiteral*>(node)) {
        return visitNullLiteral(nlit);
    }
    if (auto* slit = dynamic_cast<frontend::StringLiteral*>(node)) {
        return visitStringLiteral(slit);
    }
    if (auto* var = dynamic_cast<frontend::VarExpr*>(node)) {
        return visitVarExpr(var);
    }
    if (auto* binop = dynamic_cast<frontend::BinaryOp*>(node)) {
        return visitBinaryOp(binop);
    }
    if (auto* unop = dynamic_cast<frontend::UnaryOp*>(node)) {
        return visitUnaryOp(unop);
    }
    if (auto* member = dynamic_cast<frontend::MemberAccess*>(node)) {
        return visitMemberAccess(member);
    }
    if (auto* ternary = dynamic_cast<frontend::TernaryExpr*>(node)) {
        return visitTernary(ternary);
    }
    if (auto* idx = dynamic_cast<frontend::IndexExpr*>(node)) {
        return visitIndexExpr(idx);
    }
    if (auto* arr = dynamic_cast<frontend::ArrayLiteral*>(node)) {
        return visitArrayLiteral(arr);
    }
    if (auto* unwrap = dynamic_cast<frontend::UnwrapExpr*>(node)) {
        return visitUnwrapExpr(unwrap);
    }
    if (auto* cast = dynamic_cast<frontend::CastExpr*>(node)) {
        return visitCastExpr(cast);
    }
    // RangeExpr not yet implemented in AST
    // if (auto* range = dynamic_cast<frontend::RangeExpr*>(node)) {
    //     return visitRangeExpr(range);
    // }
    if (auto* tstr = dynamic_cast<frontend::TemplateString*>(node)) {
        return visitTemplateString(tstr);
    }
    if (auto* vecLit = dynamic_cast<frontend::VectorLiteral*>(node)) {
        return visitVectorLiteral(vecLit);
    }
    if (auto* obj = dynamic_cast<frontend::ObjectLiteral*>(node)) {
        return visitObjectLiteral(obj);
    }
    if (auto* call = dynamic_cast<frontend::CallExpr*>(node)) {
        return visitCallExpr(call);
    }
    
    // Add other expression types as needed
    return nullptr;
}

// =============================================================================
// Literal Generators
// =============================================================================

Value* ExprCodeGen::visitIntLiteral(frontend::IntLiteral* node) {
    return ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), node->value);
}

Value* ExprCodeGen::visitFloatLiteral(frontend::FloatLiteral* node) {
    return ConstantFP::get(Type::getDoubleTy(ctx.llvmContext), node->value);
}

Value* ExprCodeGen::visitBoolLiteral(frontend::BoolLiteral* node) {
    return ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), node->value ? 1 : 0);
}

Value* ExprCodeGen::visitNullLiteral(frontend::NullLiteral* node) {
    return ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext));
}

Value* ExprCodeGen::visitStringLiteral(frontend::StringLiteral* node) {
    return ctx.builder->CreateGlobalStringPtr(node->value);
}

// =============================================================================
// Variable Access
// =============================================================================

Value* ExprCodeGen::visitVarExpr(frontend::VarExpr* node) {
    auto* sym = ctx.lookup(node->name);
    if (!sym) return nullptr;
    
    // Use loadValue helper for proper indirection handling
    return loadValue(sym->val, sym->is_ref);
}

// =============================================================================
// Safe Navigation Operator - CRITICAL FIX from Audit #2
// =============================================================================

Value* ExprCodeGen::visitMemberAccess(frontend::MemberAccess* node) {
    Value* objPtr = generate(node->object.get());
    if (!objPtr) return nullptr;

    // Check if this is safe navigation (?.)
    if (node->is_safe) {
        if (!objPtr->getType()->isPointerTy()) {
            throw std::runtime_error("Safe navigation operator '?.' requires a pointer type.");
        }

        Function* func = ctx.builder->GetInsertBlock()->getParent();
        
        // Create BasicBlocks for control flow
        BasicBlock* nullBB = BasicBlock::Create(ctx.llvmContext, "safe_null", func);
        BasicBlock* accessBB = BasicBlock::Create(ctx.llvmContext, "safe_access", func);
        BasicBlock* mergeBB = BasicBlock::Create(ctx.llvmContext, "safe_merge", func);

        // Check if object is null
        Value* isNull = ctx.builder->CreateIsNull(objPtr, "is_null");
        ctx.builder->CreateCondBr(isNull, nullBB, accessBB);

        // --- Path 1: Object is Null ---
        ctx.builder->SetInsertPoint(nullBB);
        // For safe navigation, if object is null, entire expression is null
        // TODO: Get actual field type from struct metadata
        Value* nullResult = ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext));
        ctx.builder->CreateBr(mergeBB);

        // --- Path 2: Object Valid - Access Member ---
        ctx.builder->SetInsertPoint(accessBB);
        // TODO: Implement actual GEP + Load for struct field access
        // For now, placeholder - needs struct field resolution
        Value* accessedVal = ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext));
        ctx.builder->CreateBr(mergeBB);

        // --- Merge Path - PHI Node ---
        ctx.builder->SetInsertPoint(mergeBB);
        PHINode* phi = ctx.builder->CreatePHI(accessedVal->getType(), 2, "safe_result");
        phi->addIncoming(nullResult, nullBB);
        phi->addIncoming(accessedVal, accessBB);

        return phi;
    }

    // Standard (non-safe) member access
    // TODO: Implement standard GEP + Load logic
    return nullptr;
}

// =============================================================================
// Binary Operations with TBB Support
// =============================================================================

Value* ExprCodeGen::visitBinaryOp(frontend::BinaryOp* node) {
    Value* lhs = generate(node->left.get());
    Value* rhs = generate(node->right.get());
    
    if (!lhs || !rhs) return nullptr;
    
    // Check if this is TBB arithmetic (requires sticky error propagation)
    std::string lhsType = "";
    if (ctx.exprTypeMap.count(lhs) > 0) {
        lhsType = ctx.exprTypeMap[lhs];
    }
    
    if (isTBBType(lhsType)) {
        return createSafeBinOp(node, lhs, rhs);
    }
    
    // Standard arithmetic (non-TBB)
    switch (node->op) {
        case frontend::BinaryOp::ADD:
            return ctx.builder->CreateAdd(lhs, rhs, "add");
        case frontend::BinaryOp::SUB:
            return ctx.builder->CreateSub(lhs, rhs, "sub");
        case frontend::BinaryOp::MUL:
            return ctx.builder->CreateMul(lhs, rhs, "mul");
        case frontend::BinaryOp::DIV:
            return ctx.builder->CreateSDiv(lhs, rhs, "div");
        case frontend::BinaryOp::EQ:
            return ctx.builder->CreateICmpEQ(lhs, rhs, "eq");
        case frontend::BinaryOp::NE:
            return ctx.builder->CreateICmpNE(lhs, rhs, "ne");
        case frontend::BinaryOp::LT:
            return ctx.builder->CreateICmpSLT(lhs, rhs, "lt");
        case frontend::BinaryOp::LE:
            return ctx.builder->CreateICmpSLE(lhs, rhs, "le");
        case frontend::BinaryOp::GT:
            return ctx.builder->CreateICmpSGT(lhs, rhs, "gt");
        case frontend::BinaryOp::GE:
            return ctx.builder->CreateICmpSGE(lhs, rhs, "ge");
        default:
            return nullptr;
    }
}

// =============================================================================
// TBB "Sticky Error" Arithmetic - CRITICAL for TBB Safety
// =============================================================================

Value* ExprCodeGen::createSafeBinOp(frontend::BinaryOp* node, Value* L, Value* R) {
    unsigned bits = L->getType()->getIntegerBitWidth();
    
    // 1. Define Sentinel (Min Int for signed types)
    Value* sentinel = ConstantInt::get(ctx.llvmContext, 
        APInt::getSignedMinValue(bits));

    // 2. Check Inputs for ERR sentinel
    Value* lIsErr = ctx.builder->CreateICmpEQ(L, sentinel, "l_err");
    Value* rIsErr = ctx.builder->CreateICmpEQ(R, sentinel, "r_err");
    Value* anyInputErr = ctx.builder->CreateOr(lIsErr, rIsErr, "any_in_err");

    // 3. Perform Operation with LLVM Overflow Intrinsic
    Intrinsic::ID intrinsicId;
    switch (node->op) {
        case frontend::BinaryOp::ADD: 
            intrinsicId = Intrinsic::sadd_with_overflow; 
            break;
        case frontend::BinaryOp::SUB: 
            intrinsicId = Intrinsic::ssub_with_overflow; 
            break;
        case frontend::BinaryOp::MUL: 
            intrinsicId = Intrinsic::smul_with_overflow; 
            break;
        default: 
            throw std::runtime_error("TBB operation not supported for this operator");
    }
    
    Function* intr = Intrinsic::getDeclaration(ctx.module.get(), intrinsicId, {L->getType()});
    Value* call = ctx.builder->CreateCall(intr, {L, R}, "tbb_op");
    Value* opResult = ctx.builder->CreateExtractValue(call, 0, "res");
    Value* overflow = ctx.builder->CreateExtractValue(call, 1, "ovf");

    // 4. Check Result Collision (Result == Sentinel)
    Value* resIsSentinel = ctx.builder->CreateICmpEQ(opResult, sentinel, "collision");

    // 5. Final Sticky Logic: If (InputErr OR Overflow OR Result==Sentinel) -> Sentinel, Else Result
    Value* fail = ctx.builder->CreateOr(anyInputErr, overflow);
    fail = ctx.builder->CreateOr(fail, resIsSentinel, "tbb_fail");

    Value* result = ctx.builder->CreateSelect(fail, sentinel, opResult, "tbb_result");
    
    // Track that result is TBB type for future operations
    if (ctx.exprTypeMap.count(L) > 0) {
        ctx.exprTypeMap[result] = ctx.exprTypeMap[L];
    }
    
    return result;
}

// =============================================================================
// Unary Operations
// =============================================================================

Value* ExprCodeGen::visitUnaryOp(frontend::UnaryOp* node) {
    return nullptr; // Stub - to be implemented when AST has UnaryOp
}

// =============================================================================
// Ternary Operator (condition ? true : false)
// =============================================================================

Value* ExprCodeGen::visitTernary(frontend::TernaryExpr* node) {
    Value* cond = generate(node->condition.get());
    Value* true_val = generate(node->true_expr.get());
    Value* false_val = generate(node->false_expr.get());
    
    if (!cond || !true_val || !false_val) return nullptr;
    
    // LLVM select requires i1 condition
    if (cond->getType()->isIntegerTy() && cond->getType()->getIntegerBitWidth() != 1) {
        cond = ctx.builder->CreateICmpNE(cond, ConstantInt::get(cond->getType(), 0));
    }
    
    return ctx.builder->CreateSelect(cond, true_val, false_val);
}

// =============================================================================
// Helper Methods
// =============================================================================

Value* ExprCodeGen::loadValue(Value* ptr, bool is_ref) {
    if (!is_ref) {
        return ptr; // Direct value (PHI node or constant)
    }
    
    // Load from alloca or pointer
    // TODO: Handle different allocation strategies properly
    return ctx.builder->CreateLoad(Type::getInt64Ty(ctx.llvmContext), ptr);
}

bool ExprCodeGen::isTBBType(const std::string& type) {
    return type == "tbb8" || type == "tbb16" || type == "tbb32" || type == "tbb64";
}

Value* ExprCodeGen::getTBBSentinel(const std::string& type) {
    unsigned bits;
    if (type == "tbb8") bits = 8;
    else if (type == "tbb16") bits = 16;
    else if (type == "tbb32") bits = 32;
    else if (type == "tbb64") bits = 64;
    else return nullptr;
    
    return ConstantInt::get(ctx.llvmContext, APInt::getSignedMinValue(bits));
}

// =============================================================================
// Array/Vector Indexing
// =============================================================================

Value* ExprCodeGen::visitIndexExpr(frontend::IndexExpr* node) {
    Value* arrayPtr = generate(node->array.get());
    Value* index = generate(node->index.get());
    
    if (!arrayPtr || !index) return nullptr;
    
    Type* arrayPtrType = arrayPtr->getType();
    
    // Determine the element type
    Type* elementType = nullptr;
    std::string ariaElementType = "";
    
    // Try to find the array variable in symbol table to get its Aria type
    if (auto* varRef = dynamic_cast<frontend::VarExpr*>(node->array.get())) {
        auto* sym = ctx.lookup(varRef->name);
        if (sym && !sym->ariaType.empty()) {
            // Parse array type: "int64[5]" or "int64[]" -> element type is "int64"
            std::string ariaType = sym->ariaType;
            size_t bracketPos = ariaType.find('[');
            if (bracketPos != std::string::npos) {
                ariaElementType = ariaType.substr(0, bracketPos);
                elementType = ctx.getLLVMType(ariaElementType);
            }
        }
    }
    
    // Fallback: infer from pointer type
    if (!elementType && arrayPtrType->isPointerTy()) {
        elementType = Type::getInt64Ty(ctx.llvmContext); // Default
    }
    
    if (!elementType) {
        throw std::runtime_error("Array indexing requires pointer or array type");
    }
    
    // Handle pointer to array element
    if (arrayPtrType->isPointerTy()) {
        // Get element pointer
        Value* elemPtr = ctx.builder->CreateGEP(
            elementType,
            arrayPtr,
            index,
            "elem_ptr"
        );
        // Load element
        return ctx.builder->CreateLoad(elementType, elemPtr, "elem");
    }
    
    throw std::runtime_error("Array indexing requires pointer or array type");
}

// =============================================================================
// Array Literals
// =============================================================================

Value* ExprCodeGen::visitArrayLiteral(frontend::ArrayLiteral* node) {
    if (node->elements.empty()) {
        throw std::runtime_error("Empty array literals not yet supported");
    }
    
    // Evaluate all elements
    std::vector<Value*> values;
    Type* elemType = nullptr;
    for (auto& elem : node->elements) {
        Value* val = generate(elem.get());
        values.push_back(val);
        if (!elemType) {
            elemType = val->getType();
        } else if (val->getType() != elemType) {
            throw std::runtime_error("Array literal elements must have same type");
        }
    }
    
    // Create array type
    uint64_t arraySize = values.size();
    ArrayType* arrayType = ArrayType::get(elemType, arraySize);
    
    // Allocate array on stack
    AllocaInst* arrayAlloca = ctx.builder->CreateAlloca(arrayType, nullptr, "array_lit");
    
    // Store each element
    for (uint64_t i = 0; i < arraySize; i++) {
        Value* indices[] = {
            ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0),
            ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), i)
        };
        Value* elemPtr = ctx.builder->CreateGEP(arrayType, arrayAlloca, indices, "elem_ptr");
        ctx.builder->CreateStore(values[i], elemPtr);
    }
    
    // Return pointer to array (decays to pointer)
    Value* indices[] = {
        ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0),
        ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0)
    };
    return ctx.builder->CreateGEP(arrayType, arrayAlloca, indices, "array_ptr");
}

// =============================================================================
// Unwrap Expression (? operator for error handling)
// =============================================================================

Value* ExprCodeGen::visitUnwrapExpr(frontend::UnwrapExpr* node) {
    Value* resultVal = generate(node->expression.get());
    if (!resultVal) return nullptr;
    
    Value* defaultVal = generate(node->default_value.get());
    if (!defaultVal) return nullptr;
    
    // Assume Result/output is a struct with err (i8) and val fields
    if (auto* structType = dyn_cast<StructType>(resultVal->getType())) {
        Function* func = ctx.builder->GetInsertBlock()->getParent();
        
        // Extract err field (index 0)
        AllocaInst* tempAlloca = ctx.builder->CreateAlloca(structType, nullptr, "result_temp");
        ctx.builder->CreateStore(resultVal, tempAlloca);
        
        Value* errPtr = ctx.builder->CreateStructGEP(structType, tempAlloca, 0, "err_ptr");
        Type* errType = structType->getElementType(0);
        Value* errVal = ctx.builder->CreateLoad(errType, errPtr, "err");
        
        // Check if err is 0 (success)
        Value* isSuccess = ctx.builder->CreateICmpEQ(
            errVal, 
            ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 0),
            "is_success"
        );
        
        // Extract val field (index 1)
        Value* valPtr = ctx.builder->CreateStructGEP(structType, tempAlloca, 1, "val_ptr");
        Type* valType = structType->getElementType(1);
        Value* valVal = ctx.builder->CreateLoad(valType, valPtr, "val");
        
        // If val and default have different types, cast default to match val type
        if (defaultVal->getType() != valType) {
            if (defaultVal->getType()->isIntegerTy() && valType->isIntegerTy()) {
                defaultVal = ctx.builder->CreateIntCast(defaultVal, valType, true);
            }
        }
        
        // Use select: if err == 0, return val, else return default
        return ctx.builder->CreateSelect(isSuccess, valVal, defaultVal, "unwrap_result");
    }
    
    // If not a struct, just return the value
    return resultVal;
}

// =============================================================================
// Cast Expression
// =============================================================================

Value* ExprCodeGen::visitCastExpr(frontend::CastExpr* node) {
    Value* sourceValue = generate(node->expression.get());
    if (!sourceValue) return nullptr;
    
    // Check if this is a function pointer cast (wildx → func)
    if (node->target_type.find("Func") != std::string::npos || node->target_type == "func") {
        // Function pointer cast - source should be wildx pointer
        return sourceValue;  // Pointer is already correct type
    }
    
    // Handle integer casts
    Type* targetType = ctx.getLLVMType(node->target_type);
    if (sourceValue->getType()->isIntegerTy() && targetType->isIntegerTy()) {
        return ctx.builder->CreateIntCast(sourceValue, targetType, true, "cast");
    }
    
    // Handle pointer casts
    if (sourceValue->getType()->isPointerTy() && targetType->isPointerTy()) {
        return ctx.builder->CreateBitCast(sourceValue, targetType, "ptrcast");
    }
    
    // If types match, no cast needed
    if (sourceValue->getType() == targetType) {
        return sourceValue;
    }
    
    // For other cases, try bitcast as fallback
    return ctx.builder->CreateBitCast(sourceValue, targetType, "cast");
}

// =============================================================================
// Range Expression (start..end or start...end)
// =============================================================================

// Value* ExprCodeGen::visitRangeExpr(frontend::RangeExpr* node) {
//     // Evaluate start and end expressions
//     Value* startVal = generate(node->start.get());
//     Value* endVal = generate(node->end.get());
//     
//     if (!startVal || !endVal) {
//         throw std::runtime_error("Invalid range expression: start or end is null");
//     }
//     
//     // Ensure start and end have the same type
//     Type* commonType = startVal->getType();
//     if (endVal->getType() != commonType) {
//         if (commonType->isIntegerTy() && endVal->getType()->isIntegerTy()) {
//             endVal = ctx.builder->CreateIntCast(endVal, commonType, true, "range.end.cast");
//         } else if (commonType->isFloatingPointTy() && endVal->getType()->isFloatingPointTy()) {
//             endVal = ctx.builder->CreateFPCast(endVal, commonType, "range.end.cast");
//         } else {
//             throw std::runtime_error("Range start and end must have compatible types");
//         }
//     }
//     
//     // Create range struct: { start, end, step, is_exclusive }
//     StructType* rangeType = StructType::create(ctx.llvmContext, {
//         commonType,                          // start
//         commonType,                          // end
//         commonType,                          // step
//         Type::getInt8Ty(ctx.llvmContext)     // is_exclusive flag
//     }, "Range");
//     
//     // Allocate struct on stack
//     Value* rangePtr = ctx.builder->CreateAlloca(rangeType, nullptr, "range");
//     
//     // Store start value
//     Value* startFieldPtr = ctx.builder->CreateStructGEP(rangeType, rangePtr, 0, "range.start.ptr");
//     ctx.builder->CreateStore(startVal, startFieldPtr);
//     
//     // Store end value
//     Value* endFieldPtr = ctx.builder->CreateStructGEP(rangeType, rangePtr, 1, "range.end.ptr");
//     ctx.builder->CreateStore(endVal, endFieldPtr);
//     
//     // Store step value (default to 1)
//     Value* stepVal;
//     if (commonType->isIntegerTy()) {
//         stepVal = ConstantInt::get(commonType, 1);
//     } else if (commonType->isFloatingPointTy()) {
//         stepVal = ConstantFP::get(commonType, 1.0);
//     } else {
//         throw std::runtime_error("Range expressions only support integer or float types");
//     }
//     Value* stepFieldPtr = ctx.builder->CreateStructGEP(rangeType, rangePtr, 2, "range.step.ptr");
//     ctx.builder->CreateStore(stepVal, stepFieldPtr);
//     
//     // Store is_exclusive flag
//     Value* exclusiveFlag = ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), node->is_exclusive ? 1 : 0);
//     Value* flagFieldPtr = ctx.builder->CreateStructGEP(rangeType, rangePtr, 3, "range.exclusive.ptr");
//     ctx.builder->CreateStore(exclusiveFlag, flagFieldPtr);
//     
//     // Load the struct value (for returning by value)
//     return ctx.builder->CreateLoad(rangeType, rangePtr, "range.value");
// }

// =============================================================================
// Template String (String Interpolation)
// =============================================================================

Value* ExprCodeGen::visitTemplateString(frontend::TemplateString* node) {
    // Declare sprintf if not already present
    Function* sprintfFunc = ctx.module->getFunction("sprintf");
    if (!sprintfFunc) {
        std::vector<Type*> sprintfParams = {
            PointerType::getUnqual(ctx.llvmContext),  // char* buffer
            PointerType::getUnqual(ctx.llvmContext)   // const char* format
        };
        FunctionType* sprintfType = FunctionType::get(
            Type::getInt32Ty(ctx.llvmContext),
            sprintfParams,
            true  // vararg
        );
        sprintfFunc = Function::Create(sprintfType, Function::ExternalLinkage, "sprintf", ctx.module.get());
    }
    
    // Allocate buffer for result string (1024 bytes)
    Value* buffer = ctx.builder->CreateAlloca(
        Type::getInt8Ty(ctx.llvmContext),
        ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 1024),
        "str_buffer"
    );
    
    // Track current position in buffer
    Value* bufferPos = buffer;
    
    for (auto& part : node->parts) {
        if (part.type == frontend::TemplatePart::STRING) {
            // Static string part
            Value* formatStr = ctx.builder->CreateGlobalStringPtr("%s");
            Value* strVal = ctx.builder->CreateGlobalStringPtr(part.string_value);
            
            std::vector<Value*> sprintfArgs = {bufferPos, formatStr, strVal};
            Value* written = ctx.builder->CreateCall(sprintfFunc, sprintfArgs);
            
            // Advance buffer position
            bufferPos = ctx.builder->CreateGEP(
                Type::getInt8Ty(ctx.llvmContext),
                bufferPos,
                written,
                "next_pos"
            );
        } else {
            // Expression part - evaluate and convert to string
            Value* exprVal = generate(part.expr_value.get());
            
            if (exprVal) {
                Value* formatStr = nullptr;
                std::vector<Value*> sprintfArgs = {bufferPos};
                
                if (exprVal->getType()->isIntegerTy()) {
                    if (exprVal->getType()->getIntegerBitWidth() == 1) {
                        // Boolean - convert to "true"/"false"
                        formatStr = ctx.builder->CreateGlobalStringPtr("%s");
                        Value* trueStr = ctx.builder->CreateGlobalStringPtr("true");
                        Value* falseStr = ctx.builder->CreateGlobalStringPtr("false");
                        Value* boolStr = ctx.builder->CreateSelect(exprVal, trueStr, falseStr);
                        sprintfArgs.push_back(formatStr);
                        sprintfArgs.push_back(boolStr);
                    } else {
                        // Integer - extend to i64 for sprintf %ld
                        Value* i64Val = ctx.builder->CreateIntCast(
                            exprVal,
                            Type::getInt64Ty(ctx.llvmContext),
                            true,
                            "to_i64"
                        );
                        formatStr = ctx.builder->CreateGlobalStringPtr("%ld");
                        sprintfArgs.push_back(formatStr);
                        sprintfArgs.push_back(i64Val);
                    }
                } else if (exprVal->getType()->isFloatingPointTy()) {
                    formatStr = ctx.builder->CreateGlobalStringPtr("%f");
                    sprintfArgs.push_back(formatStr);
                    sprintfArgs.push_back(exprVal);
                } else if (exprVal->getType()->isPointerTy()) {
                    formatStr = ctx.builder->CreateGlobalStringPtr("%s");
                    sprintfArgs.push_back(formatStr);
                    sprintfArgs.push_back(exprVal);
                } else {
                    formatStr = ctx.builder->CreateGlobalStringPtr("<unknown>");
                    sprintfArgs.push_back(formatStr);
                }
                
                Value* written = ctx.builder->CreateCall(sprintfFunc, sprintfArgs);
                
                // Advance buffer position
                bufferPos = ctx.builder->CreateGEP(
                    Type::getInt8Ty(ctx.llvmContext),
                    bufferPos,
                    written,
                    "next_pos"
                );
            }
        }
    }
    
    return buffer;
}

// =============================================================================
// Vector Literals (GLSL-style vectors)
// =============================================================================

Value* ExprCodeGen::visitVectorLiteral(frontend::VectorLiteral* node) {
    // Get LLVM vector type
    Type* vectorType = ctx.getLLVMType(node->vector_type);
    if (!vectorType || !vectorType->isVectorTy()) {
        throw std::runtime_error("Invalid vector type: " + node->vector_type);
    }
    
    FixedVectorType* fixedVecType = cast<FixedVectorType>(vectorType);
    unsigned numElements = fixedVecType->getNumElements();
    Type* elementType = fixedVecType->getElementType();
    
    // Empty constructor → Zero-initialization
    if (node->elements.empty()) {
        return Constant::getNullValue(vectorType);
    }
    
    // Single argument → Broadcasting
    if (node->elements.size() == 1) {
        Value* scalarVal = generate(node->elements[0].get());
        if (!scalarVal) return nullptr;
        
        // Cast scalar to element type if needed
        if (scalarVal->getType() != elementType) {
            if (scalarVal->getType()->isIntegerTy() && elementType->isIntegerTy()) {
                scalarVal = ctx.builder->CreateIntCast(scalarVal, elementType, true);
            } else if (scalarVal->getType()->isIntegerTy() && elementType->isFloatingPointTy()) {
                scalarVal = ctx.builder->CreateSIToFP(scalarVal, elementType);
            } else if (scalarVal->getType()->isFloatingPointTy() && elementType->isFloatingPointTy()) {
                scalarVal = ctx.builder->CreateFPCast(scalarVal, elementType);
            }
        }
        
        // Broadcast scalar to all lanes
        Value* result = UndefValue::get(vectorType);
        for (unsigned i = 0; i < numElements; ++i) {
            result = ctx.builder->CreateInsertElement(
                result,
                scalarVal,
                ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), i)
            );
        }
        return result;
    }
    
    // Multiple arguments → Component-wise construction
    Value* result = UndefValue::get(vectorType);
    unsigned currentIndex = 0;
    
    for (auto& elem : node->elements) {
        Value* elemVal = generate(elem.get());
        if (!elemVal) return nullptr;
        
        // Check if element is itself a vector (composition)
        if (elemVal->getType()->isVectorTy()) {
            FixedVectorType* elemVecType = cast<FixedVectorType>(elemVal->getType());
            unsigned elemCount = elemVecType->getNumElements();
            
            // Extract each component from the nested vector
            for (unsigned i = 0; i < elemCount; ++i) {
                Value* component = ctx.builder->CreateExtractElement(
                    elemVal,
                    ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), i)
                );
                
                // Cast to target element type if needed
                if (component->getType() != elementType) {
                    if (component->getType()->isIntegerTy() && elementType->isIntegerTy()) {
                        component = ctx.builder->CreateIntCast(component, elementType, true);
                    } else if (component->getType()->isIntegerTy() && elementType->isFloatingPointTy()) {
                        component = ctx.builder->CreateSIToFP(component, elementType);
                    } else if (component->getType()->isFloatingPointTy() && elementType->isFloatingPointTy()) {
                        component = ctx.builder->CreateFPCast(component, elementType);
                    }
                }
                
                result = ctx.builder->CreateInsertElement(
                    result,
                    component,
                    ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), currentIndex++)
                );
            }
        } else {
            // Scalar element
            Value* scalarVal = elemVal;
            
            // Cast to element type if needed
            if (scalarVal->getType() != elementType) {
                if (scalarVal->getType()->isIntegerTy() && elementType->isIntegerTy()) {
                    scalarVal = ctx.builder->CreateIntCast(scalarVal, elementType, true);
                } else if (scalarVal->getType()->isIntegerTy() && elementType->isFloatingPointTy()) {
                    scalarVal = ctx.builder->CreateSIToFP(scalarVal, elementType);
                } else if (scalarVal->getType()->isFloatingPointTy() && elementType->isFloatingPointTy()) {
                    scalarVal = ctx.builder->CreateFPCast(scalarVal, elementType);
                }
            }
            
            result = ctx.builder->CreateInsertElement(
                result,
                scalarVal,
                ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), currentIndex++)
            );
        }
    }
    
    return result;
}

// =============================================================================
// Object Literals (Struct construction, Result objects, Anonymous objects)
// =============================================================================

Value* ExprCodeGen::visitObjectLiteral(frontend::ObjectLiteral* node) {
    // Case 1: Struct constructor (has type_name) - Point{x: 10, y: 20}
    if (!node->type_name.empty()) {
        std::string structName = node->type_name;
        
        StructType* structType = StructType::getTypeByName(ctx.llvmContext, structName);
        if (!structType) {
            throw std::runtime_error("Unknown struct type: " + structName);
        }
        
        AllocaInst* structAlloca = ctx.builder->CreateAlloca(structType, nullptr, structName + "_instance");
        
        unsigned fieldIdx = 0;
        for (auto& field : node->fields) {
            Value* fieldValue = generate(field.value.get());
            if (!fieldValue) {
                throw std::runtime_error("Failed to evaluate field initializer for: " + field.name);
            }
            
            Value* fieldPtr = ctx.builder->CreateStructGEP(structType, structAlloca, fieldIdx, field.name + "_ptr");
            Type* fieldType = structType->getElementType(fieldIdx);
            
            if (fieldValue->getType() != fieldType) {
                if (fieldValue->getType()->isIntegerTy() && fieldType->isIntegerTy()) {
                    fieldValue = ctx.builder->CreateIntCast(fieldValue, fieldType, true);
                } else if (fieldValue->getType()->isFloatingPointTy() && fieldType->isFloatingPointTy()) {
                    fieldValue = ctx.builder->CreateFPCast(fieldValue, fieldType);
                } else if (fieldValue->getType()->isIntegerTy() && fieldType->isFloatingPointTy()) {
                    fieldValue = ctx.builder->CreateSIToFP(fieldValue, fieldType);
                } else if (fieldValue->getType()->isFloatingPointTy() && fieldType->isIntegerTy()) {
                    fieldValue = ctx.builder->CreateFPToSI(fieldValue, fieldType);
                } else {
                    throw std::runtime_error("Type mismatch for field: " + field.name);
                }
            }
            ctx.builder->CreateStore(fieldValue, fieldPtr);
            fieldIdx++;
        }
        
        return ctx.builder->CreateLoad(structType, structAlloca, structName + "_value");
    }
    
    // Case 2: Result object (has err and/or val fields)
    bool isResultObject = false;
    Value* valField = nullptr;
    Value* errField = nullptr;
    
    for (auto& field : node->fields) {
        if (field.name == "err") {
            isResultObject = true;
            errField = generate(field.value.get());
        } else if (field.name == "val") {
            isResultObject = true;
            valField = generate(field.value.get());
        }
    }
    
    if (isResultObject) {
        if (ctx.currentFunctionReturnType.empty()) {
            throw std::runtime_error("Result object used outside of function context");
        }
        
        Type* resultTypeLLVM = ctx.getResultType(ctx.currentFunctionReturnType);
        StructType* resultType = dyn_cast<StructType>(resultTypeLLVM);
        
        if (!resultType) {
            throw std::runtime_error("Failed to create result type for: " + ctx.currentFunctionReturnType);
        }
        
        Type* expectedValType = resultType->getElementType(1);
        AllocaInst* resultAlloca = ctx.builder->CreateAlloca(resultType, nullptr, "result");
        
        // Store err field (default to 0 if not provided)
        Value* errValue = errField ? errField : ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 0);
        
        if (errValue->getType() != Type::getInt8Ty(ctx.llvmContext)) {
            if (errValue->getType()->isIntegerTy()) {
                errValue = ctx.builder->CreateIntCast(errValue, Type::getInt8Ty(ctx.llvmContext), true, "err_cast");
            } else {
                throw std::runtime_error("err field must be int8");
            }
        }
        
        Value* errPtr = ctx.builder->CreateStructGEP(resultType, resultAlloca, 0, "err_ptr");
        ctx.builder->CreateStore(errValue, errPtr);
        
        // Store val field
        if (valField) {
            if (valField->getType() != expectedValType) {
                if (valField->getType()->isIntegerTy() && expectedValType->isIntegerTy()) {
                    valField = ctx.builder->CreateIntCast(valField, expectedValType, true, "val_cast");
                } else {
                    throw std::runtime_error("Type mismatch in result object");
                }
            }
            
            Value* valPtr = ctx.builder->CreateStructGEP(resultType, resultAlloca, 1, "val_ptr");
            ctx.builder->CreateStore(valField, valPtr);
        } else {
            throw std::runtime_error("Result object missing 'val' field");
        }
        
        return ctx.builder->CreateLoad(resultType, resultAlloca, "result_val");
    }
    
    // Case 3: Anonymous object literal {x: 10, y: 20}
    std::vector<Type*> fieldTypes;
    std::vector<Value*> fieldValues;
    std::vector<std::string> fieldNames;
    
    for (auto& field : node->fields) {
        Value* val = generate(field.value.get());
        if (!val) {
            throw std::runtime_error("Invalid field value in object literal for field: " + field.name);
        }
        
        fieldTypes.push_back(val->getType());
        fieldValues.push_back(val);
        fieldNames.push_back(field.name);
    }
    
    StructType* anonType = StructType::get(ctx.llvmContext, fieldTypes, false);
    AllocaInst* objAlloca = ctx.builder->CreateAlloca(anonType, nullptr, "anon_obj");
    
    for (size_t i = 0; i < fieldValues.size(); ++i) {
        Value* fieldPtr = ctx.builder->CreateStructGEP(anonType, objAlloca, i, fieldNames[i] + "_ptr");
        ctx.builder->CreateStore(fieldValues[i], fieldPtr);
    }
    
    return ctx.builder->CreateLoad(anonType, objAlloca, "anon_val");
}

// =============================================================================
// CallExpr - Function Calls (Complex, being migrated incrementally)
// =============================================================================

Value* ExprCodeGen::visitCallExpr(frontend::CallExpr* node) {
    if (!node) return nullptr;
    
    // =========================================================================
    // GENERIC TEMPLATE MONOMORPHIZATION (NOT HANDLED HERE!)
    // =========================================================================
    // Generic monomorphization is a PREPROCESSING step that happens in 
    // CodeGenVisitor::visitExpr() BEFORE ExprCodeGen::visitCallExpr() is called.
    //
    // Why it stays in the visitor:
    // 1. Requires access to genericTemplates map (stored in CodeGenVisitor)
    // 2. Performs AST-level transformation (rewrites function_name)
    // 3. May trigger new function instantiation (monomorphize() call)
    // 4. Type inference needs access to type checker state
    //
    // What happens:
    // - Input:  identity<int8>(42)  → node->function_name = "identity", type_args = ["int8"]
    // - After:  identity_int8(42)   → node->function_name = "identity_int8"
    //
    // By the time we reach ExprCodeGen, all generic calls have been resolved to
    // their monomorphized names, so we only see "identity_int8" not "identity<int8>".
    // This maintains clean separation: visitor = AST preprocessing, ExprCodeGen = IR gen.
    // =========================================================================
    
    // =========================================================================
    // MEMBER METHOD CALLS: p.method() or Type.method()
    // =========================================================================
    // Member method calls have a non-null callee field containing MemberAccess
    // =========================================================================
    if (node->callee) {
        return visitCallExpr_MemberMethod(node);
    }
    
    // =========================================================================
    // INTRINSICS: Syscalls, SIMD, WildX
    // =========================================================================
    
    std::string funcName = node->function_name;
    
    // Check for syscall intrinsics (file I/O operations)
    if (funcName == "intrinsic_open" || funcName == "intrinsic_close" ||
        funcName == "intrinsic_read" || funcName == "intrinsic_write" ||
        funcName == "intrinsic_lseek") {
        return visitCallExpr_Syscalls(node);
    }
    
    // Check for SIMD vector intrinsics
    if (funcName == "dot" || funcName == "cross" || 
        funcName == "length" || funcName == "normalize") {
        llvm::Value* result = visitCallExpr_SIMD(node);
        if (result) return result;
        // If SIMD handler returns nullptr, fall through to standard call
    }
    
    // Check for WildX memory protection intrinsics
    if (funcName == "aria.mem.protect_exec" || funcName == "protect_exec" ||
        funcName == "aria.mem.protect_write" || funcName == "protect_write" ||
        funcName == "aria.mem.free_exec" || funcName == "free_exec") {
        llvm::Value* result = visitCallExpr_WildX(node);
        if (result) return result;
        // If WildX handler returns nullptr, fall through to standard call
    }
    
    // =========================================================================
    // STANDARD FUNCTION CALLS: Final common path
    // =========================================================================
    // This handles all regular function calls after intrinsics are filtered out.
    // It needs to resolve the callee, which happens in the monolithic code for now.
    // =========================================================================
    
    // For now, standard calls are still in the monolithic visitExpr
    // TODO: Move function resolution logic here, then call visitCallExpr_Standard
    
    return nullptr;  // Delegated to monolithic code for now
}

// -----------------------------------------------------------------------------
// Member Method Calls Subsystem
// -----------------------------------------------------------------------------

Value* ExprCodeGen::visitCallExpr_MemberMethod(frontend::CallExpr* node) {
    // Transform p.method() → StructName_method(p)
    // Transform Type.method() → StructName_method()
    
    if (!node->callee) {
        throw std::runtime_error("visitCallExpr_MemberMethod called with null callee");
    }
    
    auto* memberAccess = dynamic_cast<frontend::MemberAccess*>(node->callee.get());
    if (!memberAccess) {
        // Callee exists but isn't a MemberAccess - might be function pointer, closure, etc.
        // These should be handled by other subsystems
        throw std::runtime_error("Complex callee expressions (function pointers, closures) not yet implemented");
    }
    
    // Determine the struct type
    std::string structTypeName;
    bool isStaticCall = memberAccess->is_static;
    
    if (isStaticCall) {
        // Static call: Type.method()
        // The object is a VarExpr with the type name
        if (auto* typeIdent = dynamic_cast<frontend::VarExpr*>(memberAccess->object.get())) {
            structTypeName = typeIdent->name;
        }
    } else {
        // Instance call: p.method()
        // Need to get the type of the object expression
        Value* objValue = generate(memberAccess->object.get());
        
        // Lookup the object's Aria type from exprTypeMap
        if (ctx.exprTypeMap.count(objValue) > 0) {
            structTypeName = ctx.exprTypeMap[objValue];
        } else {
            // Fallback: try to infer from object if it's a VarExpr
            if (auto* objIdent = dynamic_cast<frontend::VarExpr*>(memberAccess->object.get())) {
                auto* sym = ctx.lookup(objIdent->name);
                if (sym) {
                    structTypeName = sym->ariaType;
                }
            }
        }
    }
    
    if (structTypeName.empty()) {
        throw std::runtime_error("Unable to determine type for method call '" + memberAccess->member_name + "'");
    }
    
    // Build mangled method name: StructName_methodName
    std::string mangledMethodName = ctx.currentModulePrefix + structTypeName + "_" + memberAccess->member_name;
    
    // Find the method function
    Function* methodFunc = ctx.module->getFunction(mangledMethodName);
    
    if (!methodFunc) {
        throw std::runtime_error("Method '" + memberAccess->member_name + 
                               "' not found on type '" + structTypeName + "'");
    }
    
    // Build argument list
    std::vector<Value*> args;
    
    if (!isStaticCall) {
        // Instance method: pass object as first argument (self)
        Value* objPtr = generate(memberAccess->object.get());
        args.push_back(objPtr);
    }
    
    // Add remaining arguments
    for (auto& arg : node->arguments) {
        Value* argVal = generate(arg.get());
        if (!argVal) {
            throw std::runtime_error("Failed to evaluate method argument");
        }
        args.push_back(argVal);
    }
    
    // Generate the call
    return ctx.builder->CreateCall(methodFunc, args, "method_call");
}

// -----------------------------------------------------------------------------
// Syscall Intrinsics Subsystem
// -----------------------------------------------------------------------------

Value* ExprCodeGen::visitCallExpr_Syscalls(frontend::CallExpr* node) {
    std::string funcName = node->function_name;
    
    // Evaluate arguments
    std::vector<Value*> args;
    for (auto& arg : node->arguments) {
        Value* argVal = generate(arg.get());
        if (!argVal) {
            throw std::runtime_error("Failed to evaluate syscall argument");
        }
        args.push_back(argVal);
    }
    
    // TODO: Implement createSyscall() or call platform-specific syscall generation
    // For now, this is a placeholder that will be properly implemented when
    // the syscall infrastructure is added.
    
    // Map intrinsic names to syscall generation
    if (funcName == "intrinsic_open") {
        // TODO: return createSyscall(SYSCALL_OPEN, args, Type::getInt32Ty(ctx.llvmContext));
        throw std::runtime_error("Syscall intrinsics not yet implemented - need createSyscall() infrastructure");
    } else if (funcName == "intrinsic_close") {
        // TODO: return createSyscall(SYSCALL_CLOSE, args, Type::getInt32Ty(ctx.llvmContext));
        throw std::runtime_error("Syscall intrinsics not yet implemented - need createSyscall() infrastructure");
    } else if (funcName == "intrinsic_read") {
        // TODO: return createSyscall(SYSCALL_READ, args, Type::getInt64Ty(ctx.llvmContext));
        throw std::runtime_error("Syscall intrinsics not yet implemented - need createSyscall() infrastructure");
    } else if (funcName == "intrinsic_write") {
        // TODO: return createSyscall(SYSCALL_WRITE, args, Type::getInt64Ty(ctx.llvmContext));
        throw std::runtime_error("Syscall intrinsics not yet implemented - need createSyscall() infrastructure");
    } else if (funcName == "intrinsic_lseek") {
        // TODO: return createSyscall(SYSCALL_LSEEK, args, Type::getInt64Ty(ctx.llvmContext));
        throw std::runtime_error("Syscall intrinsics not yet implemented - need createSyscall() infrastructure");
    }
    
    return nullptr;
}

// -----------------------------------------------------------------------------
// Standard Function Calls Subsystem
// -----------------------------------------------------------------------------

Value* ExprCodeGen::visitCallExpr_Standard(frontend::CallExpr* node,
                                            Function* callee,
                                            Value* calleePtr,
                                            FunctionType* funcType) {
    // This is the final common path for function calls after all special cases
    // (intrinsics, member methods) have been filtered out.
    //
    // Handles:
    // 1. Argument evaluation
    // 2. Struct scalarization optimization (small structs → individual fields)
    // 3. Type casting to match parameter types
    // 4. Direct vs indirect vs closure call generation
    
    if (!callee && !calleePtr) {
        throw std::runtime_error("visitCallExpr_Standard called with no callee");
    }
    
    // Build argument list
    std::vector<Value*> args;
    
    // Get the function type for parameter type checking
    FunctionType* callFuncType = nullptr;
    if (callee) {
        callFuncType = callee->getFunctionType();
    } else if (funcType) {
        callFuncType = funcType;
    }
    
    // Track which parameters are scalarized (for struct optimization)
    size_t paramTypeIdx = 0;
    
    // =========================================================================
    // ARGUMENT PREPARATION: Evaluate, scalarize, and cast
    // =========================================================================
    
    for (size_t i = 0; i < node->arguments.size(); i++) {
        Value* argVal = generate(node->arguments[i].get());
        
        if (!argVal) {
            throw std::runtime_error("Failed to evaluate argument " + std::to_string(i));
        }
        
        // =====================================================================
        // OPTIMIZATION: Struct Scalarization
        // =====================================================================
        // Small structs (≤16 bytes) can be passed as individual scalar fields
        // instead of as a struct. This is an ABI optimization.
        // =====================================================================
        
        bool scalarized = false;
        
        if (argVal->getType()->isStructTy() && callFuncType) {
            auto* structType = cast<StructType>(argVal->getType());
            
            if (structType->isSized()) {
                uint64_t structSize = ctx.module->getDataLayout().getTypeAllocSize(structType);
                
                // Only scalarize if struct is small and function signature matches
                if (structSize > 0 && structSize <= 16) {
                    // Check if we have enough parameter slots for all fields
                    if (paramTypeIdx + structType->getNumElements() <= callFuncType->getNumParams()) {
                        // Verify types match (scalarized signature)
                        bool typesMatch = true;
                        for (unsigned fieldIdx = 0; fieldIdx < structType->getNumElements(); ++fieldIdx) {
                            if (callFuncType->getParamType(paramTypeIdx + fieldIdx) != 
                                structType->getElementType(fieldIdx)) {
                                typesMatch = false;
                                break;
                            }
                        }
                        
                        if (typesMatch) {
                            // Scalarize: extract and pass each field separately
                            for (unsigned fieldIdx = 0; fieldIdx < structType->getNumElements(); ++fieldIdx) {
                                Value* fieldVal = ctx.builder->CreateExtractValue(
                                    argVal, fieldIdx,
                                    "arg_field" + std::to_string(fieldIdx));
                                args.push_back(fieldVal);
                            }
                            paramTypeIdx += structType->getNumElements();
                            scalarized = true;
                        }
                    }
                }
            }
        }
        
        if (!scalarized) {
            // Standard argument passing (no scalarization)
            
            // Cast argument to match parameter type if needed
            if (callFuncType && paramTypeIdx < callFuncType->getNumParams()) {
                Type* expectedType = callFuncType->getParamType(paramTypeIdx);
                if (argVal->getType() != expectedType) {
                    // If both are integers, perform cast
                    if (argVal->getType()->isIntegerTy() && expectedType->isIntegerTy()) {
                        argVal = ctx.builder->CreateIntCast(argVal, expectedType, true);
                    }
                }
            }
            
            args.push_back(argVal);
            paramTypeIdx++;
        }
    }
    
    // =========================================================================
    // CALL GENERATION: Direct vs Indirect vs Closure
    // =========================================================================
    
    if (calleePtr) {
        // =======================================================================
        // INDIRECT CALL: Through function pointer or closure
        // =======================================================================
        
        Type* calleePtrType = calleePtr->getType();
        
        // Check if this is a closure struct {ptr funcPtr, ptr envPtr}
        bool isClosure = false;
        Value* closureStruct = calleePtr;
        
        // Detect closure type
        if (calleePtrType->isPointerTy()) {
            // Pointer to closure struct - assume it's a closure
            isClosure = true;
        } else if (calleePtrType->isStructTy()) {
            StructType* structType = cast<StructType>(calleePtrType);
            if (structType->getNumElements() == 2 &&
                structType->getElementType(0)->isPointerTy() &&
                structType->getElementType(1)->isPointerTy()) {
                isClosure = true;
            }
        }
        
        if (isClosure) {
            // ===================================================================
            // CLOSURE CALL: Extract funcPtr and envPtr, prepend env to args
            // ===================================================================
            
            Value* funcPtr;
            Value* envPtr;
            
            if (calleePtrType->isPointerTy()) {
                // Closure is behind a pointer - need GEP + Load
                // For opaque pointers, get struct type from alloca
                StructType* fatPtrType = nullptr;
                if (auto* allocaInst = dyn_cast<AllocaInst>(closureStruct)) {
                    fatPtrType = dyn_cast<StructType>(allocaInst->getAllocatedType());
                }
                
                if (!fatPtrType) {
                    throw std::runtime_error("Cannot determine closure struct type for '" + 
                                           node->function_name + "'");
                }
                
                // Extract function pointer (field 0)
                Value* funcPtrPtr = ctx.builder->CreateStructGEP(
                    fatPtrType, closureStruct, 0, "closure_func_ptr_ptr");
                funcPtr = ctx.builder->CreateLoad(
                    PointerType::getUnqual(ctx.llvmContext), funcPtrPtr, "closure_func_ptr");
                
                // Extract environment pointer (field 1)
                Value* envPtrPtr = ctx.builder->CreateStructGEP(
                    fatPtrType, closureStruct, 1, "closure_env_ptr_ptr");
                envPtr = ctx.builder->CreateLoad(
                    PointerType::getUnqual(ctx.llvmContext), envPtrPtr, "closure_env_ptr");
            } else {
                // Closure is a struct value - use ExtractValue
                funcPtr = ctx.builder->CreateExtractValue(closureStruct, 0, "closure_func_ptr");
                envPtr = ctx.builder->CreateExtractValue(closureStruct, 1, "closure_env_ptr");
            }
            
            // Prepend environment pointer to arguments
            std::vector<Value*> closureArgs;
            closureArgs.push_back(envPtr);
            closureArgs.insert(closureArgs.end(), args.begin(), args.end());
            
            // Build closure function type: (ptr env, ...params) -> result
            std::vector<Type*> paramTypes;
            paramTypes.push_back(PointerType::getUnqual(ctx.llvmContext)); // env
            if (funcType) {
                for (unsigned i = 0; i < funcType->getNumParams(); ++i) {
                    paramTypes.push_back(funcType->getParamType(i));
                }
            }
            Type* returnType = funcType ? funcType->getReturnType() : Type::getVoidTy(ctx.llvmContext);
            FunctionType* closureFuncType = FunctionType::get(returnType, paramTypes, false);
            
            // Generate closure call
            if (closureFuncType->getReturnType()->isVoidTy()) {
                return ctx.builder->CreateCall(closureFuncType, funcPtr, closureArgs);
            }
            return ctx.builder->CreateCall(closureFuncType, funcPtr, closureArgs, "closure_call");
            
        } else {
            // ===================================================================
            // REGULAR INDIRECT CALL: Through function pointer (not a closure)
            // ===================================================================
            
            if (!funcType) {
                throw std::runtime_error("Cannot perform indirect call without function type");
            }
            
            // Cast pointer if needed (shouldn't be necessary with opaque pointers)
            Value* funcPtr = calleePtr;
            
            // Generate indirect call
            if (funcType->getReturnType()->isVoidTy()) {
                return ctx.builder->CreateCall(funcType, funcPtr, args);
            }
            return ctx.builder->CreateCall(funcType, funcPtr, args, "calltmp");
        }
        
    } else {
        // =======================================================================
        // DIRECT CALL: Through known function
        // =======================================================================
        
        if (!callee) {
            throw std::runtime_error("Direct call with no callee function");
        }
        
        // Void functions shouldn't have result names
        if (callee->getReturnType()->isVoidTy()) {
            return ctx.builder->CreateCall(callee, args);
        }
        return ctx.builder->CreateCall(callee, args, "calltmp");
    }
}

// ================================================================
// SIMD VECTOR INTRINSICS
// Handles: dot, cross, length, normalize
// ================================================================
Value* ExprCodeGen::visitCallExpr_SIMD(frontend::CallExpr* node) {
    using namespace llvm;
    
    std::string funcName = node->function_name;
    
    // Dot product: dot(vec, vec) -> scalar
    if (funcName == "dot" && node->arguments.size() == 2) {
        Value* v1 = generate(node->arguments[0].get());
        Value* v2 = generate(node->arguments[1].get());
        
        if (v1 && v2 && v1->getType()->isVectorTy() && v2->getType()->isVectorTy()) {
            auto* vecType = cast<FixedVectorType>(v1->getType());
            Type* elemType = vecType->getElementType();
            unsigned numElems = vecType->getNumElements();
            
            // Component-wise multiply
            Value* product = ctx.builder->CreateFMul(v1, v2, "dot_mul");
            
            // Horizontal sum using vector reduction
            // Extract and accumulate all elements
            Value* sum = Constant::getNullValue(elemType);
            for (unsigned i = 0; i < numElems; i++) {
                Value* elem = ctx.builder->CreateExtractElement(
                    product, ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), i), "dot_elem");
                sum = ctx.builder->CreateFAdd(sum, elem, "dot_sum");
            }
            return sum;
        }
    }
    
    // Cross product: cross(vec3, vec3) -> vec3 (only for 3D vectors)
    else if (funcName == "cross" && node->arguments.size() == 2) {
        Value* v1 = generate(node->arguments[0].get());
        Value* v2 = generate(node->arguments[1].get());
        
        if (v1 && v2 && v1->getType()->isVectorTy() && v2->getType()->isVectorTy()) {
            auto* vecType = cast<FixedVectorType>(v1->getType());
            // Note: vec3 is actually stored as vec4 (SIMD alignment), so check for >= 3
            if (vecType->getNumElements() >= 3) {
                // Cross product formula: (a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x)
                Type* i32 = Type::getInt32Ty(ctx.llvmContext);
                
                Value* ax = ctx.builder->CreateExtractElement(v1, ConstantInt::get(i32, 0), "ax");
                Value* ay = ctx.builder->CreateExtractElement(v1, ConstantInt::get(i32, 1), "ay");
                Value* az = ctx.builder->CreateExtractElement(v1, ConstantInt::get(i32, 2), "az");
                
                Value* bx = ctx.builder->CreateExtractElement(v2, ConstantInt::get(i32, 0), "bx");
                Value* by = ctx.builder->CreateExtractElement(v2, ConstantInt::get(i32, 1), "by");
                Value* bz = ctx.builder->CreateExtractElement(v2, ConstantInt::get(i32, 2), "bz");
                
                // X component: ay*bz - az*by
                Value* cx = ctx.builder->CreateFSub(
                    ctx.builder->CreateFMul(ay, bz, "ay_bz"),
                    ctx.builder->CreateFMul(az, by, "az_by"),
                    "cross_x"
                );
                
                // Y component: az*bx - ax*bz
                Value* cy = ctx.builder->CreateFSub(
                    ctx.builder->CreateFMul(az, bx, "az_bx"),
                    ctx.builder->CreateFMul(ax, bz, "ax_bz"),
                    "cross_y"
                );
                
                // Z component: ax*by - ay*bx
                Value* cz = ctx.builder->CreateFSub(
                    ctx.builder->CreateFMul(ax, by, "ax_by"),
                    ctx.builder->CreateFMul(ay, bx, "ay_bx"),
                    "cross_z"
                );
                
                // Build result vector
                Value* result = UndefValue::get(vecType);
                result = ctx.builder->CreateInsertElement(result, cx, ConstantInt::get(i32, 0), "cross_0");
                result = ctx.builder->CreateInsertElement(result, cy, ConstantInt::get(i32, 1), "cross_1");
                result = ctx.builder->CreateInsertElement(result, cz, ConstantInt::get(i32, 2), "cross_2");
                return result;
            }
        }
    }
    
    // Length (magnitude): length(vec) -> scalar = sqrt(dot(vec, vec))
    else if (funcName == "length" && node->arguments.size() == 1) {
        Value* v = generate(node->arguments[0].get());
        
        if (v && v->getType()->isVectorTy()) {
            auto* vecType = cast<FixedVectorType>(v->getType());
            Type* elemType = vecType->getElementType();
            unsigned numElems = vecType->getNumElements();
            
            // Compute dot product with itself
            Value* product = ctx.builder->CreateFMul(v, v, "len_sq");
            Value* sum = Constant::getNullValue(elemType);
            for (unsigned i = 0; i < numElems; i++) {
                Value* elem = ctx.builder->CreateExtractElement(
                    product, ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), i), "len_elem");
                sum = ctx.builder->CreateFAdd(sum, elem, "len_sum");
            }
            
            // sqrt(sum)
            Function* sqrtFn = Intrinsic::getDeclaration(
                ctx.module.get(),
                elemType->isFloatTy() ? Intrinsic::sqrt : Intrinsic::sqrt,
                {elemType}
            );
            return ctx.builder->CreateCall(sqrtFn, {sum}, "length");
        }
    }
    
    // Normalize: normalize(vec) -> vec / length(vec)
    else if (funcName == "normalize" && node->arguments.size() == 1) {
        Value* v = generate(node->arguments[0].get());
        
        if (v && v->getType()->isVectorTy()) {
            auto* vecType = cast<FixedVectorType>(v->getType());
            Type* elemType = vecType->getElementType();
            unsigned numElems = vecType->getNumElements();
            
            // Compute length
            Value* product = ctx.builder->CreateFMul(v, v, "norm_sq");
            Value* sum = Constant::getNullValue(elemType);
            for (unsigned i = 0; i < numElems; i++) {
                Value* elem = ctx.builder->CreateExtractElement(
                    product, ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), i), "norm_elem");
                sum = ctx.builder->CreateFAdd(sum, elem, "norm_sum");
            }
            
            Function* sqrtFn = Intrinsic::getDeclaration(
                ctx.module.get(),
                elemType->isFloatTy() ? Intrinsic::sqrt : Intrinsic::sqrt,
                {elemType}
            );
            Value* len = ctx.builder->CreateCall(sqrtFn, {sum}, "norm_len");
            
            // Broadcast scalar to vector
            Value* lenVec = UndefValue::get(vecType);
            for (unsigned i = 0; i < numElems; i++) {
                lenVec = ctx.builder->CreateInsertElement(
                    lenVec, len,
                    ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), i),
                    "norm_broadcast"
                );
            }
            
            // Divide vector by length vector
            return ctx.builder->CreateFDiv(v, lenVec, "normalized");
        }
    }
    
    // Not a SIMD intrinsic we recognize
    return nullptr;
}

// ================================================================
// WILDX MEMORY PROTECTION INTRINSICS
// Handles: protect_exec, protect_write, free_exec
// Maps to runtime functions for W^X enforcement
// ================================================================
Value* ExprCodeGen::visitCallExpr_WildX(frontend::CallExpr* node) {
    using namespace llvm;
    
    std::string funcName = node->function_name;
    std::string targetFunc;
    
    // Map user-facing names to runtime function names
    if (funcName == "aria.mem.protect_exec" || funcName == "protect_exec") {
        targetFunc = "aria_mem_protect_exec";
    } else if (funcName == "aria.mem.protect_write" || funcName == "protect_write") {
        targetFunc = "aria_mem_protect_write";
    } else if (funcName == "aria.mem.free_exec" || funcName == "free_exec") {
        targetFunc = "aria_free_exec";
    } else {
        // Not a WildX intrinsic
        return nullptr;
    }
    
    // These are just regular function calls to the runtime
    // Let the standard call handler take over with the remapped name
    // We need to temporarily modify the function name
    std::string originalName = node->function_name;
    node->function_name = targetFunc;
    
    // Look up the runtime function
    Function* callee = ctx.module->getFunction(targetFunc);
    if (!callee) {
        // Runtime function not declared - this would be a linker error
        // For now, return nullptr and let standard handler report error
        node->function_name = originalName; // Restore
        return nullptr;
    }
    
    // Restore original name for error messages
    node->function_name = originalName;
    
    // Delegate to standard call handler
    return visitCallExpr_Standard(node, callee, nullptr, nullptr);
}

} // namespace backend
} // namespace aria
