=== ARIA SOURCE PART 7: LSP SERVER (TOOLING) ===

FILE: include/tools/lsp/transport.h
====================================
#ifndef ARIA_LSP_TRANSPORT_H
#define ARIA_LSP_TRANSPORT_H

#include <string>
#include <optional>
#include <functional>
#include <mutex>
#include <nlohmann/json.hpp>

namespace aria {
namespace lsp {

using json = nlohmann::json;

/**
 * JSON-RPC 2.0 Message Types
 * 
 * As per research_034_lsp.txt Section 2.1.2:
 * - Request: Has id, requires response
 * - Notification: No id, fire-and-forget
 * - Response: Has id, result or error
 */
enum class MessageType {
    REQUEST,
    NOTIFICATION,
    RESPONSE
};

/**
 * Parsed JSON-RPC message with type information
 */
struct JsonRpcMessage {
    MessageType type;
    json content;
    
    // For requests/responses
    std::optional<json> id;
    
    // For requests/notifications
    std::optional<std::string> method;
    
    // For responses
    bool is_error = false;
};

/**
 * LSP Transport Layer
 * 
 * Implements the LSP header-based framing over stdin/stdout.
 * 
 * Critical Implementation Details (from research_034):
 * - Messages have Header Part + Content Part separated by \r\n\r\n
 * - Content-Length header specifies exact byte count
 * - MUST read exact byte count (not line-based or whitespace-delimited)
 * - Content-Type defaults to application/vscode-jsonrpc; charset=utf-8
 * 
 * Thread Safety:
 * - read() is NOT thread-safe (stdin is shared)
 * - write() uses internal mutex for thread-safe stdout access
 */
class Transport {
public:
    Transport();
    ~Transport();
    
    /**
     * Read one complete LSP message from stdin.
     * 
     * Returns std::nullopt on EOF or fatal error.
     * Throws std::runtime_error on parse errors (caught by main loop).
     * 
     * Implementation Strategy (research_034 Section 2.1.1):
     * 1. Read headers line-by-line until \r\n\r\n
     * 2. Extract Content-Length value
     * 3. Allocate exact-size buffer
     * 4. Read exact number of bytes (blocking)
     * 5. Parse JSON payload
     */
    std::optional<JsonRpcMessage> read();
    
    /**
     * Write a JSON-RPC message to stdout.
     * 
     * Thread-safe: Multiple worker threads can call concurrently.
     * Automatically adds LSP headers (Content-Length, Content-Type).
     */
    void write(const json& message);
    
    /**
     * Helper to construct JSON-RPC response
     */
    static json makeResponse(const json& id, const json& result);
    
    /**
     * Helper to construct JSON-RPC error response
     */
    static json makeError(const json& id, int code, const std::string& message);
    
    /**
     * Helper to construct JSON-RPC notification
     */
    static json makeNotification(const std::string& method, const json& params);

private:
    /**
     * Read headers until \r\n\r\n delimiter.
     * Returns Content-Length value.
     */
    int read_headers();
    
    /**
     * Read exact number of bytes from stdin.
     * Blocking call that fills the buffer completely.
     */
    std::string read_content(int content_length);
    
    /**
     * Parse JSON-RPC message and determine type
     */
    JsonRpcMessage parse_message(const std::string& content);
    
    // Mutex for thread-safe stdout writes
    std::mutex write_mutex_;
};

} // namespace lsp
} // namespace aria

#endif // ARIA_LSP_TRANSPORT_H



FILE: src/tools/lsp/transport.cpp
====================================
#include "tools/lsp/transport.h"
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <cstring>

namespace aria {
namespace lsp {

Transport::Transport() {
    // Disable stdio buffering for immediate I/O
    // Critical for stdin/stdout communication with editor
    std::ios::sync_with_stdio(false);
}

Transport::~Transport() = default;

std::optional<JsonRpcMessage> Transport::read() {
    try {
        // Step 1: Read headers to get Content-Length
        int content_length = read_headers();
        if (content_length <= 0) {
            return std::nullopt; // EOF or invalid
        }
        
        // Step 2: Read exact byte count of JSON payload
        std::string content = read_content(content_length);
        
        // Step 3: Parse JSON and determine message type
        JsonRpcMessage msg = parse_message(content);
        
        return msg;
        
    } catch (const std::exception& e) {
        // Log to stderr (VS Code captures this in Output panel)
        std::cerr << "Transport::read() error: " << e.what() << std::endl;
        return std::nullopt;
    }
}

int Transport::read_headers() {
    int content_length = -1;
    std::string line;
    
    // Read headers line by line until we hit the \r\n\r\n delimiter
    // Headers format:
    //   Content-Length: 123\r\n
    //   Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n
    //   \r\n
    while (std::getline(std::cin, line)) {
        // Remove \r if present (cross-platform compatibility)
        if (!line.empty() && line.back() == '\r') {
            line.pop_back();
        }
        
        // Empty line signals end of headers
        if (line.empty()) {
            break;
        }
        
        // Parse "Content-Length: NNN"
        const std::string prefix = "Content-Length: ";
        if (line.compare(0, prefix.size(), prefix) == 0) {
            try {
                content_length = std::stoi(line.substr(prefix.size()));
            } catch (...) {
                throw std::runtime_error("Invalid Content-Length header");
            }
        }
        
        // We ignore Content-Type (default is fine)
    }
    
    if (std::cin.eof()) {
        return -1; // Client closed connection
    }
    
    if (content_length <= 0) {
        throw std::runtime_error("Missing or invalid Content-Length header");
    }
    
    return content_length;
}

std::string Transport::read_content(int content_length) {
    // CRITICAL: Must read EXACT byte count (research_034 Section 2.1.1)
    // Cannot use std::cin >> or getline() - they stop at whitespace/newlines
    // Must use read() to get raw bytes
    
    std::string buffer;
    buffer.resize(content_length);
    
    std::cin.read(&buffer[0], content_length);
    
    if (std::cin.gcount() != content_length) {
        throw std::runtime_error("Failed to read complete message content");
    }
    
    return buffer;
}

JsonRpcMessage Transport::parse_message(const std::string& content) {
    JsonRpcMessage msg;
    
    try {
        msg.content = json::parse(content);
    } catch (const json::exception& e) {
        throw std::runtime_error(std::string("JSON parse error: ") + e.what());
    }
    
    // Determine message type based on JSON-RPC 2.0 spec (research_034 Table 1)
    
    // Check for 'id' field
    if (msg.content.contains("id")) {
        msg.id = msg.content["id"];
        
        // Has 'method' -> Request
        if (msg.content.contains("method")) {
            msg.type = MessageType::REQUEST;
            msg.method = msg.content["method"].get<std::string>();
        }
        // Has 'result' or 'error' -> Response
        else if (msg.content.contains("result") || msg.content.contains("error")) {
            msg.type = MessageType::RESPONSE;
            msg.is_error = msg.content.contains("error");
        }
        else {
            throw std::runtime_error("Message with id but no method/result/error");
        }
    }
    // No 'id' + has 'method' -> Notification
    else if (msg.content.contains("method")) {
        msg.type = MessageType::NOTIFICATION;
        msg.method = msg.content["method"].get<std::string>();
    }
    else {
        throw std::runtime_error("Invalid JSON-RPC message structure");
    }
    
    return msg;
}

void Transport::write(const json& message) {
    // Thread-safe write to stdout (research_034 Section 3.2.1)
    std::lock_guard<std::mutex> lock(write_mutex_);
    
    // Serialize JSON to string
    std::string content = message.dump();
    
    // Write LSP headers
    std::cout << "Content-Length: " << content.size() << "\r\n";
    std::cout << "Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n";
    std::cout << "\r\n";
    
    // Write JSON payload
    std::cout << content;
    std::cout.flush(); // Critical: ensure immediate delivery
}

json Transport::makeResponse(const json& id, const json& result) {
    return {
        {"jsonrpc", "2.0"},
        {"id", id},
        {"result", result}
    };
}

json Transport::makeError(const json& id, int code, const std::string& message) {
    return {
        {"jsonrpc", "2.0"},
        {"id", id},
        {"error", {
            {"code", code},
            {"message", message}
        }}
    };
}

json Transport::makeNotification(const std::string& method, const json& params) {
    return {
        {"jsonrpc", "2.0"},
        {"method", method},
        {"params", params}
    };
}

} // namespace lsp
} // namespace aria



FILE: include/tools/lsp/server.h
====================================
#ifndef ARIA_LSP_SERVER_H
#define ARIA_LSP_SERVER_H

#include "tools/lsp/transport.h"
#include "tools/lsp/vfs.h"
#include "frontend/diagnostics.h"
#include "frontend/lexer/lexer.h"
#include "frontend/parser/parser.h"
#include <string>
#include <atomic>

namespace aria {
namespace lsp {

/**
 * LSP Server State Machine
 * 
 * Per LSP spec, server transitions through states:
 * - Uninitialized -> initialized request -> Initialized
 * - Initialized -> shutdown request -> ShuttingDown
 * - ShuttingDown -> exit notification -> Exited
 */
enum class ServerState {
    UNINITIALIZED,
    INITIALIZED,
    SHUTTING_DOWN,
    EXITED
};

/**
 * Server Capabilities
 * 
 * Declares what features this LSP server supports.
 * Start simple, add more as we implement features.
 */
struct ServerCapabilities {
    // Text document synchronization (Phase 7.3.3)
    int textDocumentSync = 1; // Full sync (TextDocumentSyncKind::Full)
    
    // Hover provider (Phase 7.3.5)
    bool hoverProvider = false;
    
    // Go to definition (Phase 7.3.5)
    bool definitionProvider = false;
    
    // Document symbols (outline view)
    bool documentSymbolProvider = false;
    
    // Workspace symbols (global search)
    bool workspaceSymbolProvider = false;
    
    // Code completion
    bool completionProvider = false;
    
    // Diagnostics
    bool diagnosticProvider = false;
    
    json to_json() const {
        return {
            {"textDocumentSync", textDocumentSync},
            {"hoverProvider", hoverProvider},
            {"definitionProvider", definitionProvider},
            {"documentSymbolProvider", documentSymbolProvider},
            {"workspaceSymbolProvider", workspaceSymbolProvider},
            {"completionProvider", completionProvider},
            {"diagnosticProvider", diagnosticProvider}
        };
    }
};

/**
 * Aria Language Server
 * 
 * Main LSP server implementation. Handles:
 * - Lifecycle (initialize, shutdown, exit)
 * - Document synchronization (didOpen, didChange, didClose)
 * - Language features (hover, definition, etc.)
 * 
 * Architecture (from research_034):
 * - Main thread handles I/O and message routing
 * - Worker threads will handle actual compilation (Phase 7.3.6)
 * - GlobalState with read-write locks (Phase 7.3.6)
 */
class Server {
public:
    Server();
    ~Server();
    
    /**
     * Main server loop - reads messages and dispatches
     * Returns when exit notification received
     */
    void run();
    
private:
    // Transport layer
    Transport transport_;
    
    // Server state
    std::atomic<ServerState> state_;
    
    // Declared capabilities
    ServerCapabilities capabilities_;
    
    // Virtual file system
    VirtualFileSystem vfs_;
    
    // Request/notification handlers
    json handle_initialize(const json& params);
    void handle_initialized(const json& params);
    json handle_shutdown(const json& params);
    void handle_exit(const json& params);
    
    // Document synchronization handlers
    void handle_did_open(const json& params);
    void handle_did_change(const json& params);
    void handle_did_close(const json& params);
    void handle_did_save(const json& params);
    
    // Diagnostics
    void publish_diagnostics(const std::string& uri);
    void clear_diagnostics(const std::string& uri);
    json convert_diagnostic_to_lsp(const aria::Diagnostic& diag);
    
    // Navigation handlers
    json handle_hover(const json& params);
    json handle_definition(const json& params);
    
    // Message dispatcher
    void dispatch_message(const JsonRpcMessage& msg);
    void handle_request(const json& id, const std::string& method, const json& params);
    void handle_notification(const std::string& method, const json& params);
    
    // Error responses
    json error_response(int code, const std::string& message);
};

} // namespace lsp
} // namespace aria

#endif // ARIA_LSP_SERVER_H



FILE: src/tools/lsp/server.cpp
====================================
#include "tools/lsp/server.h"
#include <iostream>

namespace aria {
namespace lsp {

// JSON-RPC error codes (from spec)
constexpr int ERROR_PARSE_ERROR = -32700;
constexpr int ERROR_INVALID_REQUEST = -32600;
constexpr int ERROR_METHOD_NOT_FOUND = -32601;
constexpr int ERROR_INVALID_PARAMS = -32602;
constexpr int ERROR_INTERNAL_ERROR = -32603;
constexpr int ERROR_SERVER_NOT_INITIALIZED = -32002;
constexpr int ERROR_SERVER_ERROR_START = -32099;

Server::Server() : state_(ServerState::UNINITIALIZED) {
    // Start with minimal capabilities
    // We'll enable more as we implement features
    capabilities_.textDocumentSync = 1; // Full sync for now
    capabilities_.diagnosticProvider = true; // We can provide diagnostics!
    capabilities_.hoverProvider = true; // Show type info on hover
    capabilities_.definitionProvider = true; // Go to definition
}

Server::~Server() = default;

void Server::run() {
    std::cerr << "Aria Language Server starting..." << std::endl;
    
    // Main message loop
    while (state_.load() != ServerState::EXITED) {
        auto msg_opt = transport_.read();
        
        if (!msg_opt.has_value()) {
            // EOF or error - client disconnected
            std::cerr << "Client disconnected" << std::endl;
            break;
        }
        
        dispatch_message(msg_opt.value());
    }
    
    std::cerr << "Aria Language Server exiting..." << std::endl;
}

void Server::dispatch_message(const JsonRpcMessage& msg) {
    try {
        switch (msg.type) {
            case MessageType::REQUEST: {
                if (!msg.id.has_value() || !msg.method.has_value()) {
                    std::cerr << "Malformed request" << std::endl;
                    return;
                }
                
                json params = msg.content.contains("params") ? msg.content["params"] : json::object();
                handle_request(msg.id.value(), msg.method.value(), params);
                break;
            }
            
            case MessageType::NOTIFICATION: {
                if (!msg.method.has_value()) {
                    std::cerr << "Malformed notification" << std::endl;
                    return;
                }
                
                json params = msg.content.contains("params") ? msg.content["params"] : json::object();
                handle_notification(msg.method.value(), params);
                break;
            }
            
            case MessageType::RESPONSE: {
                // We don't send requests to client yet, so ignore responses
                std::cerr << "Ignoring response from client" << std::endl;
                break;
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error dispatching message: " << e.what() << std::endl;
    }
}

void Server::handle_request(const json& id, const std::string& method, const json& params) {
    std::cerr << "Request: " << method << std::endl;
    
    try {
        json result;
        
        if (method == "initialize") {
            result = handle_initialize(params);
        }
        else if (method == "shutdown") {
            result = handle_shutdown(params);
        }
        else if (method == "textDocument/hover") {
            result = handle_hover(params);
        }
        else if (method == "textDocument/definition") {
            result = handle_definition(params);
        }
        else {
            // Method not found
            json error = Transport::makeError(id, ERROR_METHOD_NOT_FOUND, 
                                              "Method not found: " + method);
            transport_.write(error);
            return;
        }
        
        // Send success response
        json response = Transport::makeResponse(id, result);
        transport_.write(response);
        
    } catch (const std::exception& e) {
        // Internal error
        json error = Transport::makeError(id, ERROR_INTERNAL_ERROR, 
                                          std::string("Internal error: ") + e.what());
        transport_.write(error);
    }
}

void Server::handle_notification(const std::string& method, const json& params) {
    std::cerr << "Notification: " << method << std::endl;
    
    try {
        if (method == "initialized") {
            handle_initialized(params);
        }
        else if (method == "exit") {
            handle_exit(params);
        }
        else if (method == "textDocument/didOpen") {
            handle_did_open(params);
        }
        else if (method == "textDocument/didChange") {
            handle_did_change(params);
        }
        else if (method == "textDocument/didClose") {
            handle_did_close(params);
        }
        else if (method == "textDocument/didSave") {
            handle_did_save(params);
        }
        else {
            // Unknown notification - ignore per spec (don't send response)
            std::cerr << "Unknown notification: " << method << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "Error handling notification: " << e.what() << std::endl;
        // Don't send response for notifications
    }
}

json Server::handle_initialize(const json& params) {
    std::cerr << "Handling initialize request" << std::endl;
    
    // Transition from UNINITIALIZED to INITIALIZED
    ServerState expected = ServerState::UNINITIALIZED;
    if (!state_.compare_exchange_strong(expected, ServerState::INITIALIZED)) {
        throw std::runtime_error("Server already initialized");
    }
    
    // Extract client info for logging
    if (params.contains("clientInfo")) {
        std::string clientName = params["clientInfo"].value("name", "unknown");
        std::string clientVersion = params["clientInfo"].value("version", "unknown");
        std::cerr << "Client: " << clientName << " " << clientVersion << std::endl;
    }
    
    // Build initialize result with our capabilities
    json result = {
        {"capabilities", capabilities_.to_json()},
        {"serverInfo", {
            {"name", "aria-ls"},
            {"version", "0.1.0"}
        }}
    };
    
    return result;
}

void Server::handle_initialized(const json& params) {
    std::cerr << "Client confirmed initialization" << std::endl;
    // Client is ready to receive requests/notifications from server
    // We could send workspace/configuration requests here if needed
}

json Server::handle_shutdown(const json& params) {
    std::cerr << "Handling shutdown request" << std::endl;
    
    // Transition to SHUTTING_DOWN
    state_.store(ServerState::SHUTTING_DOWN);
    
    // Return null per spec
    return nullptr;
}

void Server::handle_exit(const json& params) {
    std::cerr << "Handling exit notification" << std::endl;
    
    // Transition to EXITED - this will end the run() loop
    state_.store(ServerState::EXITED);
}

json Server::error_response(int code, const std::string& message) {
    return {
        {"code", code},
        {"message", message}
    };
}

// ============================================================================
// Document Synchronization
// ============================================================================

void Server::handle_did_open(const json& params) {
    // Extract document info
    // params: { textDocument: { uri, languageId, version, text } }
    
    if (!params.contains("textDocument")) {
        std::cerr << "didOpen: missing textDocument" << std::endl;
        return;
    }
    
    const json& doc = params["textDocument"];
    std::string uri = doc.value("uri", "");
    std::string text = doc.value("text", "");
    
    if (uri.empty()) {
        std::cerr << "didOpen: missing uri" << std::endl;
        return;
    }
    
    std::cerr << "Document opened: " << uri << " (" << text.size() << " bytes)" << std::endl;
    
    // Store in VFS
    vfs_.set_content(uri, text);
    
    // Publish diagnostics for this file
    publish_diagnostics(uri);
}

void Server::handle_did_change(const json& params) {
    // For Full Sync (TextDocumentSyncKind::Full = 1):
    // params: { textDocument: { uri, version }, contentChanges: [{ text }] }
    // contentChanges has exactly one element with full text
    
    if (!params.contains("textDocument") || !params.contains("contentChanges")) {
        std::cerr << "didChange: missing required fields" << std::endl;
        return;
    }
    
    std::string uri = params["textDocument"].value("uri", "");
    
    if (uri.empty()) {
        std::cerr << "didChange: missing uri" << std::endl;
        return;
    }
    
    // Get the new full text (Full Sync mode)
    const json& changes = params["contentChanges"];
    if (!changes.is_array() || changes.empty()) {
        std::cerr << "didChange: empty contentChanges" << std::endl;
        return;
    }
    
    std::string text = changes[0].value("text", "");
    
    std::cerr << "Document changed: " << uri << " (" << text.size() << " bytes)" << std::endl;
    
    // Update VFS
    vfs_.set_content(uri, text);
    
    // Publish updated diagnostics
    publish_diagnostics(uri);
}

void Server::handle_did_close(const json& params) {
    // params: { textDocument: { uri } }
    
    if (!params.contains("textDocument")) {
        std::cerr << "didClose: missing textDocument" << std::endl;
        return;
    }
    
    std::string uri = params["textDocument"].value("uri", "");
    
    if (uri.empty()) {
        std::cerr << "didClose: missing uri" << std::endl;
        return;
    }
    
    std::cerr << "Document closed: " << uri << std::endl;
    
    // Remove from VFS
    vfs_.remove(uri);
    
    // Clear diagnostics for this file
    clear_diagnostics(uri);
}

void Server::handle_did_save(const json& params) {
    // params: { textDocument: { uri }, text?: string }
    // We're using Full Sync, so we already have latest content from didChange
    // Just log it
    
    if (!params.contains("textDocument")) {
        std::cerr << "didSave: missing textDocument" << std::endl;
        return;
    }
    
    std::string uri = params["textDocument"].value("uri", "");
    std::cerr << "Document saved: " << uri << std::endl;
    
    // Could trigger additional actions here (e.g., run tests)
}

// ============================================================================
// Diagnostics Publishing
// ============================================================================

void Server::publish_diagnostics(const std::string& uri) {
    // Get file content from VFS
    auto content_opt = vfs_.get_content(uri);
    if (!content_opt.has_value()) {
        std::cerr << "Cannot publish diagnostics: file not in VFS: " << uri << std::endl;
        return;
    }
    
    std::string content = content_opt.value();
    
    try {
        // Create diagnostic engine
        aria::DiagnosticEngine diag_engine;
        
        // Lex the file
        aria::frontend::Lexer lexer(content);
        std::vector<aria::frontend::Token> tokens = lexer.tokenize();
        
        // Check for lexer errors
        if (!lexer.getErrors().empty()) {
            for (const auto& error : lexer.getErrors()) {
                // Parse error message to extract location
                // Format: "[Line X, Col Y] Error: message"
                size_t line_pos = error.find("Line ");
                size_t col_pos = error.find(", Col ");
                
                if (line_pos != std::string::npos && col_pos != std::string::npos) {
                    int line = std::stoi(error.substr(line_pos + 5, col_pos - line_pos - 5));
                    int col = std::stoi(error.substr(col_pos + 6));
                    
                    aria::SourceLocation loc(uri, line, col, 1);
                    
                    diag_engine.error(loc, error.substr(error.find("Error: ") + 7));
                }
            }
        }
        
        // Parse the tokens
        aria::Parser parser(tokens);
        try {
            auto ast = parser.parse();
            
            // Check for parser errors
            if (!parser.getErrors().empty()) {
                for (const auto& error : parser.getErrors()) {
                    // Similar parsing logic as above
                    size_t line_pos = error.find("line ");
                    size_t col_pos = error.find(", column ");
                    
                    if (line_pos != std::string::npos && col_pos != std::string::npos) {
                        int line = std::stoi(error.substr(line_pos + 5, col_pos - line_pos - 5));
                        int col = std::stoi(error.substr(col_pos + 9));
                        
                        aria::SourceLocation loc(uri, line, col, 1);
                        
                        // Extract error message
                        size_t msg_start = error.find(": ", col_pos);
                        if (msg_start != std::string::npos) {
                            diag_engine.error(loc, error.substr(msg_start + 2));
                        }
                    }
                }
            }
            
            // TODO: Semantic analysis would go here (Phase 7.3.5+)
            // TypeChecker, BorrowChecker, etc.
            
        } catch (const std::exception& e) {
            // Parser threw exception - create diagnostic
            aria::SourceLocation loc(uri, 1, 1, 1);
            diag_engine.error(loc, std::string("Parse error: ") + e.what());
        }
        
        // Convert diagnostics to LSP format
        json diagnostics_array = json::array();
        
        for (const auto& diag_ptr : diag_engine.diagnostics()) {
            diagnostics_array.push_back(convert_diagnostic_to_lsp(*diag_ptr));
        }
        
        // Build publishDiagnostics notification
        json notification = Transport::makeNotification("textDocument/publishDiagnostics", {
            {"uri", uri},
            {"diagnostics", diagnostics_array}
        });
        
        // Send to client
        transport_.write(notification);
        
        std::cerr << "Published " << diagnostics_array.size() << " diagnostics for " << uri << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "Error publishing diagnostics: " << e.what() << std::endl;
    }
}

void Server::clear_diagnostics(const std::string& uri) {
    // Send empty diagnostics array
    json notification = Transport::makeNotification("textDocument/publishDiagnostics", {
        {"uri", uri},
        {"diagnostics", json::array()}
    });
    
    transport_.write(notification);
    std::cerr << "Cleared diagnostics for " << uri << std::endl;
}

json Server::convert_diagnostic_to_lsp(const aria::Diagnostic& diag) {
    // Map severity (research_034 Table 2)
    int lsp_severity;
    switch (diag.level()) {
        case aria::DiagnosticLevel::NOTE:
            lsp_severity = 3; // Information
            break;
        case aria::DiagnosticLevel::WARNING:
            lsp_severity = 2; // Warning
            break;
        case aria::DiagnosticLevel::ERROR:
        case aria::DiagnosticLevel::FATAL:
            lsp_severity = 1; // Error
            break;
        default:
            lsp_severity = 1;
    }
    
    // Convert 1-based to 0-based indices (research_034 Section 5.1)
    const aria::SourceLocation& loc = diag.location();
    int lsp_line = loc.line - 1;
    int lsp_col = loc.column - 1;
    
    // Build LSP diagnostic
    json lsp_diag = {
        {"range", {
            {"start", {{"line", lsp_line}, {"character", lsp_col}}},
            {"end", {{"line", lsp_line}, {"character", lsp_col + loc.length}}}
        }},
        {"severity", lsp_severity},
        {"message", diag.message()},
        {"source", "aria"}
    };
    
    return lsp_diag;
}

json Server::handle_hover(const json& params) {
    // Extract position from params
    std::string uri = params["textDocument"]["uri"];
    int line = params["position"]["line"];  // 0-based
    int character = params["position"]["character"];  // 0-based
    
    std::cerr << "Hover request at " << uri << ":" << line << ":" << character << std::endl;
    
    // Get file content
    auto content = vfs_.get_content(uri);
    if (!content) {
        return nullptr;  // null means no hover info
    }
    
    // For Phase 7.3.5, we'll return basic hover info
    // TODO Phase 7.3.6+: Full semantic analysis with SymbolTable
    // For now, just show that hover is working with a placeholder
    
    // Parse to find token at position
    aria::frontend::Lexer lexer(*content);
    std::vector<aria::frontend::Token> tokens = lexer.tokenize();
    
    // Find token at cursor position (convert to 1-based for Aria)
    int aria_line = line + 1;
    int aria_col = character + 1;
    
    for (const auto& token : tokens) {
        if (token.line == aria_line && 
            token.column <= aria_col && 
            aria_col < token.column + static_cast<int>(token.lexeme.length())) {
            
            // Found token under cursor
            std::string hover_text = "**Token:** `" + token.lexeme + "`";
            
            // Build hover response
            json result = {
                {"contents", {
                    {"kind", "markdown"},
                    {"value", hover_text}
                }},
                {"range", {
                    {"start", {{"line", line}, {"character", token.column - 1}}},
                    {"end", {{"line", line}, {"character", token.column - 1 + static_cast<int>(token.lexeme.length())}}}
                }}
            };
            
            return result;
        }
    }
    
    // No token at position
    return nullptr;
}

json Server::handle_definition(const json& params) {
    // Extract position from params
    std::string uri = params["textDocument"]["uri"];
    int line = params["position"]["line"];  // 0-based
    int character = params["position"]["character"];  // 0-based
    
    std::cerr << "Go-to-definition request at " << uri << ":" << line << ":" << character << std::endl;
    
    // Get file content
    auto content = vfs_.get_content(uri);
    if (!content) {
        return nullptr;  // null means no definition found
    }
    
    // For Phase 7.3.5, we'll return basic placeholder functionality
    // TODO Phase 7.3.6+: Full semantic analysis with SymbolTable
    // For now, we'll just demonstrate the protocol works
    
    // Parse to find identifier at position
    aria::frontend::Lexer lexer(*content);
    std::vector<aria::frontend::Token> tokens = lexer.tokenize();
    
    // Find token at cursor position (convert to 1-based for Aria)
    int aria_line = line + 1;
    int aria_col = character + 1;
    
    for (size_t i = 0; i < tokens.size(); i++) {
        const auto& token = tokens[i];
        if (token.type == aria::frontend::TokenType::TOKEN_IDENTIFIER &&
            token.line == aria_line && 
            token.column <= aria_col && 
            aria_col < token.column + static_cast<int>(token.lexeme.length())) {
            
            // Found identifier under cursor
            // For Phase 7.3.5, just demonstrate the protocol works
            // TODO Phase 7.3.6+: Use SymbolTable to find actual declarations
            // For now, search for first occurrence of this identifier
            std::string target_name = token.lexeme;
            
            for (size_t j = 0; j < tokens.size(); j++) {
                if (tokens[j].type == aria::frontend::TokenType::TOKEN_IDENTIFIER &&
                    tokens[j].lexeme == target_name &&
                    j != i) {  // Not the same token
                    
                    // Found another occurrence - assume it's the declaration
                    const auto& decl_token = tokens[j];
                    json location = {
                        {"uri", uri},
                        {"range", {
                            {"start", {{"line", decl_token.line - 1}, {"character", decl_token.column - 1}}},
                            {"end", {{"line", decl_token.line - 1}, {"character", decl_token.column - 1 + static_cast<int>(decl_token.lexeme.length())}}}
                        }}
                    };
                    
                    return location;
                }
            }
            
            // No other occurrence found - return null
            return nullptr;
        }
    }
    
    // No identifier at position
    return nullptr;
}

} // namespace lsp
} // namespace aria



FILE: include/tools/lsp/vfs.h
====================================
#ifndef ARIA_LSP_VFS_H
#define ARIA_LSP_VFS_H

#include <string>
#include <vector>
#include <unordered_map>
#include <shared_mutex>
#include <optional>

namespace aria {
namespace lsp {

/**
 * Virtual File System
 * 
 * Maintains in-memory copy of files open in the editor.
 * Critical because editor content != disk content (unsaved changes).
 * 
 * Thread-safe: Multiple readers, single writer (std::shared_mutex).
 * Research_034: "The VFS should be implemented as a specialized class 
 * wrapping a std::unordered_map<std::string, std::string>"
 */
class VirtualFileSystem {
public:
    VirtualFileSystem() = default;
    
    /**
     * Add or update file content (didOpen, didChange)
     * Thread-safe: Acquires write lock
     */
    void set_content(const std::string& uri, const std::string& content);
    
    /**
     * Get file content
     * Thread-safe: Acquires read lock
     * Returns std::nullopt if file not in VFS
     */
    std::optional<std::string> get_content(const std::string& uri) const;
    
    /**
     * Remove file from VFS (didClose)
     * Thread-safe: Acquires write lock
     */
    void remove(const std::string& uri);
    
    /**
     * Check if file exists in VFS
     * Thread-safe: Acquires read lock
     */
    bool contains(const std::string& uri) const;
    
    /**
     * Get all open document URIs
     * Thread-safe: Acquires read lock
     */
    std::vector<std::string> get_open_documents() const;
    
    /**
     * Get number of open documents
     */
    size_t size() const;
    
private:
    // URI -> file content
    mutable std::shared_mutex mutex_;
    std::unordered_map<std::string, std::string> files_;
};

} // namespace lsp
} // namespace aria

#endif // ARIA_LSP_VFS_H



FILE: src/tools/lsp/vfs.cpp
====================================
#include "tools/lsp/vfs.h"
#include <mutex>
#include <algorithm>

namespace aria {
namespace lsp {

void VirtualFileSystem::set_content(const std::string& uri, const std::string& content) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    files_[uri] = content;
}

std::optional<std::string> VirtualFileSystem::get_content(const std::string& uri) const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    
    auto it = files_.find(uri);
    if (it != files_.end()) {
        return it->second;
    }
    return std::nullopt;
}

void VirtualFileSystem::remove(const std::string& uri) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    files_.erase(uri);
}

bool VirtualFileSystem::contains(const std::string& uri) const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return files_.find(uri) != files_.end();
}

std::vector<std::string> VirtualFileSystem::get_open_documents() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    
    std::vector<std::string> uris;
    uris.reserve(files_.size());
    
    for (const auto& pair : files_) {
        uris.push_back(pair.first);
    }
    
    return uris;
}

size_t VirtualFileSystem::size() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return files_.size();
}

} // namespace lsp
} // namespace aria
