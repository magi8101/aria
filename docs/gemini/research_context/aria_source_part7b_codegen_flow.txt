===================================
ARIA COMPILER SOURCE - PART 7b of 9
Backend: Control Flow & Flow CodeGen
===================================

--- src/backend/codegen_control_flow.h ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_control_flow.h
// PURPOSE: Control flow statement code generation (pick, loops)
////////////////////////////////////////////////////////////////
#ifndef ARIA_BACKEND_CODEGEN_CONTROL_FLOW_H
#define ARIA_BACKEND_CODEGEN_CONTROL_FLOW_H

#include "codegen_fwd.h"
#include "codegen_context.h"
#include "../frontend/ast.h"

#include <llvm/IR/Value.h>
#include <llvm/IR/BasicBlock.h>
#include <map>

namespace aria {

// Forward declarations
namespace frontend {
    class PickStmt;
    class TillLoop;
    class WhenLoop;
    class ForLoop;
    class WhileLoop;
    class IfStmt;
    class AstVisitor;
}

namespace backend {

class ControlFlowCodeGen {
    CodeGenContext& ctx;

public:
    explicit ControlFlowCodeGen(CodeGenContext& context) : ctx(context) {}

    // Pattern matching (pick statement)
    void visitPickStmt(frontend::PickStmt* node, frontend::AstVisitor* visitor);
    
    // Loop statements
    void visitTillLoop(frontend::TillLoop* node, frontend::AstVisitor* visitor);
    void visitWhenLoop(frontend::WhenLoop* node, frontend::AstVisitor* visitor);
    void visitForLoop(frontend::ForLoop* node, frontend::AstVisitor* visitor);
    void visitWhileLoop(frontend::WhileLoop* node, frontend::AstVisitor* visitor);
    
    // Conditional
    void visitIfStmt(frontend::IfStmt* node, frontend::AstVisitor* visitor);
    
    // Helper: Generate linear if-else case chain
    void generateLinearCaseChain(frontend::PickStmt* node, size_t startIdx, 
                                llvm::Function* func, llvm::BasicBlock* doneBB,
                                std::map<std::string, llvm::BasicBlock*>& labelBlocks,
                                frontend::AstVisitor* visitor);
};

} // namespace backend
} // namespace aria

#endif // ARIA_BACKEND_CODEGEN_CONTROL_FLOW_H



--- src/backend/codegen_control_flow.cpp ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_control_flow.cpp
// PURPOSE: Control flow statement code generation (pick pattern matching, loops)
////////////////////////////////////////////////////////////////

#include "codegen_control_flow.h"
#include "codegen_expr.h"
#include "../frontend/ast.h"
#include "../frontend/ast/stmt.h"
#include "../frontend/ast/control_flow.h"
#include "../frontend/ast/loops.h"

#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Instructions.h>

using namespace llvm;

namespace aria {
namespace backend {

// Import frontend types
using aria::frontend::PickCase;

// =============================================================================
// Pattern Matching: Pick Statement
// =============================================================================

void ControlFlowCodeGen::visitPickStmt(frontend::PickStmt* node, frontend::AstVisitor* visitor) {
    ExprCodeGen exprGen(ctx);
    Value* selector = exprGen.generate(node->selector.get());
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* doneBB = BasicBlock::Create(ctx.llvmContext, "pick_done");
    
    // Build label map for fall() targets
    std::map<std::string, BasicBlock*> labelBlocks;
    
    // First pass: create labeled blocks
    for (size_t i = 0; i < node->cases.size(); ++i) {
        auto& pcase = node->cases[i];
        if (!pcase.label.empty()) {
            BasicBlock* labelBB = BasicBlock::Create(ctx.llvmContext, "pick_label_" + pcase.label, func);
            labelBlocks[pcase.label] = labelBB;
        }
    }
    
    // Store label blocks in context for fall statements
    ctx.pickLabelBlocks = &labelBlocks;
    ctx.pickDoneBlock = doneBB;
    
    // =====================================================================
    // OPTIMIZATION: Group consecutive EXACT integer cases into SwitchInst
    // This converts O(N) linear search into O(1) jump table
    // =====================================================================
    
    // Check if we can use switch optimization
    bool canUseSwitch = selector->getType()->isIntegerTy();
    
    // Scan for consecutive EXACT cases at the start
    size_t exactCaseCount = 0;
    if (canUseSwitch) {
        for (size_t i = 0; i < node->cases.size(); ++i) {
            auto& pcase = node->cases[i];
            if (pcase.type == PickCase::EXACT && pcase.label.empty()) {
                // Check if value is a constant (required for switch)
                Value* caseVal = exprGen.generate(pcase.value_start.get());
                if (isa<ConstantInt>(caseVal)) {
                    exactCaseCount = i + 1;
                } else {
                    // Non-constant value - cannot use switch for remaining cases
                    break;
                }
            } else {
                // Different case type - stop grouping
                break;
            }
        }
    }
    
    // If we have 3+ consecutive EXACT constant cases, use SwitchInst
    if (exactCaseCount >= 3) {
        // Create switch instruction
        BasicBlock* defaultBB = BasicBlock::Create(ctx.llvmContext, "switch_default", func);
        SwitchInst* switchInst = ctx.builder->CreateSwitch(selector, defaultBB, exactCaseCount);
        
        // Add each exact case to the switch
        for (size_t i = 0; i < exactCaseCount; ++i) {
            auto& pcase = node->cases[i];
            Value* caseVal = exprGen.generate(pcase.value_start.get());
            auto* caseConst = cast<ConstantInt>(caseVal);
            
            // Create case body block
            BasicBlock* caseBodyBB = BasicBlock::Create(
                ctx.llvmContext, 
                "switch_case_" + std::to_string(i), 
                func
            );
            
            // Add to switch
            switchInst->addCase(caseConst, caseBodyBB);
            
            // Generate case body
            ctx.builder->SetInsertPoint(caseBodyBB);
            {
                ScopeGuard guard(ctx);
                pcase.body->accept(*visitor);
            }
            
            // Auto-break unless terminated
            if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                ctx.builder->CreateBr(doneBB);
            }
        }
        
        // Continue with remaining cases (if any) using linear chain
        ctx.builder->SetInsertPoint(defaultBB);
        
        // Process remaining cases (starting from exactCaseCount)
        size_t remainingStart = exactCaseCount;
        if (remainingStart < node->cases.size()) {
            // Fall through to linear case chain for remaining cases
            generateLinearCaseChain(node, remainingStart, func, doneBB, labelBlocks, visitor);
        } else {
            // All cases were handled by switch - jump to done
            ctx.builder->CreateBr(doneBB);
        }
        
    } else {
        // Use traditional linear if-else chain (original implementation)
        generateLinearCaseChain(node, 0, func, doneBB, labelBlocks, visitor);
    }
    
    func->insert(func->end(), doneBB);
    ctx.builder->SetInsertPoint(doneBB);
    
    // Clear pick context
    ctx.pickLabelBlocks = nullptr;
    ctx.pickDoneBlock = nullptr;
}

// Helper: Generate traditional linear if-else case chain
void ControlFlowCodeGen::generateLinearCaseChain(frontend::PickStmt* node, size_t startIdx, 
                                                 Function* func, BasicBlock* doneBB,
                                                 std::map<std::string, BasicBlock*>& labelBlocks,
                                                 frontend::AstVisitor* visitor) {
    ExprCodeGen exprGen(ctx);
    BasicBlock* nextCaseBB = nullptr;
    Value* selector = exprGen.generate(node->selector.get());
    
    // Second pass: generate case logic
    for (size_t i = startIdx; i < node->cases.size(); ++i) {
        auto& pcase = node->cases[i];
        
        // For labeled cases, jump directly to their block
        if (!pcase.label.empty()) {
            // Create unconditional branch to labeled block
            if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                ctx.builder->CreateBr(labelBlocks[pcase.label]);
            }
            
            // Set insert point to the labeled block
            ctx.builder->SetInsertPoint(labelBlocks[pcase.label]);
            
            // Generate body
            {
                ScopeGuard guard(ctx);
                pcase.body->accept(*visitor);
            }
            
            // Auto-break if no terminator
            if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                ctx.builder->CreateBr(doneBB);
            }
            
            // Create a new block for next case
            nextCaseBB = BasicBlock::Create(ctx.llvmContext, "case_next_" + std::to_string(i), func);
            ctx.builder->SetInsertPoint(nextCaseBB);
            continue;
        }
        
        // Regular case (not labeled)
        BasicBlock* caseBodyBB = BasicBlock::Create(ctx.llvmContext, "case_body_" + std::to_string(i), func);
        nextCaseBB = BasicBlock::Create(ctx.llvmContext, "case_next_" + std::to_string(i));
        
        // Generate condition based on case type
        Value* match = nullptr;
        
        switch (pcase.type) {
            case PickCase::WILDCARD:
                // (*) - always matches
                match = ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 1);
                break;
                
            case PickCase::EXACT: {
                // (value) - exact match
                Value* val = exprGen.generate(pcase.value_start.get());
                // Cast val to match selector type for comparison
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpEQ(selector, val, "pick_eq");
                break;
            }
            
            case PickCase::LESS_THAN: {
                // (<value) - less than
                Value* val = exprGen.generate(pcase.value_start.get());
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSLT(selector, val, "pick_lt");
                break;
            }
            
            case PickCase::GREATER_THAN: {
                // (>value) - greater than
                Value* val = exprGen.generate(pcase.value_start.get());
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSGT(selector, val, "pick_gt");
                break;
            }
            
            case PickCase::LESS_EQUAL: {
                // (<=value) - less or equal
                Value* val = exprGen.generate(pcase.value_start.get());
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSLE(selector, val, "pick_le");
                break;
            }
            
            case PickCase::GREATER_EQUAL: {
                // (>=value) - greater or equal
                Value* val = exprGen.generate(pcase.value_start.get());
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSGE(selector, val, "pick_ge");
                break;
            }
            
            case PickCase::RANGE: {
                // (start..end) or (start...end) - range match
                Value* start = exprGen.generate(pcase.value_start.get());
                Value* end = exprGen.generate(pcase.value_end.get());
                
                // Cast to match selector type for comparison
                if (start->getType() != selector->getType()) {
                    if (start->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        start = ctx.builder->CreateIntCast(start, selector->getType(), true);
                    }
                }
                if (end->getType() != selector->getType()) {
                    if (end->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        end = ctx.builder->CreateIntCast(end, selector->getType(), true);
                    }
                }
                
                // selector >= start
                Value* ge_start = ctx.builder->CreateICmpSGE(selector, start, "range_ge");
                
                // selector <= end (inclusive) or selector < end (exclusive)
                Value* le_end;
                if (pcase.is_range_exclusive) {
                    le_end = ctx.builder->CreateICmpSLT(selector, end, "range_lt");
                } else {
                    le_end = ctx.builder->CreateICmpSLE(selector, end, "range_le");
                }
                
                // Combined: ge_start && le_end
                match = ctx.builder->CreateAnd(ge_start, le_end, "range_match");
                break;
            }
            
            case PickCase::DESTRUCTURE_OBJ:
            case PickCase::DESTRUCTURE_ARR:
                // Complex destructuring - for now, always match
                // TODO: Implement full destructuring pattern matching
                match = ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 1);
                break;
                
            default:
                match = ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 0);
                break;
        }
        
        // Create conditional branch
        ctx.builder->CreateCondBr(match, caseBodyBB, nextCaseBB);
        
        // Generate case body
        ctx.builder->SetInsertPoint(caseBodyBB);
        {
            ScopeGuard guard(ctx);
            pcase.body->accept(*visitor);
        }
        
        // Auto-break (unless fallthrough via fall())
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(doneBB);
        }
        
        // Move to next case check
        func->insert(func->end(), nextCaseBB);
        ctx.builder->SetInsertPoint(nextCaseBB);
    }
    
    // Final fallthrough to done if no case matched
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(doneBB);
    }
}

// ============================================================================
// Loop Statements
// ============================================================================

using aria::frontend::TillLoop;
using aria::frontend::WhenLoop;
using aria::frontend::ForLoop;
using aria::frontend::WhileLoop;
using aria::frontend::IfStmt;
using aria::frontend::AstVisitor;

void ControlFlowCodeGen::visitTillLoop(TillLoop* node, AstVisitor* visitor) {
    // Till(limit, step) with '$' iterator
    // Positive step: counts from 0 to limit
    // Negative step: counts from limit to 0
    ExprCodeGen exprGen(ctx);
    Value* limit = exprGen.generate(node->limit.get());
    Value* step = exprGen.generate(node->step.get());

    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* preheader = ctx.builder->GetInsertBlock();
    BasicBlock* loopBB = BasicBlock::Create(ctx.llvmContext, "loop_body", func);
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "loop_exit", func);

    // Determine start value based on step sign
    // For positive step: start = 0, for negative step: start = limit
    Value* stepIsNegative = ctx.builder->CreateICmpSLT(step, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0));
    Value* startVal = ctx.builder->CreateSelect(stepIsNegative, limit, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0));

    ctx.builder->CreateBr(loopBB);
    ctx.builder->SetInsertPoint(loopBB);

    // PHI Node for '$'
    PHINode* iterVar = ctx.builder->CreatePHI(Type::getInt64Ty(ctx.llvmContext), 2, "$");
    iterVar->addIncoming(startVal, preheader);

    // Define '$' in scope and generate body
    {
        ScopeGuard guard(ctx);
        ctx.define("$", iterVar, false); // False = Value itself, not ref
        node->body->accept(*visitor);
    }

    // Increment (or decrement for negative step)
    Value* nextVal = ctx.builder->CreateAdd(iterVar, step, "next_val");
    iterVar->addIncoming(nextVal, ctx.builder->GetInsertBlock());

    // Condition: for positive step: nextVal < limit, for negative step: nextVal >= 0
    Value* condPos = ctx.builder->CreateICmpSLT(nextVal, limit, "cond_pos");
    Value* condNeg = ctx.builder->CreateICmpSGE(nextVal, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0), "cond_neg");
    Value* cond = ctx.builder->CreateSelect(stepIsNegative, condNeg, condPos, "loop_cond");
    
    ctx.builder->CreateCondBr(cond, loopBB, exitBB);

    ctx.builder->SetInsertPoint(exitBB);
}

void ControlFlowCodeGen::visitWhenLoop(WhenLoop* node, AstVisitor* visitor) {
    // When loop: when(condition) { body } then { success } end { failure }
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* loopCondBB = BasicBlock::Create(ctx.llvmContext, "when_cond", func);
    BasicBlock* loopBodyBB = BasicBlock::Create(ctx.llvmContext, "when_body", func);
    BasicBlock* thenBB = node->then_block ? BasicBlock::Create(ctx.llvmContext, "when_then") : nullptr;
    BasicBlock* endBB = node->end_block ? BasicBlock::Create(ctx.llvmContext, "when_end") : nullptr;
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "when_exit");
    
    // Jump to condition check
    ctx.builder->CreateBr(loopCondBB);
    ctx.builder->SetInsertPoint(loopCondBB);
    
    // Evaluate condition
    ExprCodeGen exprGen(ctx);
    Value* cond = exprGen.generate(node->condition.get());
    ctx.builder->CreateCondBr(cond, loopBodyBB, thenBB ? thenBB : (endBB ? endBB : exitBB));
    
    // Save loop context for break/continue
    // For when loops: break jumps to end block (early exit), continue jumps to condition
    BasicBlock* prevBreakTarget = ctx.currentLoopBreakTarget;
    BasicBlock* prevContinueTarget = ctx.currentLoopContinueTarget;
    ctx.currentLoopBreakTarget = endBB ? endBB : exitBB;  // Break goes to end block if present
    ctx.currentLoopContinueTarget = loopCondBB;
    
    // Loop body
    ctx.builder->SetInsertPoint(loopBodyBB);
    if (node->body) {
        ScopeGuard guard(ctx);
        node->body->accept(*visitor);
    }
    
    // Restore previous loop context
    ctx.currentLoopBreakTarget = prevBreakTarget;
    ctx.currentLoopContinueTarget = prevContinueTarget;
    
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(loopCondBB);  // Back to condition
    }
    
    // Then block (successful completion)
    if (thenBB) {
        func->insert(func->end(), thenBB);
        ctx.builder->SetInsertPoint(thenBB);
        if (node->then_block) {
            ScopeGuard guard(ctx);
            node->then_block->accept(*visitor);
        }
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(exitBB);
        }
    }
    
    // End block (early exit or no execution)
    if (endBB) {
        func->insert(func->end(), endBB);
        ctx.builder->SetInsertPoint(endBB);
        if (node->end_block) {
            ScopeGuard guard(ctx);
            node->end_block->accept(*visitor);
        }
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(exitBB);
        }
    }
    
    // Exit
    func->insert(func->end(), exitBB);
    ctx.builder->SetInsertPoint(exitBB);
}

void ControlFlowCodeGen::visitForLoop(ForLoop* node, AstVisitor* visitor) {
    // For loop: for iter in iterable { body }
    // Note: For now, simplified implementation assuming iterable is a range
    // Full implementation would need iterator protocol
    
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* loopCondBB = BasicBlock::Create(ctx.llvmContext, "for_cond", func);
    BasicBlock* loopBodyBB = BasicBlock::Create(ctx.llvmContext, "for_body", func);
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "for_exit");
    
    // For simplified implementation, treat iterable as a value to iterate over
    // In a full implementation, this would call iterator methods
    ExprCodeGen exprGen(ctx);
    Value* iterable = exprGen.generate(node->iterable.get());
    
    // Create iterator variable (simplified: just use the value directly)
    Value* startVal = ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0);
    
    ctx.builder->CreateBr(loopCondBB);
    ctx.builder->SetInsertPoint(loopCondBB);
    
    // PHI node for iterator
    PHINode* iterVar = ctx.builder->CreatePHI(Type::getInt64Ty(ctx.llvmContext), 2, node->iterator_name.c_str());
    iterVar->addIncoming(startVal, ctx.builder->GetInsertBlock()->getSinglePredecessor());
    
    // Extend iterable to i64 if needed for comparison
    if (iterable->getType() != Type::getInt64Ty(ctx.llvmContext)) {
        if (iterable->getType()->isIntegerTy()) {
            iterable = ctx.builder->CreateSExtOrTrunc(iterable, Type::getInt64Ty(ctx.llvmContext));
        }
    }
    
    // Condition: iter < iterable (simplified)
    Value* cond = ctx.builder->CreateICmpSLT(iterVar, iterable, "for_cond");
    ctx.builder->CreateCondBr(cond, loopBodyBB, exitBB);
    
    // Loop body
    ctx.builder->SetInsertPoint(loopBodyBB);
    {
        ScopeGuard guard(ctx);
        ctx.define(node->iterator_name, iterVar, false);
        node->body->accept(*visitor);
    }
    
    // Increment iterator
    Value* nextIter = ctx.builder->CreateAdd(iterVar, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 1), "next_iter");
    iterVar->addIncoming(nextIter, ctx.builder->GetInsertBlock());
    
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(loopCondBB);
    }
    
    // Exit
    func->insert(func->end(), exitBB);
    ctx.builder->SetInsertPoint(exitBB);
}

void ControlFlowCodeGen::visitWhileLoop(WhileLoop* node, AstVisitor* visitor) {
    // While loop: while condition { body }
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* loopCondBB = BasicBlock::Create(ctx.llvmContext, "while_cond", func);
    BasicBlock* loopBodyBB = BasicBlock::Create(ctx.llvmContext, "while_body", func);
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "while_exit");
    
    // Jump to condition check
    ctx.builder->CreateBr(loopCondBB);
    ctx.builder->SetInsertPoint(loopCondBB);
    
    // Evaluate condition
    ExprCodeGen exprGen(ctx);
    Value* cond = exprGen.generate(node->condition.get());
    
    // Convert condition to bool (i1) if needed
    if (cond && cond->getType() != Type::getInt1Ty(ctx.llvmContext)) {
        // Compare to zero (false if zero, true otherwise)
        cond = ctx.builder->CreateICmpNE(
            cond,
            Constant::getNullValue(cond->getType()),
            "whilecond"
        );
    }
    
    ctx.builder->CreateCondBr(cond, loopBodyBB, exitBB);
    
    // Loop body
    ctx.builder->SetInsertPoint(loopBodyBB);
    
    // Save loop context for break/continue
    BasicBlock* prevBreakTarget = ctx.currentLoopBreakTarget;
    BasicBlock* prevContinueTarget = ctx.currentLoopContinueTarget;
    ctx.currentLoopBreakTarget = exitBB;
    ctx.currentLoopContinueTarget = loopCondBB;
    
    {
        ScopeGuard guard(ctx);
        node->body->accept(*visitor);
    }
    
    // Restore previous loop context
    ctx.currentLoopBreakTarget = prevBreakTarget;
    ctx.currentLoopContinueTarget = prevContinueTarget;
    
    // Jump back to condition (if no explicit control flow)
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(loopCondBB);
    }
    
    // Exit
    func->insert(func->end(), exitBB);
    ctx.builder->SetInsertPoint(exitBB);
}

// ============================================================================
// Conditional Statements
// ============================================================================

void ControlFlowCodeGen::visitIfStmt(IfStmt* node, AstVisitor* visitor) {
    // Generate if-then-else control flow
    ExprCodeGen exprGen(ctx);
    Value* condVal = exprGen.generate(node->condition.get());
    if (!condVal) return;
    
    // Convert condition to bool (i1)
    if (condVal->getType() != Type::getInt1Ty(ctx.llvmContext)) {
        // Compare to zero (false if zero, true otherwise)
        condVal = ctx.builder->CreateICmpNE(
            condVal,
            Constant::getNullValue(condVal->getType()),
            "ifcond"
        );
    }
    
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    
    // Create blocks for then, else, and merge
    BasicBlock* thenBB = BasicBlock::Create(ctx.llvmContext, "then", func);
    BasicBlock* elseBB = node->else_block ? 
        BasicBlock::Create(ctx.llvmContext, "else") : nullptr;
    BasicBlock* mergeBB = BasicBlock::Create(ctx.llvmContext, "ifcont");
    
    // Branch based on condition
    if (elseBB) {
        ctx.builder->CreateCondBr(condVal, thenBB, elseBB);
    } else {
        ctx.builder->CreateCondBr(condVal, thenBB, mergeBB);
    }
    
    // Emit then block
    ctx.builder->SetInsertPoint(thenBB);
    if (node->then_block) {
        node->then_block->accept(*visitor);
    }
    // Branch to merge if no terminator
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(mergeBB);
    }
    
    // Emit else block if present
    if (elseBB) {
        func->insert(func->end(), elseBB);
        ctx.builder->SetInsertPoint(elseBB);
        if (node->else_block) {
            node->else_block->accept(*visitor);
        }
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(mergeBB);
        }
    }
    
    // Emit merge block
    func->insert(func->end(), mergeBB);
    ctx.builder->SetInsertPoint(mergeBB);
}

} // namespace backend
} // namespace aria



--- src/backend/codegen_flow.h ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_flow.h
// STATUS: NEW (Refactor Task 10 - Gemini Audit #2)
// PURPOSE: Control flow code generation (if, loops, pick, when)
////////////////////////////////////////////////////////////////
#ifndef ARIA_BACKEND_CODEGEN_FLOW_H
#define ARIA_BACKEND_CODEGEN_FLOW_H

#include "codegen_fwd.h"
#include "codegen_context.h"
#include "../frontend/ast.h"
#include "../frontend/ast/stmt.h"
#include "../frontend/ast/control_flow.h"
#include "../frontend/ast/loops.h"

namespace aria {
namespace backend {

// Forward declare the other generators
class ExprCodeGen;
class StmtCodeGen;

////////////////////////////////////////////////////////////////
// Control Flow Code Generator
// Handles conditional and loop constructs
////////////////////////////////////////////////////////////////
class FlowCodeGen {
    CodeGenContext& ctx;

public:
    explicit FlowCodeGen(CodeGenContext& context) : ctx(context) {}

    // Control flow generators
    void visitIfStmt(frontend::IfStmt* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor);
    void visitPickStmt(frontend::PickStmt* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor);
    void visitBlock(frontend::Block* node, ExprCodeGen& exprGen, StmtCodeGen& stmtGen);
    
    // Loop generators
    void visitForLoop(frontend::ForLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor);
    void visitWhileLoop(frontend::WhileLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor);
    void visitTillLoop(frontend::TillLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor);
    // void visitLoopStmt(frontend::LoopStmt* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor); // LoopStmt doesn't exist in AST
    void visitWhenLoop(frontend::WhenLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor);
    
    // Async constructs
    void visitAsyncBlock(frontend::AsyncBlock* node, ExprCodeGen& exprGen, StmtCodeGen& stmtGen);
};

} // namespace backend
} // namespace aria

#endif // ARIA_BACKEND_CODEGEN_FLOW_H



--- src/backend/codegen_flow.cpp ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_flow.cpp
// STATUS: NEW (Refactor Task 10 - Gemini Audit #2)
// PURPOSE: Control flow code generation (if, loops, pick, when)
////////////////////////////////////////////////////////////////

#include "codegen_flow.h"
#include "codegen_expr.h"
#include "codegen_stmt.h"
#include "../frontend/ast.h"
#include "../frontend/ast/stmt.h"
#include "../frontend/ast/expr.h"
#include "../frontend/ast/control_flow.h"
#include "../frontend/ast/loops.h"
#include <llvm/IR/Constants.h>

using namespace llvm;

namespace aria {
namespace backend {

// =============================================================================
// If Statement
// =============================================================================

void FlowCodeGen::visitIfStmt(frontend::IfStmt* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor) {
    Value* condVal = exprGen.generate(node->condition.get());
    if (!condVal) return;
    
    // Convert condition to bool (i1)
    if (condVal->getType() != Type::getInt1Ty(ctx.llvmContext)) {
        condVal = ctx.builder->CreateICmpNE(
            condVal,
            Constant::getNullValue(condVal->getType()),
            "ifcond"
        );
    }
    
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* thenBB = BasicBlock::Create(ctx.llvmContext, "then", func);
    BasicBlock* elseBB = node->else_block ? 
        BasicBlock::Create(ctx.llvmContext, "else") : nullptr;
    BasicBlock* mergeBB = BasicBlock::Create(ctx.llvmContext, "ifcont");
    
    if (elseBB) {
        ctx.builder->CreateCondBr(condVal, thenBB, elseBB);
    } else {
        ctx.builder->CreateCondBr(condVal, thenBB, mergeBB);
    }
    
    ctx.builder->SetInsertPoint(thenBB);
    if (node->then_block) {
        node->then_block->accept(visitor);
    }
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(mergeBB);
    }
    
    if (elseBB) {
        func->insert(func->end(), elseBB);
        ctx.builder->SetInsertPoint(elseBB);
        if (node->else_block) {
            node->else_block->accept(visitor);
        }
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(mergeBB);
        }
    }
    
    func->insert(func->end(), mergeBB);
    ctx.builder->SetInsertPoint(mergeBB);
}

// =============================================================================
// Block Statement
// =============================================================================

void FlowCodeGen::visitBlock(frontend::Block* node, ExprCodeGen& exprGen, StmtCodeGen& stmtGen) {
    if (!node) return;
    
    for (auto& stmt : node->statements) {
        stmt->accept(*reinterpret_cast<frontend::AstVisitor*>(this)); // Process each statement
    }
}

// =============================================================================
// For Loop
// =============================================================================

void FlowCodeGen::visitForLoop(frontend::ForLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor) {
    // For loop: for iter in iterable { body }
    // Handles Range expressions (1..10) and arrays
    
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* loopCondBB = BasicBlock::Create(ctx.llvmContext, "for_cond", func);
    BasicBlock* loopBodyBB = BasicBlock::Create(ctx.llvmContext, "for_body", func);
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "for_exit");
    
    Value* iterable = exprGen.generate(node->iterable.get());
    if (!iterable) {
        throw std::runtime_error("For loop: iterable expression evaluated to null");
    }
    
    // Check if iterable is a Range struct
    Value* startVal = nullptr;
    Value* endVal = nullptr;
    Value* stepVal = nullptr;
    bool isExclusive = false;
    Type* iterType = nullptr;
    
    if (auto* rangeStructTy = dyn_cast<StructType>(iterable->getType())) {
        if (rangeStructTy->getName().starts_with("Range")) {
            // Unpack Range struct: { start, end, step, is_exclusive }
            Value* rangeAlloca = ctx.builder->CreateAlloca(rangeStructTy, nullptr, "range_temp");
            ctx.builder->CreateStore(iterable, rangeAlloca);
            
            // Extract fields
            Value* startPtr = ctx.builder->CreateStructGEP(rangeStructTy, rangeAlloca, 0, "start_ptr");
            startVal = ctx.builder->CreateLoad(rangeStructTy->getElementType(0), startPtr, "range_start");
            
            Value* endPtr = ctx.builder->CreateStructGEP(rangeStructTy, rangeAlloca, 1, "end_ptr");
            endVal = ctx.builder->CreateLoad(rangeStructTy->getElementType(1), endPtr, "range_end");
            
            Value* stepPtr = ctx.builder->CreateStructGEP(rangeStructTy, rangeAlloca, 2, "step_ptr");
            stepVal = ctx.builder->CreateLoad(rangeStructTy->getElementType(2), stepPtr, "range_step");
            
            Value* exclusivePtr = ctx.builder->CreateStructGEP(rangeStructTy, rangeAlloca, 3, "exclusive_ptr");
            Value* exclusiveFlag = ctx.builder->CreateLoad(Type::getInt8Ty(ctx.llvmContext), exclusivePtr, "range_exclusive");
            Value* exclusiveBool = ctx.builder->CreateICmpNE(exclusiveFlag, ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 0));
            
            iterType = rangeStructTy->getElementType(0);
            isExclusive = true;
            
            // Adjust end value if exclusive
            endVal = ctx.builder->CreateSelect(exclusiveBool, endVal,
                ctx.builder->CreateAdd(endVal, ConstantInt::get(iterType, 1)), "adjusted_end");
        }
    }
    
    // If not a Range, fall back to simple iteration (0..iterable)
    if (!startVal) {
        iterType = Type::getInt64Ty(ctx.llvmContext);
        startVal = ConstantInt::get(iterType, 0);
        
        // Treat iterable as upper bound
        if (iterable->getType()->isIntegerTy()) {
            endVal = ctx.builder->CreateIntCast(iterable, iterType, true, "end_cast");
        } else {
            throw std::runtime_error("For loop: non-range iterable must be integer type");
        }
        
        stepVal = ConstantInt::get(iterType, 1);
    }
    
    // Create loop
    ctx.builder->CreateBr(loopCondBB);
    ctx.builder->SetInsertPoint(loopCondBB);
    
    // PHI node for iterator
    PHINode* iterVar = ctx.builder->CreatePHI(iterType, 2, node->iterator_name.c_str());
    iterVar->addIncoming(startVal, ctx.builder->GetInsertBlock()->getSinglePredecessor());
    
    // Condition: iter < end
    Value* cond = ctx.builder->CreateICmpSLT(iterVar, endVal, "for_cond");
    ctx.builder->CreateCondBr(cond, loopBodyBB, exitBB);
    
    // Loop body
    ctx.builder->SetInsertPoint(loopBodyBB);
    {
        ScopeGuard guard(ctx);
        ctx.define(node->iterator_name, iterVar, false);
        node->body->accept(visitor);
    }
    
    // Increment iterator
    Value* nextIter = ctx.builder->CreateAdd(iterVar, stepVal, "next_iter");
    iterVar->addIncoming(nextIter, ctx.builder->GetInsertBlock());
    
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(loopCondBB);
    }
    
    // Exit
    func->insert(func->end(), exitBB);
    ctx.builder->SetInsertPoint(exitBB);
}

// =============================================================================
// While Loop
// =============================================================================

void FlowCodeGen::visitWhileLoop(frontend::WhileLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor) {
    // While loop: while condition { body }
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* loopCondBB = BasicBlock::Create(ctx.llvmContext, "while_cond", func);
    BasicBlock* loopBodyBB = BasicBlock::Create(ctx.llvmContext, "while_body", func);
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "while_exit");
    
    // Jump to condition check
    ctx.builder->CreateBr(loopCondBB);
    ctx.builder->SetInsertPoint(loopCondBB);
    
    // Evaluate condition
    Value* cond = exprGen.generate(node->condition.get());
    
    // Convert condition to bool (i1) if needed
    if (cond && cond->getType() != Type::getInt1Ty(ctx.llvmContext)) {
        cond = ctx.builder->CreateICmpNE(
            cond,
            Constant::getNullValue(cond->getType()),
            "whilecond"
        );
    }
    
    ctx.builder->CreateCondBr(cond, loopBodyBB, exitBB);
    
    // Loop body
    ctx.builder->SetInsertPoint(loopBodyBB);
    
    // Save loop context for break/continue
    ctx.loopStack.push({exitBB, loopCondBB});
    
    {
        ScopeGuard guard(ctx);
        node->body->accept(visitor);
    }
    
    ctx.loopStack.pop();
    
    // Jump back to condition (if no explicit control flow)
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(loopCondBB);
    }
    
    // Exit
    func->insert(func->end(), exitBB);
    ctx.builder->SetInsertPoint(exitBB);
}

// =============================================================================
// Till Loop (Aria-specific)
// =============================================================================

void FlowCodeGen::visitTillLoop(frontend::TillLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor) {
    // Till(limit, step) with '$' iterator
    // Positive step: counts from 0 to limit
    // Negative step: counts from limit to 0
    Value* limit = exprGen.generate(node->limit.get());
    Value* step = exprGen.generate(node->step.get());

    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* preheader = ctx.builder->GetInsertBlock();
    BasicBlock* loopBB = BasicBlock::Create(ctx.llvmContext, "loop_body", func);
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "loop_exit");

    // Determine start value based on step sign
    Value* stepIsNegative = ctx.builder->CreateICmpSLT(step, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0));
    Value* startVal = ctx.builder->CreateSelect(stepIsNegative, limit, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0));

    ctx.builder->CreateBr(loopBB);
    ctx.builder->SetInsertPoint(loopBB);

    // PHI Node for '$'
    PHINode* iterVar = ctx.builder->CreatePHI(Type::getInt64Ty(ctx.llvmContext), 2, "$");
    iterVar->addIncoming(startVal, preheader);

    // Define '$' in scope and generate body
    {
        ScopeGuard guard(ctx);
        ctx.define("$", iterVar, false);
        node->body->accept(visitor);
    }

    // Increment (or decrement for negative step)
    Value* nextVal = ctx.builder->CreateAdd(iterVar, step, "next_val");
    iterVar->addIncoming(nextVal, ctx.builder->GetInsertBlock());

    // Condition: for positive step: nextVal < limit, for negative step: nextVal >= 0
    Value* condPos = ctx.builder->CreateICmpSLT(nextVal, limit, "cond_pos");
    Value* condNeg = ctx.builder->CreateICmpSGE(nextVal, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0), "cond_neg");
    Value* cond = ctx.builder->CreateSelect(stepIsNegative, condNeg, condPos, "loop_cond");
    
    ctx.builder->CreateCondBr(cond, loopBB, exitBB);

    ctx.builder->SetInsertPoint(exitBB);
}

// =============================================================================
// Loop Statement (loop(start, stop, step))
// =============================================================================

// void FlowCodeGen::visitLoopStmt(frontend::LoopStmt* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor) {
//     // loop(start, stop, step) with '$' iterator
//     // Dynamic direction: step >= 0 counts up, step < 0 counts down
//     Value* startVal = exprGen.generate(node->start.get());
//     Value* stopVal = exprGen.generate(node->stop.get());
//     Value* stepVal = exprGen.generate(node->step.get());
// 
//     Function* func = ctx.builder->GetInsertBlock()->getParent();
//     BasicBlock* preheader = ctx.builder->GetInsertBlock();
//     BasicBlock* headerBB = BasicBlock::Create(ctx.llvmContext, "loop_header", func);
//     BasicBlock* bodyBB = BasicBlock::Create(ctx.llvmContext, "loop_body", func);
//     BasicBlock* latchBB = BasicBlock::Create(ctx.llvmContext, "loop_latch", func);
//     BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "loop_exit", func);
// 
//     // Jump to header
//     ctx.builder->CreateBr(headerBB);
//     ctx.builder->SetInsertPoint(headerBB);
// 
//     // PHI node for '$' iterator
//     PHINode* iterVar = ctx.builder->CreatePHI(Type::getInt64Ty(ctx.llvmContext), 2, "$");
//     iterVar->addIncoming(startVal, preheader);
// 
//     // Dynamic direction check: step >= 0 means forward (iter <= stop), step < 0 means backward (iter >= stop)
//     Value* stepIsNegative = ctx.builder->CreateICmpSLT(stepVal, ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0), "step_neg");
//     Value* condForward = ctx.builder->CreateICmpSLE(iterVar, stopVal, "cond_fwd");
//     Value* condBackward = ctx.builder->CreateICmpSGE(iterVar, stopVal, "cond_bwd");
//     Value* loopCond = ctx.builder->CreateSelect(stepIsNegative, condBackward, condForward, "loop_cond");
//     
//     ctx.builder->CreateCondBr(loopCond, bodyBB, exitBB);
// 
//     // Save loop context for break/continue
//     ctx.loopStack.push({exitBB, latchBB});
// 
//     // Loop body
//     ctx.builder->SetInsertPoint(bodyBB);
//     {
//         ScopeGuard guard(ctx);
//         ctx.define("$", iterVar, false);
//         node->body->accept(visitor);
//     }
//     
//     if (!ctx.builder->GetInsertBlock()->getTerminator()) {
//         ctx.builder->CreateBr(latchBB);
//     }
// 
//     // Latch: increment and loop back
//     ctx.builder->SetInsertPoint(latchBB);
//     Value* nextVal = ctx.builder->CreateAdd(iterVar, stepVal, "next_iter");
//     iterVar->addIncoming(nextVal, latchBB);
//     ctx.builder->CreateBr(headerBB);
// 
//     // Restore loop context
//     ctx.loopStack.pop();
// 
//     // Exit block
//     ctx.builder->SetInsertPoint(exitBB);
// }

// =============================================================================
// When Loop
// =============================================================================

void FlowCodeGen::visitWhenLoop(frontend::WhenLoop* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor) {
    // When loop: when(condition) { body } then { success } end { failure }
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* loopCondBB = BasicBlock::Create(ctx.llvmContext, "when_cond", func);
    BasicBlock* loopBodyBB = BasicBlock::Create(ctx.llvmContext, "when_body", func);
    BasicBlock* thenBB = node->then_block ? BasicBlock::Create(ctx.llvmContext, "when_then") : nullptr;
    BasicBlock* endBB = node->end_block ? BasicBlock::Create(ctx.llvmContext, "when_end") : nullptr;
    BasicBlock* exitBB = BasicBlock::Create(ctx.llvmContext, "when_exit");
    
    // Jump to condition check
    ctx.builder->CreateBr(loopCondBB);
    ctx.builder->SetInsertPoint(loopCondBB);
    
    // Evaluate condition
    Value* cond = exprGen.generate(node->condition.get());
    ctx.builder->CreateCondBr(cond, loopBodyBB, thenBB ? thenBB : (endBB ? endBB : exitBB));
    
    // Save loop context for break/continue
    ctx.loopStack.push({endBB ? endBB : exitBB, loopCondBB});
    
    // Loop body
    ctx.builder->SetInsertPoint(loopBodyBB);
    if (node->body) {
        ScopeGuard guard(ctx);
        node->body->accept(visitor);
    }
    
    // Restore previous loop context
    ctx.loopStack.pop();
    
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(loopCondBB);
    }
    
    // Then block (successful completion)
    if (thenBB) {
        func->insert(func->end(), thenBB);
        ctx.builder->SetInsertPoint(thenBB);
        if (node->then_block) {
            ScopeGuard guard(ctx);
            node->then_block->accept(visitor);
        }
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(exitBB);
        }
    }
    
    // End block (early exit or no execution)
    if (endBB) {
        func->insert(func->end(), endBB);
        ctx.builder->SetInsertPoint(endBB);
        if (node->end_block) {
            ScopeGuard guard(ctx);
            node->end_block->accept(visitor);
        }
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(exitBB);
        }
    }
    
    // Exit
    func->insert(func->end(), exitBB);
    ctx.builder->SetInsertPoint(exitBB);
}

// =============================================================================
// Pick Statement (Pattern Matching)
// =============================================================================

// Helper: Generate linear case chain for pick statement
static void generateLinearCaseChain(CodeGenContext& ctx, ExprCodeGen& exprGen, 
                                    frontend::AstVisitor& visitor,
                                    frontend::PickStmt* node, size_t startIdx, Function* func, 
                                    BasicBlock* doneBB, std::map<std::string, BasicBlock*>& labelBlocks) {
    BasicBlock* nextCaseBB = nullptr;
    Value* selector = exprGen.generate(node->selector.get());
    
    // Second pass: generate case logic
    for (size_t i = startIdx; i < node->cases.size(); ++i) {
        auto& pcase = node->cases[i];
        
        // For labeled cases, jump directly to their block
        if (!pcase.label.empty()) {
            // Create unconditional branch to labeled block
            if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                ctx.builder->CreateBr(labelBlocks[pcase.label]);
            }
            
            // Set insert point to the labeled block
            ctx.builder->SetInsertPoint(labelBlocks[pcase.label]);
            
            // Generate body
            {
                ScopeGuard guard(ctx);
                pcase.body->accept(visitor);
            }
            
            // Auto-break if no terminator
            if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                ctx.builder->CreateBr(doneBB);
            }
            
            // Create a new block for next case
            nextCaseBB = BasicBlock::Create(ctx.llvmContext, "case_next_" + std::to_string(i), func);
            ctx.builder->SetInsertPoint(nextCaseBB);
            continue;
        }
        
        // Regular case (not labeled)
        BasicBlock* caseBodyBB = BasicBlock::Create(ctx.llvmContext, "case_body_" + std::to_string(i), func);
        nextCaseBB = BasicBlock::Create(ctx.llvmContext, "case_next_" + std::to_string(i));
        
        // Generate condition based on case type
        Value* match = nullptr;
        
        switch (pcase.type) {
            case frontend::PickCase::WILDCARD:
                // (*) - always matches
                match = ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 1);
                break;
                
            case frontend::PickCase::EXACT: {
                // (value) - exact match
                Value* val = exprGen.generate(pcase.value_start.get());
                // Cast val to match selector type for comparison
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpEQ(selector, val, "pick_eq");
                break;
            }
            
            case frontend::PickCase::LESS_THAN: {
                // (<value) - less than
                Value* val = exprGen.generate(pcase.value_start.get());
                // Cast val to match selector type for comparison
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSLT(selector, val, "pick_lt");
                break;
            }
            
            case frontend::PickCase::GREATER_THAN: {
                // (>value) - greater than
                Value* val = exprGen.generate(pcase.value_start.get());
                // Cast val to match selector type for comparison
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSGT(selector, val, "pick_gt");
                break;
            }
            
            case frontend::PickCase::LESS_EQUAL: {
                // (<=value) - less or equal
                Value* val = exprGen.generate(pcase.value_start.get());
                // Cast val to match selector type for comparison
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSLE(selector, val, "pick_le");
                break;
            }
            
            case frontend::PickCase::GREATER_EQUAL: {
                // (>=value) - greater or equal
                Value* val = exprGen.generate(pcase.value_start.get());
                // Cast val to match selector type for comparison
                if (val->getType() != selector->getType()) {
                    if (val->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        val = ctx.builder->CreateIntCast(val, selector->getType(), true);
                    }
                }
                match = ctx.builder->CreateICmpSGE(selector, val, "pick_ge");
                break;
            }
            
            case frontend::PickCase::RANGE: {
                // (start..end) or (start...end) - range match
                Value* start = exprGen.generate(pcase.value_start.get());
                Value* end = exprGen.generate(pcase.value_end.get());
                
                // Cast to match selector type for comparison
                if (start->getType() != selector->getType()) {
                    if (start->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        start = ctx.builder->CreateIntCast(start, selector->getType(), true);
                    }
                }
                if (end->getType() != selector->getType()) {
                    if (end->getType()->isIntegerTy() && selector->getType()->isIntegerTy()) {
                        end = ctx.builder->CreateIntCast(end, selector->getType(), true);
                    }
                }
                
                // selector >= start
                Value* ge_start = ctx.builder->CreateICmpSGE(selector, start, "range_ge");
                
                // selector <= end (inclusive) or selector < end (exclusive)
                Value* le_end;
                if (pcase.is_range_exclusive) {
                    le_end = ctx.builder->CreateICmpSLT(selector, end, "range_lt");
                } else {
                    le_end = ctx.builder->CreateICmpSLE(selector, end, "range_le");
                }
                
                // Combined: ge_start && le_end
                match = ctx.builder->CreateAnd(ge_start, le_end, "range_match");
                break;
            }
            
            case frontend::PickCase::DESTRUCTURE_OBJ: {
                // Object destructuring: pick point { { x, y } => ... }
                // Match is implicitly true if types align (type checker validated)
                if (!selector->getType()->isStructTy() && !selector->getType()->isPointerTy()) {
                    throw std::runtime_error("Cannot destructure non-struct type in pick pattern");
                }
                
                match = ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 1);
                
                // Create conditional branch to the body
                ctx.builder->CreateCondBr(match, caseBodyBB, nextCaseBB);
                
                // Generate Case Body with Variable Bindings
                ctx.builder->SetInsertPoint(caseBodyBB);
                {
                    ScopeGuard guard(ctx); // New scope for the bindings
                    
                    // Get struct type from selector
                    // Note: Semantic analyzer ensures selector is struct or pointer-to-struct
                    StructType* structType = nullptr;
                    Value* structPtr = selector;
                    
                    if (selector->getType()->isStructTy()) {
                        // Value type - need to create a temporary and get pointer
                        structType = cast<StructType>(selector->getType());
                        AllocaInst* tempAlloca = ctx.builder->CreateAlloca(structType, nullptr, "destruct_temp");
                        ctx.builder->CreateStore(selector, tempAlloca);
                        structPtr = tempAlloca;
                    } else if (selector->getType()->isPointerTy()) {
                        // Already a pointer - assume it points to a struct (validated by sema)
                        // With LLVM 18 opaque pointers, we need type info from AST
                        // TODO: Pass struct type through from semantic analysis
                        throw std::runtime_error("Destructuring pointer-to-struct requires type metadata (LLVM 18 opaque pointers)");
                    }
                    
                    if (!structType) {
                        throw std::runtime_error("Failed to extract struct type for destructuring");
                    }
                    
                    // Get struct name for field mapping
                    std::string structName = structType->hasName() ? structType->getName().str() : "";
                    
                    // Process destructuring pattern bindings
                    // Note: The pattern should be stored in pcase - this assumes parser provides it
                    // For now, implement basic field extraction by index
                    // TODO: Match by field name using ctx.structFieldMaps
                    
                    // Extract fields sequentially (simplified version)
                    // In full implementation, would match pattern field names to struct fields
                    for (unsigned idx = 0; idx < structType->getNumElements(); ++idx) {
                        // Generate binding name (e.g., field_0, field_1)
                        std::string bindName = "field_" + std::to_string(idx);
                        
                        // Extract field value
                        Value* fieldPtr = ctx.builder->CreateStructGEP(structType, structPtr, idx, bindName + "_ptr");
                        Type* fieldType = structType->getElementType(idx);
                        Value* fieldVal = ctx.builder->CreateLoad(fieldType, fieldPtr, bindName);
                        
                        // Register in local scope (simplified - real version uses pattern names)
                        // ctx.define(bindName, fieldVal, false);
                    }
                    
                    // Generate the actual body code
                    pcase.body->accept(visitor);
                }
                
                // Handle fallthrough/break
                if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                    ctx.builder->CreateBr(doneBB);
                }
                
                // Setup for next case
                func->insert(func->end(), nextCaseBB);
                ctx.builder->SetInsertPoint(nextCaseBB);
                continue; // Skip the normal flow below
            }
            
            case frontend::PickCase::DESTRUCTURE_ARR: {
                // Array destructuring: pick arr { [a, b, c] => ... }
                if (!selector->getType()->isArrayTy() && !selector->getType()->isPointerTy()) {
                    throw std::runtime_error("Cannot destructure non-array type in pick pattern");
                }
                
                match = ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 1);
                
                // Create conditional branch to the body
                ctx.builder->CreateCondBr(match, caseBodyBB, nextCaseBB);
                
                // Generate Case Body with Variable Bindings  
                ctx.builder->SetInsertPoint(caseBodyBB);
                {
                    ScopeGuard guard(ctx); // New scope for the bindings
                    
                    // Get array type from selector
                    // Note: Semantic analyzer ensures selector is array or pointer-to-array
                    ArrayType* arrayType = nullptr;
                    Value* arrayPtr = selector;
                    
                    if (selector->getType()->isArrayTy()) {
                        // Value type - create temporary and get pointer
                        arrayType = cast<ArrayType>(selector->getType());
                        AllocaInst* tempAlloca = ctx.builder->CreateAlloca(arrayType, nullptr, "arr_destruct_temp");
                        ctx.builder->CreateStore(selector, tempAlloca);
                        arrayPtr = tempAlloca;
                    } else if (selector->getType()->isPointerTy()) {
                        // Already a pointer - assume it points to an array (validated by sema)
                        // With LLVM 18 opaque pointers, we need type info from AST
                        // TODO: Pass array type through from semantic analysis
                        throw std::runtime_error("Destructuring pointer-to-array requires type metadata (LLVM 18 opaque pointers)");
                    }
                    
                    if (!arrayType) {
                        throw std::runtime_error("Failed to extract array type for destructuring");
                    }
                    
                    Type* elemType = arrayType->getElementType();
                    uint64_t arraySize = arrayType->getNumElements();
                    
                    // Extract array elements and bind to pattern variables
                    // Simplified version: bind to elem_0, elem_1, etc.
                    for (uint64_t idx = 0; idx < arraySize; ++idx) {
                        std::string bindName = "elem_" + std::to_string(idx);
                        
                        // GEP to array element
                        Value* indices[] = {
                            ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 0),
                            ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), idx)
                        };
                        Value* elemPtr = ctx.builder->CreateGEP(arrayType, arrayPtr, indices, bindName + "_ptr");
                        Value* elemVal = ctx.builder->CreateLoad(elemType, elemPtr, bindName);
                        
                        // Register in local scope
                        // ctx.define(bindName, elemVal, false);
                    }
                    
                    // Generate the actual body code
                    pcase.body->accept(visitor);
                }
                
                // Handle fallthrough/break
                if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                    ctx.builder->CreateBr(doneBB);
                }
                
                // Setup for next case
                func->insert(func->end(), nextCaseBB);
                ctx.builder->SetInsertPoint(nextCaseBB);
                continue; // Skip the normal flow below
            }
            
            case frontend::PickCase::UNREACHABLE:
                // Labeled case - already handled above
                continue;
                
            default:
                match = ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 0);
                break;
        }
        
        // Create conditional branch
        ctx.builder->CreateCondBr(match, caseBodyBB, nextCaseBB);
        
        // Generate case body
        ctx.builder->SetInsertPoint(caseBodyBB);
        {
            ScopeGuard guard(ctx);
            pcase.body->accept(visitor);
        }
        
        // Auto-break (unless fallthrough via fall())
        if (!ctx.builder->GetInsertBlock()->getTerminator()) {
            ctx.builder->CreateBr(doneBB);
        }
        
        // Move to next case check
        func->insert(func->end(), nextCaseBB);
        ctx.builder->SetInsertPoint(nextCaseBB);
    }
    
    // Final fallthrough to done if no case matched
    if (!ctx.builder->GetInsertBlock()->getTerminator()) {
        ctx.builder->CreateBr(doneBB);
    }
}

void FlowCodeGen::visitPickStmt(frontend::PickStmt* node, ExprCodeGen& exprGen, frontend::AstVisitor& visitor) {
    Value* selector = exprGen.generate(node->selector.get());
    Function* func = ctx.builder->GetInsertBlock()->getParent();
    BasicBlock* doneBB = BasicBlock::Create(ctx.llvmContext, "pick_done");
    
    // Build label map for fall() targets
    std::map<std::string, BasicBlock*> labelBlocks;
    
    // First pass: create labeled blocks
    for (size_t i = 0; i < node->cases.size(); ++i) {
        auto& pcase = node->cases[i];
        if (!pcase.label.empty()) {
            BasicBlock* labelBB = BasicBlock::Create(ctx.llvmContext, "pick_label_" + pcase.label, func);
            labelBlocks[pcase.label] = labelBB;
        }
    }
    
    // Store label blocks in context for fall statements
    ctx.pickLabelBlocks = &labelBlocks;
    ctx.pickDoneBlock = doneBB;
    
    // =====================================================================
    // OPTIMIZATION: Group consecutive EXACT integer cases into SwitchInst
    // This converts O(N) linear search into O(1) jump table
    // =====================================================================
    
    // Check if we can use switch optimization
    bool canUseSwitch = selector->getType()->isIntegerTy();
    
    // Scan for consecutive EXACT cases at the start
    size_t exactCaseCount = 0;
    if (canUseSwitch) {
        for (size_t i = 0; i < node->cases.size(); ++i) {
            auto& pcase = node->cases[i];
            if (pcase.type == frontend::PickCase::EXACT && pcase.label.empty()) {
                // Check if value is a constant (required for switch)
                Value* caseVal = exprGen.generate(pcase.value_start.get());
                if (isa<ConstantInt>(caseVal)) {
                    exactCaseCount = i + 1;
                } else {
                    // Non-constant value - cannot use switch for remaining cases
                    break;
                }
            } else {
                // Different case type - stop grouping
                break;
            }
        }
    }
    
    // If we have 3+ consecutive EXACT constant cases, use SwitchInst
    if (exactCaseCount >= 3) {
        // Create switch instruction
        BasicBlock* defaultBB = BasicBlock::Create(ctx.llvmContext, "switch_default", func);
        SwitchInst* switchInst = ctx.builder->CreateSwitch(selector, defaultBB, exactCaseCount);
        
        // Add each exact case to the switch
        for (size_t i = 0; i < exactCaseCount; ++i) {
            auto& pcase = node->cases[i];
            Value* caseVal = exprGen.generate(pcase.value_start.get());
            auto* caseConst = cast<ConstantInt>(caseVal);
            
            // Create case body block
            BasicBlock* caseBodyBB = BasicBlock::Create(
                ctx.llvmContext, 
                "switch_case_" + std::to_string(i), 
                func
            );
            
            // Add to switch
            switchInst->addCase(caseConst, caseBodyBB);
            
            // Generate case body
            ctx.builder->SetInsertPoint(caseBodyBB);
            {
                ScopeGuard guard(ctx);
                pcase.body->accept(visitor);
            }
            
            // Auto-break unless terminated
            if (!ctx.builder->GetInsertBlock()->getTerminator()) {
                ctx.builder->CreateBr(doneBB);
            }
        }
        
        // Continue with remaining cases (if any) using linear chain
        ctx.builder->SetInsertPoint(defaultBB);
        
        // Process remaining cases (starting from exactCaseCount)
        size_t remainingStart = exactCaseCount;
        if (remainingStart < node->cases.size()) {
            // Fall through to linear case chain for remaining cases
            generateLinearCaseChain(ctx, exprGen, visitor, node, remainingStart, func, doneBB, labelBlocks);
        } else {
            // All cases were handled by switch - jump to done
            ctx.builder->CreateBr(doneBB);
        }
        
    } else {
        // Use traditional linear if-else chain (original implementation)
        generateLinearCaseChain(ctx, exprGen, visitor, node, 0, func, doneBB, labelBlocks);
    }
    
    func->insert(func->end(), doneBB);
    ctx.builder->SetInsertPoint(doneBB);
    
    // Clear pick context
    ctx.pickLabelBlocks = nullptr;
    ctx.pickDoneBlock = nullptr;
}

// =============================================================================
// Async Block
// =============================================================================

void FlowCodeGen::visitAsyncBlock(frontend::AsyncBlock* node, ExprCodeGen& exprGen, StmtCodeGen& stmtGen) {
    // Stub - to be implemented
    // TODO: Extract async block generation from codegen.cpp
}

} // namespace backend
} // namespace aria
