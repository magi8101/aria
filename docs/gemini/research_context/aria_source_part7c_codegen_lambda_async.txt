===================================
ARIA COMPILER SOURCE - PART 7c of 9
Backend: Lambda & Async CodeGen
===================================

--- src/backend/codegen_lambda.h ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_lambda.h
// STATUS: NEW (Refactor Task - Lambda/Closure Module)
// PURPOSE: Lambda and closure code generation
////////////////////////////////////////////////////////////////

#ifndef ARIA_BACKEND_CODEGEN_LAMBDA_H
#define ARIA_BACKEND_CODEGEN_LAMBDA_H

#include "codegen_fwd.h"
#include "codegen_context.h"
#include "../frontend/ast.h"
#include "../frontend/ast/expr.h"

#include <llvm/IR/Value.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Type.h>

#include <vector>
#include <string>
#include <set>

namespace aria {
namespace frontend {
    class LambdaExpr;
    class Block;
    class Statement;
    class Expression;
}

namespace backend {

// Forward declarations
class CodeGenVisitor;
class ExprCodeGen;

////////////////////////////////////////////////////////////////
// Lambda/Closure Code Generator
// Handles lambda expressions, closure creation, and capture analysis
////////////////////////////////////////////////////////////////
class LambdaCodeGen {
    CodeGenContext& ctx;
    CodeGenVisitor* visitor;  // Visitor for delegating expression/statement generation
    
public:
    explicit LambdaCodeGen(CodeGenContext& context, CodeGenVisitor* vis) 
        : ctx(context), visitor(vis) {}
    
    // Main generation methods
    llvm::Value* generateAnonymousLambda(frontend::LambdaExpr* lambda);
    llvm::Function* generateNamedLambda(frontend::LambdaExpr* lambda, const std::string& name,
                                       llvm::StructType* envType = nullptr);
    
    // Closure environment management
    llvm::StructType* generateClosureEnvType(frontend::LambdaExpr* lambda, const std::string& envName);
    llvm::Value* allocateClosureEnv(llvm::StructType* envType);
    void populateClosureEnv(llvm::Value* envPtr, llvm::StructType* envType, frontend::LambdaExpr* lambda);
    
    // Lambda body generation
    void generateLambdaBody(frontend::LambdaExpr* lambda, llvm::Function* func, 
                           llvm::StructType* envType = nullptr);
    
    // Capture analysis
    std::vector<std::string> analyzeCapturedVariables(frontend::LambdaExpr* lambda);
    
    // Closure struct creation
    llvm::Value* createClosureStruct(llvm::Function* func, llvm::Value* envPtr);
    
private:
    // Helper methods for capture analysis
    void analyzeBlockForCaptures(frontend::Block* block, std::vector<std::string>& captured,
                                 std::set<std::string>& visited, const std::set<std::string>& localVars);
    void analyzeStmtForCaptures(frontend::Statement* stmt, std::vector<std::string>& captured,
                               std::set<std::string>& visited, const std::set<std::string>& localVars);
    void analyzeExprForCaptures(frontend::Expression* expr, std::vector<std::string>& captured,
                               std::set<std::string>& visited, const std::set<std::string>& localVars);
};

} // namespace backend
} // namespace aria

#endif // ARIA_BACKEND_CODEGEN_LAMBDA_H



--- src/backend/codegen_lambda.cpp ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_lambda.cpp
// STATUS: NEW (Refactor Task - Lambda/Closure Module)
// PURPOSE: Lambda and closure code generation
////////////////////////////////////////////////////////////////

#include "codegen_lambda.h"
#include "codegen_expr.h"
#include "../frontend/ast.h"
#include "../frontend/ast/expr.h"
#include "../frontend/ast/stmt.h"
#include "../frontend/ast/control_flow.h"
#include "../frontend/ast/loops.h"
#include <llvm/IR/Constants.h>
#include <llvm/IR/Intrinsics.h>
#include <llvm/IR/IRBuilder.h>
#include <algorithm>

using namespace llvm;

namespace aria {
namespace backend {

std::vector<std::string> LambdaCodeGen::analyzeCapturedVariables(aria::frontend::LambdaExpr* lambda) {
    std::vector<std::string> captured;
    std::set<std::string> visited;
    
    // Get parameter names (these are NOT captures)
    std::set<std::string> paramNames;
    for (const auto& param : lambda->parameters) {
        paramNames.insert(param.name);
    }
    
    // Recursively scan lambda body for variable references
    analyzeBlockForCaptures(lambda->body.get(), captured, visited, paramNames);
    
    return captured;
}

void LambdaCodeGen::analyzeBlockForCaptures(frontend::Block* block, std::vector<std::string>& captured,
                              std::set<std::string>& visited, const std::set<std::string>& localVars) {
    if (!block) return;
    
    for (auto& stmt : block->statements) {
        auto* statement = dynamic_cast<frontend::Statement*>(stmt.get());
        if (statement) {
            analyzeStmtForCaptures(statement, captured, visited, localVars);
        }
    }
}

void LambdaCodeGen::analyzeStmtForCaptures(frontend::Statement* stmt, std::vector<std::string>& captured,
                             std::set<std::string>& visited, const std::set<std::string>& localVars) {
    if (!stmt) return;
    
    // Variable declarations add to local scope
    if (auto* varDecl = dynamic_cast<frontend::VarDecl*>(stmt)) {
        // Don't capture variables declared inside the lambda
        const_cast<std::set<std::string>&>(localVars).insert(varDecl->name);
        if (varDecl->initializer) {
            analyzeExprForCaptures(varDecl->initializer.get(), captured, visited, localVars);
        }
        return;
    }
    
    // Expression statements
    if (auto* exprStmt = dynamic_cast<frontend::ExpressionStmt*>(stmt)) {
        analyzeExprForCaptures(exprStmt->expression.get(), captured, visited, localVars);
        return;
    }
    
    // Return statements
    if (auto* retStmt = dynamic_cast<frontend::ReturnStmt*>(stmt)) {
        if (retStmt->value) {
            analyzeExprForCaptures(retStmt->value.get(), captured, visited, localVars);
        }
        return;
    }
    
    // If statements
    if (auto* ifStmt = dynamic_cast<frontend::IfStmt*>(stmt)) {
        analyzeExprForCaptures(ifStmt->condition.get(), captured, visited, localVars);
        analyzeBlockForCaptures(ifStmt->then_block.get(), captured, visited, localVars);
        if (ifStmt->else_block) {
            analyzeBlockForCaptures(ifStmt->else_block.get(), captured, visited, localVars);
        }
        return;
    }
    
    // Loops
    if (auto* tillLoop = dynamic_cast<frontend::TillLoop*>(stmt)) {
        if (tillLoop->limit) {
            analyzeExprForCaptures(tillLoop->limit.get(), captured, visited, localVars);
        }
        if (tillLoop->step) {
            analyzeExprForCaptures(tillLoop->step.get(), captured, visited, localVars);
        }
        analyzeBlockForCaptures(tillLoop->body.get(), captured, visited, localVars);
        return;
    }
    
    if (auto* whileLoop = dynamic_cast<frontend::WhileLoop*>(stmt)) {
        analyzeExprForCaptures(whileLoop->condition.get(), captured, visited, localVars);
        analyzeBlockForCaptures(whileLoop->body.get(), captured, visited, localVars);
        return;
    }
}

void LambdaCodeGen::analyzeExprForCaptures(frontend::Expression* expr, std::vector<std::string>& captured,
                             std::set<std::string>& visited, const std::set<std::string>& localVars) {
    if (!expr) return;
    
    // Variable references - the key capture point
    if (auto* varExpr = dynamic_cast<frontend::VarExpr*>(expr)) {
        const std::string& varName = varExpr->name;
        
        // Skip if it's a local variable or parameter
        if (localVars.count(varName) > 0) return;
        
        // Skip if already visited
        if (visited.count(varName) > 0) return;
        
        // Check if it exists in an enclosing scope
        auto* sym = ctx.lookup(varName);
        if (sym && sym->strategy != CodeGenContext::AllocStrategy::VALUE) {
            // This is a capture! Add it if not already in list
            if (std::find(captured.begin(), captured.end(), varName) == captured.end()) {
                captured.push_back(varName);
                visited.insert(varName);
            }
        }
        return;
    }
    
    // Binary operations
    if (auto* binOp = dynamic_cast<frontend::BinaryOp*>(expr)) {
        analyzeExprForCaptures(binOp->left.get(), captured, visited, localVars);
        analyzeExprForCaptures(binOp->right.get(), captured, visited, localVars);
        return;
    }
    
    // Unary operations
    if (auto* unOp = dynamic_cast<frontend::UnaryOp*>(expr)) {
        analyzeExprForCaptures(unOp->operand.get(), captured, visited, localVars);
        return;
    }
    
    // Call expressions
    if (auto* call = dynamic_cast<frontend::CallExpr*>(expr)) {
        for (auto& arg : call->arguments) {
            analyzeExprForCaptures(arg.get(), captured, visited, localVars);
        }
        return;
    }
    
    // Array indexing
    if (auto* index = dynamic_cast<frontend::IndexExpr*>(expr)) {
        analyzeExprForCaptures(index->array.get(), captured, visited, localVars);
        analyzeExprForCaptures(index->index.get(), captured, visited, localVars);
        return;
    }
    
    // Note: Nested lambdas would need special handling - for now we skip them
    // as they create their own capture scope
}

// -------------------------------------------------------------------------
// Helper Methods for Closure Environment
// -------------------------------------------------------------------------

// Helper: Generate environment struct type for closure captures
StructType* LambdaCodeGen::generateClosureEnvType(aria::frontend::LambdaExpr* lambda, const std::string& envName) {
    if (!lambda->needs_heap_environment || lambda->captured_variables.empty()) {
        return nullptr;
    }
    
    std::vector<Type*> fieldTypes;
    for (const auto& captured : lambda->captured_variables) {
        if (!captured.is_global) {  // Only include local captures in environment
            Type* fieldType = ctx.getLLVMType(captured.type);
            fieldTypes.push_back(fieldType);
        }
    }
    
    if (fieldTypes.empty()) {
        return nullptr;
    }
    
    return StructType::create(ctx.llvmContext, fieldTypes, envName);
}

// Helper: Allocate closure environment on heap
Value* LambdaCodeGen::allocateClosureEnv(StructType* envType) {
    if (!envType) return nullptr;
    
    // Get or declare malloc
    FunctionType* mallocType = FunctionType::get(
        PointerType::getUnqual(ctx.llvmContext),
        {Type::getInt64Ty(ctx.llvmContext)},
        false
    );
    FunctionCallee mallocFunc = ctx.module->getOrInsertFunction("malloc", mallocType);
    
    // Calculate size of environment struct
    const DataLayout& DL = ctx.module->getDataLayout();
    uint64_t envSize = DL.getTypeAllocSize(envType);
    Value* size = ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), envSize);
    
    // Allocate environment
    Value* envPtr = ctx.builder->CreateCall(mallocFunc, {size}, "closure_env");
    
    return envPtr;
}

// Helper: Store captured values into environment
void LambdaCodeGen::populateClosureEnv(Value* envPtr, StructType* envType, aria::frontend::LambdaExpr* lambda) {
    if (!envPtr || !envType) return;
    
    unsigned fieldIdx = 0;
    for (const auto& captured : lambda->captured_variables) {
        if (!captured.is_global) {  // Only populate local captures
            // Look up the captured variable in current scope
            auto* sym = ctx.lookup(captured.name);
            if (sym && sym->val) {
                // Load the value if it's a reference
                Value* valueToStore = sym->val;
                if (sym->is_ref) {
                    valueToStore = ctx.builder->CreateLoad(
                        ctx.getLLVMType(captured.type),
                        sym->val,
                        captured.name + ".val"
                    );
                }
                
                // Get pointer to environment field
                Value* fieldPtr = ctx.builder->CreateStructGEP(
                    envType,
                    envPtr,
                    fieldIdx,
                    "env." + captured.name
                );
                
                // Store the value
                ctx.builder->CreateStore(valueToStore, fieldPtr);
            }
            fieldIdx++;
        }
    }
}

// -------------------------------------------------------------------------
// 1. Variable Declarations
// -------------------------------------------------------------------------

// Helper: Generate environment struct type for closure captures
void LambdaCodeGen::generateLambdaBody(aria::frontend::LambdaExpr* lambda, Function* func, StructType* envType) {
    // Set parameter names
    unsigned idx = 0;
    unsigned argIdx = 0;
    
    // If we have an environment, first arg is __env (already named)
    if (lambda->needs_heap_environment && envType) {
        argIdx = 1;  // Skip environment parameter when naming user parameters
    }
    
    for (auto argIt = func->arg_begin() + argIdx; argIt != func->arg_end(); ++argIt) {
        if (idx < lambda->parameters.size()) {
            argIt->setName(lambda->parameters[idx++].name);
        }
    }
    
    // Create entry basic block
    BasicBlock* entry = BasicBlock::Create(ctx.llvmContext, "entry", func);
    
    // Save previous state
    Function* prevFunc = ctx.currentFunction;
    BasicBlock* prevBlock = ctx.builder->GetInsertBlock();
    std::string prevReturnType = ctx.currentFunctionReturnType;
    bool prevAutoWrap = ctx.currentFunctionAutoWrap;
    
    ctx.currentFunction = func;
    
    // If we're in a generic monomorphization context (typeSubstitution is not empty),
    // currentFunctionReturnType has already been set to the substituted type.
    // Don't overwrite it with the lambda's original generic type.
    if (ctx.typeSubstitution.empty()) {
        ctx.currentFunctionReturnType = lambda->return_type;
    }
    // Otherwise, keep the already-set substituted return type
    
    ctx.currentFunctionAutoWrap = lambda->auto_wrap;
    ctx.builder->SetInsertPoint(entry);
    
    // ASYNC COROUTINE SETUP (if lambda is marked async)
    if (lambda->is_async) {
        // Get LLVM coroutine intrinsics
        Function* coroId = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_id
        );
        Function* coroBegin = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_begin
        );
        Function* coroSize = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_size, 
            {Type::getInt32Ty(ctx.llvmContext)}
        );
        Function* coroAlloc = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_alloc
        );
        
        // Create coroutine ID token
        Value* nullPtr = ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext));
        Value* coroIdVal = ctx.builder->CreateCall(
            coroId,
            {
                ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), 0),  // alignment
                nullPtr,  // promise
                nullPtr,  // coroaddr
                nullPtr   // fnaddr
            },
            "coro.id"
        );
        
        // Get coroutine frame size
        Value* size = ctx.builder->CreateCall(coroSize, {}, "coro.size");
        
        // Check if we need to allocate
        Value* needAlloc = ctx.builder->CreateCall(coroAlloc, {coroIdVal}, "coro.alloc");
        
        // Allocate coroutine frame using malloc
        // Get or declare malloc
        FunctionType* mallocType = FunctionType::get(
            PointerType::getUnqual(ctx.llvmContext),
            {Type::getInt32Ty(ctx.llvmContext)},
            false
        );
        FunctionCallee mallocFunc = ctx.module->getOrInsertFunction("malloc", mallocType);
        
        // Allocate frame
        Value* frame = ctx.builder->CreateCall(mallocFunc, {size}, "coro.frame");
        
        // Begin coroutine
        Value* hdl = ctx.builder->CreateCall(
            coroBegin,
            {coroIdVal, frame},
            "coro.handle"
        );
        
        // Store handle in a variable for later use
        AllocaInst* hdlAlloca = ctx.builder->CreateAlloca(
            hdl->getType(), 
            nullptr, 
            "coro.handle.addr"
        );
        ctx.builder->CreateStore(hdl, hdlAlloca);
        ctx.define("__coro_handle__", hdlAlloca, false, "void*");
    }
    
    // Clear defer stacks for new function
    ctx.deferStacks = std::vector<std::vector<frontend::Block*>>();
    ctx.deferStacks.emplace_back();
    
    // SHADOW STACK: Push frame for GC root tracking
    // Get or declare aria_shadow_stack_push_frame()
    FunctionType* pushFrameType = FunctionType::get(
        Type::getVoidTy(ctx.llvmContext),
        {},
        false
    );
    FunctionCallee pushFrameFunc = ctx.module->getOrInsertFunction(
        "aria_shadow_stack_push_frame",
        pushFrameType
    );
    ctx.builder->CreateCall(pushFrameFunc);
    
    // CLOSURE SUPPORT: Extract captured variables from environment
    if (lambda->needs_heap_environment && envType) {
        // First parameter is environment pointer
        Argument* envArg = func->arg_begin();
        
        // Extract each captured variable from environment
        unsigned fieldIdx = 0;
        for (const auto& captured : lambda->captured_variables) {
            if (!captured.is_global) {
                // Get pointer to environment field
                Value* fieldPtr = ctx.builder->CreateStructGEP(
                    envType,
                    envArg,
                    fieldIdx,
                    "env." + captured.name
                );
                
                // Load the captured value
                Type* fieldType = ctx.getLLVMType(captured.type);
                Value* capturedValue = ctx.builder->CreateLoad(
                    fieldType,
                    fieldPtr,
                    captured.name
                );
                
                // Store in alloca so it can be referenced in lambda body
                AllocaInst* alloca = ctx.builder->CreateAlloca(
                    fieldType,
                    nullptr,
                    captured.name + ".addr"
                );
                ctx.builder->CreateStore(capturedValue, alloca);
                
                // Register in symbol table
                ctx.define(captured.name, alloca, true, captured.type);
                
                fieldIdx++;
            }
        }
    }
    
    // Create allocas for parameters
    std::vector<std::pair<std::string, CodeGenContext::Symbol*>> savedSymbols;
    
    idx = 0;
    argIdx = 0;
    
    // Skip environment parameter if present
    if (lambda->needs_heap_environment && envType) {
        argIdx = 1;
    }
    
    for (auto argIt = func->arg_begin() + argIdx; argIt != func->arg_end(); ++argIt) {
        Type* argType = argIt->getType();
        AllocaInst* alloca = ctx.builder->CreateAlloca(argType, nullptr, argIt->getName());
        ctx.builder->CreateStore(&(*argIt), alloca);
        
        std::string argName = std::string(argIt->getName());
        auto* existingSym = ctx.lookup(argName);
        if (existingSym) {
            savedSymbols.push_back({argName, existingSym});
        }
        
        // Store parameter with its Aria type from the lambda parameter list
        std::string paramAriaType = lambda->parameters[idx].type;
        ctx.define(argName, alloca, true, paramAriaType);
        idx++; // Increment for next parameter
    }
    
    // Generate lambda body
    // TODO: Need visitor reference to call body->accept()
    // if (lambda->body) {
    //     lambda->body->accept(*this);
    // }
    
    // Add return if missing
    if (ctx.builder->GetInsertBlock()->getTerminator() == nullptr) {
        // Execute all defers before implicit return (LIFO order)
        if (!ctx.deferStacks.empty() && !ctx.deferStacks[0].empty()) {
            for (auto it = ctx.deferStacks[0].rbegin(); it != ctx.deferStacks[0].rend(); ++it) {
                // TODO: Need visitor reference
                // (*it)->accept(*this);
            }
        }
        
        // SHADOW STACK: Pop frame before return
        FunctionType* popFrameType = FunctionType::get(
            Type::getVoidTy(ctx.llvmContext),
            {},
            false
        );
        FunctionCallee popFrameFunc = ctx.module->getOrInsertFunction(
            "aria_shadow_stack_pop_frame",
            popFrameType
        );
        ctx.builder->CreateCall(popFrameFunc);
        
        Type* returnType = func->getReturnType();
        if (returnType->isVoidTy()) {
            ctx.builder->CreateRetVoid();
        } else {
            ctx.builder->CreateRet(Constant::getNullValue(returnType));
        }
    }
    
    // Restore previous symbols
    for (auto& pair : savedSymbols) {
        ctx.define(pair.first, pair.second->val, pair.second->is_ref);
    }
    
    // Generate resume wrapper for async functions
    // This bridges LLVM coroutines with the Aria scheduler's function-pointer model
    if (lambda->is_async) {
        // Create the resume wrapper function: void funcName_resume(void* handle)
        std::string resumeName = std::string(func->getName()) + "_resume";
        
        FunctionType* resumeType = FunctionType::get(
            Type::getVoidTy(ctx.llvmContext),
            {PointerType::getUnqual(ctx.llvmContext)},  // void* handle parameter
            false
        );
        
        Function* resumeFunc = Function::Create(
            resumeType,
            Function::ExternalLinkage,  // External so scheduler can call it
            resumeName,
            ctx.module.get()
        );
        
        // Generate the resume wrapper body
        BasicBlock* resumeEntry = BasicBlock::Create(ctx.llvmContext, "entry", resumeFunc);
        IRBuilder<> resumeBuilder(resumeEntry);
        
        // Get the handle parameter
        Value* handle = resumeFunc->arg_begin();
        handle->setName("handle");
        
        // Get llvm.coro.resume intrinsic
        Function* coroResume = Intrinsic::getDeclaration(
            ctx.module.get(),
            Intrinsic::coro_resume
        );
        
        // Call llvm.coro.resume(handle)
        resumeBuilder.CreateCall(coroResume, {handle});
        
        // Return void
        resumeBuilder.CreateRetVoid();
        
        // Store the resume function pointer in a global variable
        // so the scheduler can find it when setting up the CoroutineFrame
        std::string resumePtrName = std::string(func->getName()) + "_resume_ptr";
        GlobalVariable* resumePtr = new GlobalVariable(
            *ctx.module,
            resumeFunc->getType(),
            true,  // constant
            GlobalValue::ExternalLinkage,
            resumeFunc,
            resumePtrName
        );
    }
    
    // Restore previous function context
    ctx.currentFunction = prevFunc;
    ctx.currentFunctionReturnType = prevReturnType;
    ctx.currentFunctionAutoWrap = prevAutoWrap;
    if (prevBlock) {
        ctx.builder->SetInsertPoint(prevBlock);
    }
}




Value* LambdaCodeGen::createClosureStruct(Function* func, Value* envPtr) {
    // Define closure struct type if not already defined
    // %closure = type { ptr, ptr }  (function pointer, environment pointer)
    StructType* closureType = StructType::get(
        ctx.llvmContext,
        {
            PointerType::getUnqual(ctx.llvmContext),  // function pointer
            PointerType::getUnqual(ctx.llvmContext)   // environment pointer
        }
    );
    
    // Allocate closure struct on stack
    AllocaInst* closureAlloca = ctx.builder->CreateAlloca(closureType, nullptr, "closure");
    
    // Store function pointer
    Value* funcPtrField = ctx.builder->CreateStructGEP(closureType, closureAlloca, 0, "closure_func_ptr");
    ctx.builder->CreateStore(func, funcPtrField);
    
    // Store environment pointer (or null if no captures)
    Value* envPtrField = ctx.builder->CreateStructGEP(closureType, closureAlloca, 1, "closure_env_ptr");
    if (envPtr) {
        ctx.builder->CreateStore(envPtr, envPtrField);
    } else {
        // No environment - store null pointer
        Value* nullPtr = ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext));
        ctx.builder->CreateStore(nullPtr, envPtrField);
    }
    
    // Load and return the closure struct value
    return ctx.builder->CreateLoad(closureType, closureAlloca, "closure_val");
}

// -------------------------------------------------------------------------
// Helper: Closure Capture Analysis
// -------------------------------------------------------------------------


Value* LambdaCodeGen::generateAnonymousLambda(frontend::LambdaExpr* lambda) {
    // Generate anonymous function for lambda with closure support
    static int lambdaCounter = 0;
    std::string lambdaName = "lambda_" + std::to_string(lambdaCounter++);
    
    // 1. Analyze which variables are captured from enclosing scope
    std::vector<std::string> capturedVars = analyzeCapturedVariables(lambda);
    
    // 2. Create function type
    std::vector<Type*> paramTypes;
    
    // If we have captured variables, add hidden environment parameter as first arg
    StructType* envType = nullptr;
    if (!capturedVars.empty()) {
        std::vector<Type*> envFields;
        for (const auto& varName : capturedVars) {
            auto* sym = ctx.lookup(varName);
            if (sym) {
                // Store pointer to the captured variable
                Type* varType = sym->val->getType();
                if (!varType->isPointerTy()) {
                    varType = PointerType::getUnqual(ctx.llvmContext);
                }
                envFields.push_back(varType);
            }
        }
        
        // Create environment struct type
        std::string envTypeName = lambdaName + "_env";
        envType = StructType::create(ctx.llvmContext, envFields, envTypeName);
        
        // Add environment pointer as first parameter
        paramTypes.push_back(PointerType::getUnqual(ctx.llvmContext));
    }
    
    // Add regular parameters
    for (auto& param : lambda->parameters) {
        paramTypes.push_back(ctx.getLLVMType(param.type));
    }
    
    // Functions ALWAYS return result<T> where T is the declared return type
    // The return type in lambda->return_type is the VAL type, not the full result type
    Type* returnType = ctx.getResultType(lambda->return_type);
    FunctionType* funcType = FunctionType::get(returnType, paramTypes, false);
    
    // 2. Create function
    Function* func = Function::Create(
        funcType,
        Function::InternalLinkage,  // Internal linkage for lambdas
        lambdaName,
        ctx.module.get()
    );
    
    // 3. Set parameter names
    unsigned idx = 0;
    
    // If we have an environment, first parameter is the env pointer
    Value* envParam = nullptr;
    if (envType) {
        auto argIt = func->arg_begin();
        envParam = &(*argIt);
        envParam->setName("env");
        ++argIt;
        // Now set names for regular parameters
        for (unsigned i = 0; i < lambda->parameters.size(); ++i, ++argIt) {
            argIt->setName(lambda->parameters[i].name);
        }
    } else {
        // No environment, just set parameter names normally
        for (auto& arg : func->args()) {
            arg.setName(lambda->parameters[idx++].name);
        }
    }
    
    // 4. Create entry basic block
    BasicBlock* entry = BasicBlock::Create(ctx.llvmContext, "entry", func);
    
    // 5. Save previous state and set new function context
    Function* prevFunc = ctx.currentFunction;
    BasicBlock* prevBlock = ctx.builder->GetInsertBlock();
    std::string prevReturnType = ctx.currentFunctionReturnType;
    bool prevAutoWrap = ctx.currentFunctionAutoWrap;
    
    ctx.currentFunction = func;
    ctx.currentFunctionReturnType = lambda->return_type;  // Store VAL type for validation
    ctx.currentFunctionAutoWrap = lambda->auto_wrap;       // Store auto-wrap flag
    ctx.builder->SetInsertPoint(entry);
    
    // ASYNC COROUTINE SETUP (if lambda is marked async)
    if (lambda->is_async) {
        // Get LLVM coroutine intrinsics
        Function* coroId = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_id
        );
        Function* coroBegin = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_begin
        );
        Function* coroSize = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_size, 
            {Type::getInt32Ty(ctx.llvmContext)}
        );
        Function* coroAlloc = Intrinsic::getDeclaration(
            ctx.module.get(), 
            Intrinsic::coro_alloc
        );
        
        // Create coroutine ID token
        Value* nullPtr = ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext));
        Value* coroIdVal = ctx.builder->CreateCall(
            coroId,
            {
                ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), 0),  // alignment
                nullPtr,  // promise
                nullPtr,  // coroaddr
                nullPtr   // fnaddr
            },
            "coro.id"
        );
        
        // Get coroutine frame size
        Value* size = ctx.builder->CreateCall(coroSize, {}, "coro.size");
        
        // Check if we need to allocate
        Value* needAlloc = ctx.builder->CreateCall(coroAlloc, {coroIdVal}, "coro.alloc");
        
        // Allocate coroutine frame using malloc
        // Get or declare malloc
        FunctionType* mallocType = FunctionType::get(
            PointerType::getUnqual(ctx.llvmContext),
            {Type::getInt32Ty(ctx.llvmContext)},
            false
        );
        FunctionCallee mallocFunc = ctx.module->getOrInsertFunction("malloc", mallocType);
        
        // Allocate frame
        Value* frame = ctx.builder->CreateCall(mallocFunc, {size}, "coro.frame");
        
        // Begin coroutine
        Value* hdl = ctx.builder->CreateCall(
            coroBegin,
            {coroIdVal, frame},
            "coro.handle"
        );
        
        // Store handle in a variable for later use
        // (This will be needed for suspend/resume operations)
        AllocaInst* hdlAlloca = ctx.builder->CreateAlloca(
            hdl->getType(), 
            nullptr, 
            "coro.handle.addr"
        );
        ctx.builder->CreateStore(hdl, hdlAlloca);
        ctx.define("__coro_handle__", hdlAlloca, false, "void*");
    }
    
    // CRITICAL: Clear defer stacks for new function (defers don't persist across functions)
    ctx.deferStacks = std::vector<std::vector<frontend::Block*>>();
    ctx.deferStacks.emplace_back();  // Start with one scope for the function
    
    // 6. Set up captured variables from environment
    std::vector<std::pair<std::string, CodeGenContext::Symbol*>> savedSymbols;
    
    if (envParam && envType) {
        // Extract captured variables from environment struct
        for (unsigned i = 0; i < capturedVars.size(); ++i) {
            const std::string& varName = capturedVars[i];
            
            // Get pointer to field in environment struct
            Value* fieldPtr = ctx.builder->CreateStructGEP(
                envType, 
                envParam, 
                i, 
                varName + "_captured_ptr"
            );
            
            // Load the pointer to the captured variable
            Type* capturedPtrType = envType->getElementType(i);
            Value* capturedVarPtr = ctx.builder->CreateLoad(
                capturedPtrType,
                fieldPtr,
                varName + "_captured"
            );
            
            // Save existing symbol if any
            auto* existingSym = ctx.lookup(varName);
            if (existingSym) {
                savedSymbols.push_back({varName, existingSym});
            }
            
            // Define captured variable in lambda scope
            // Get the original Aria type from the symbol table
            auto* originalSym = ctx.lookup(varName);
            std::string ariaType = originalSym ? originalSym->ariaType : "";
            ctx.define(varName, capturedVarPtr, true, ariaType);
        }
    }
    
    // 7. Create allocas for regular parameters
    idx = 0;
    auto argIt = func->arg_begin();
    
    // Skip environment parameter if present
    if (envParam) ++argIt;
    
    for (unsigned i = 0; i < lambda->parameters.size(); ++i, ++argIt) {
        Value* arg = &(*argIt);
        Type* argType = arg->getType();
        AllocaInst* alloca = ctx.builder->CreateAlloca(argType, nullptr, arg->getName());
        ctx.builder->CreateStore(arg, alloca);
        
        // Save any existing symbol with this name
        std::string argName = std::string(arg->getName());
        auto* existingSym = ctx.lookup(argName);
        if (existingSym) {
            savedSymbols.push_back({argName, existingSym});
        }
        
        // Store parameter with its Aria type from the lambda parameter list
        std::string paramAriaType = lambda->parameters[i].type;
        ctx.define(argName, alloca, true, paramAriaType);
    }
    
    // 8. Generate lambda body
    // TODO: Need visitor reference to call body->accept()
    // if (lambda->body) {
    //     lambda->body->accept(*this);
    // }
    
    // 9. Add return if missing
    if (ctx.builder->GetInsertBlock()->getTerminator() == nullptr) {
        if (returnType->isVoidTy()) {
            ctx.builder->CreateRetVoid();
        } else {
            ctx.builder->CreateRet(Constant::getNullValue(returnType));
        }
    }
    
    // 9. Restore previous symbols
    for (auto& pair : savedSymbols) {
        ctx.define(pair.first, pair.second->val, pair.second->is_ref);
    }
    
    // 10. Restore previous function context
    ctx.currentFunction = prevFunc;
    ctx.currentFunctionReturnType = prevReturnType;
    ctx.currentFunctionAutoWrap = prevAutoWrap;
    if (prevBlock) {
        ctx.builder->SetInsertPoint(prevBlock);
    }
    
    // 11. Create environment struct if we have captures
    Value* envStruct = nullptr;
    if (envType && !capturedVars.empty()) {
        // Allocate environment struct on stack
        envStruct = ctx.builder->CreateAlloca(envType, nullptr, lambdaName + "_env_alloca");
        
        // Populate environment with pointers to captured variables
        for (unsigned i = 0; i < capturedVars.size(); ++i) {
            const std::string& varName = capturedVars[i];
            auto* sym = ctx.lookup(varName);
            if (sym) {
                // Get field pointer in environment struct
                Value* fieldPtr = ctx.builder->CreateStructGEP(
                    envType,
                    envStruct,
                    i,
                    varName + "_env_field_ptr"
                );
                
                // Store pointer to captured variable
                ctx.builder->CreateStore(sym->val, fieldPtr);
            }
        }
    }
    
    // 12. If immediately invoked, call the lambda
    if (lambda->is_immediately_invoked) {
        // Build arguments list
        std::vector<Value*> args;
        
        // First argument is environment if present
        if (envStruct) {
            args.push_back(envStruct);
        }
        
        // Then evaluate and add regular arguments
        unsigned paramOffset = envStruct ? 1 : 0;
        for (size_t i = 0; i < lambda->call_arguments.size(); i++) {
            // TODO: Need visitor reference for visitExpr
            Value* argVal = nullptr; // visitExpr(lambda->call_arguments[i].get());
            if (!argVal) {
                throw std::runtime_error("Failed to evaluate lambda argument");
            }
            
            // Cast argument to match parameter type if needed
            if ((i + paramOffset) < func->arg_size()) {
                Type* expectedType = func->getFunctionType()->getParamType(i + paramOffset);
                if (argVal->getType() != expectedType) {
                    // If both are integers, perform cast
                    if (argVal->getType()->isIntegerTy() && expectedType->isIntegerTy()) {
                        argVal = ctx.builder->CreateIntCast(argVal, expectedType, true);
                    }
                }
            }
            
            args.push_back(argVal);
        }
        
        // Call the lambda and return its result
        return ctx.builder->CreateCall(func, args, "lambda_result");
    } else {
        // Non-immediately-invoked lambda: Return as closure (fat pointer)
        // Closures with captures need heap-allocated environment
        Value* heapEnv = nullptr;
        
        if (!capturedVars.empty()) {
            // Allocate environment on heap (for escaping closures)
            // Calculate size of environment struct
            const DataLayout& DL = ctx.module->getDataLayout();
            uint64_t envSize = DL.getTypeAllocSize(envType);
            
            // Call aria.alloc to allocate heap memory
            Function* ariaAlloc = ctx.module->getFunction("aria.alloc");
            if (!ariaAlloc) {
                // Declare aria.alloc if not already declared
                FunctionType* allocType = FunctionType::get(
                    PointerType::getUnqual(ctx.llvmContext),
                    {Type::getInt64Ty(ctx.llvmContext)},
                    false
                );
                ariaAlloc = Function::Create(
                    allocType,
                    Function::ExternalLinkage,
                    "aria.alloc",
                    ctx.module.get()
                );
            }
            
            Value* sizeVal = ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), envSize);
            heapEnv = ctx.builder->CreateCall(ariaAlloc, {sizeVal}, "closure_env_heap");
            
            // Cast to environment struct type
            Value* typedHeapEnv = ctx.builder->CreateBitCast(
                heapEnv,
                PointerType::get(envType, 0),
                "closure_env_typed"
            );
            
            // Copy environment data from stack to heap
            if (envStruct) {
                for (unsigned i = 0; i < capturedVars.size(); ++i) {
                    // Load from stack environment
                    Value* stackFieldPtr = ctx.builder->CreateStructGEP(
                        envType, envStruct, i, "stack_field_ptr"
                    );
                    Type* fieldType = envType->getElementType(i);
                    Value* fieldValue = ctx.builder->CreateLoad(
                        fieldType, stackFieldPtr, "field_value"
                    );
                    
                    // Store to heap environment
                    Value* heapFieldPtr = ctx.builder->CreateStructGEP(
                        envType, typedHeapEnv, i, "heap_field_ptr"
                    );
                    ctx.builder->CreateStore(fieldValue, heapFieldPtr);
                }
            }
            
            // Use heap environment for closure
            heapEnv = typedHeapEnv;
        }
        
        // Create and return closure struct (fat pointer)
        return createClosureStruct(func, heapEnv);
    }
}


Function* LambdaCodeGen::generateNamedLambda(frontend::LambdaExpr* lambda, const std::string& name, StructType* envType) {
    // IMPORTANT: We need to pre-declare the function in the symbol table
    // BEFORE generating the lambda body, so recursive calls can find it.
    
    // Create function type
    std::vector<Type*> paramTypes;
    
    // CLOSURE SUPPORT: Add hidden environment pointer parameter if needed (or use provided envType)
    if (!envType && lambda->needs_heap_environment) {
        envType = generateClosureEnvType(lambda, name + "_env");
    }
    
    if (envType) {
        // Add ptr as first parameter
        paramTypes.push_back(PointerType::getUnqual(ctx.llvmContext));
    }
    
    for (auto& param : lambda->parameters) {
        paramTypes.push_back(ctx.getLLVMType(param.type));
    }
    
    // ASYNC FUNCTIONS: Return coroutine handle (ptr) instead of declared type
    Type* returnType;
    if (lambda->is_async) {
        returnType = PointerType::getUnqual(ctx.llvmContext);  // i8* coroutine handle
    } else {
        returnType = ctx.getResultType(lambda->return_type);
    }
    
    FunctionType* funcType = FunctionType::get(returnType, paramTypes, false);
    
    // Create function with module prefix if in a module
    std::string funcName = ctx.currentModulePrefix + name;
    
    // Create function with the FINAL name (not lambda_N)
    Function* func = Function::Create(
        funcType,
        Function::InternalLinkage,
        funcName,
        ctx.module.get()
    );
    
    // Set name for environment parameter if present
    if (lambda->needs_heap_environment && envType) {
        func->arg_begin()->setName("__env");
    }
    
    // CLOSURE SUPPORT: If we need heap environment, create and populate it
    Value* closureValue = nullptr;
    if (lambda->needs_heap_environment && envType) {
        // Allocate environment on heap
        Value* envPtr = allocateClosureEnv(envType);
        
        // Populate environment with captured values
        populateClosureEnv(envPtr, envType, lambda);
        
        // Create fat pointer structure {func_ptr, env_ptr}
        // For now, we'll store this as a struct in memory
        Type* fatPtrFields[] = {
            PointerType::getUnqual(ctx.llvmContext),  // func ptr
            PointerType::getUnqual(ctx.llvmContext)   // env ptr
        };
        StructType* fatPtrType = StructType::create(ctx.llvmContext, fatPtrFields, name + "_closure_t");
        
        // Allocate fat pointer on stack
        AllocaInst* fatPtrAlloca = ctx.builder->CreateAlloca(fatPtrType, nullptr, name + ".closure");
        
        // Store function pointer
        Value* funcPtrField = ctx.builder->CreateStructGEP(fatPtrType, fatPtrAlloca, 0);
        ctx.builder->CreateStore(func, funcPtrField);
        
        // Store environment pointer
        Value* envPtrField = ctx.builder->CreateStructGEP(fatPtrType, fatPtrAlloca, 1);
        ctx.builder->CreateStore(envPtr, envPtrField);
        
        closureValue = fatPtrAlloca;
    }
    
    // Now generate the lambda body (visitExpr will fill in the function)
    // We pass the pre-created function to be filled
    // Also pass the environment type so lambda body can extract captured variables
    generateLambdaBody(lambda, func, envType);
    

    return func;
}

} // namespace backend
} // namespace aria



--- src/backend/codegen_async.h ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_async.h
// STATUS: NEW (Refactor Task - AsyncCodeGen Module)
// PURPOSE: Async/await coroutine code generation
////////////////////////////////////////////////////////////////
#ifndef ARIA_BACKEND_CODEGEN_ASYNC_H
#define ARIA_BACKEND_CODEGEN_ASYNC_H

#include "codegen_fwd.h"
#include "codegen_context.h"
#include "../frontend/ast.h"
#include "../frontend/ast/expr.h"

namespace aria {
namespace backend {

// Forward declare the other generators
class ExprCodeGen;

////////////////////////////////////////////////////////////////
// Async/Coroutine Code Generator
// Handles async blocks, await expressions, and spawn expressions
// Uses LLVM coroutine intrinsics for suspend/resume semantics
////////////////////////////////////////////////////////////////
class AsyncCodeGen {
    CodeGenContext& ctx;

public:
    explicit AsyncCodeGen(CodeGenContext& context) : ctx(context) {}

    // Async constructs
    void visitAsyncBlock(frontend::AsyncBlock* node, frontend::AstVisitor& visitor);
    void visitAwaitExpr(frontend::AwaitExpr* node, ExprCodeGen& exprGen);
    void visitSpawnExpr(frontend::SpawnExpr* node, ExprCodeGen& exprGen);
    
    // Helper: Emit final suspend for async functions
    void emitAsyncFinalSuspend();
};

} // namespace backend
} // namespace aria

#endif // ARIA_BACKEND_CODEGEN_ASYNC_H



--- src/backend/codegen_async.cpp ---
////////////////////////////////////////////////////////////////
// FILE: src/backend/codegen_async.cpp
// STATUS: NEW (Refactor Task - AsyncCodeGen Module)
// PURPOSE: Async/await coroutine code generation
////////////////////////////////////////////////////////////////

#include "codegen_async.h"
#include "codegen_expr.h"
#include "../frontend/ast.h"
#include "../frontend/ast/expr.h"
#include "../frontend/ast/stmt.h"
#include <llvm/IR/Constants.h>
#include <llvm/IR/Intrinsics.h>
#include <llvm/IR/IRBuilder.h>

using namespace llvm;

namespace aria {
namespace backend {

// =============================================================================
// Async Block
// =============================================================================

void AsyncCodeGen::visitAsyncBlock(frontend::AsyncBlock* node, frontend::AstVisitor& visitor) {
    // async { body } catch (err:e) { catch_body }
    // Implements LLVM coroutine lowering for async/await support
    
    // 1. Create async function wrapper
    std::string asyncName = "__async_" + std::to_string(reinterpret_cast<uintptr_t>(node));
    
    // Async functions return an i8* handle (the coroutine handle)
    FunctionType* asyncFuncType = FunctionType::get(
        PointerType::getUnqual(ctx.llvmContext),  // Returns i8* handle
        {},  // No parameters (TODO: capture variables from outer scope)
        false
    );
    
    Function* asyncFn = Function::Create(
        asyncFuncType,
        Function::InternalLinkage,
        asyncName,
        ctx.module.get()
    );
    
    // 2. Save current context
    BasicBlock* callerBlock = ctx.builder->GetInsertBlock();
    Function* prevFunc = ctx.currentFunction;
    
    // 3. Setup async function entry block
    BasicBlock* entry = BasicBlock::Create(ctx.llvmContext, "entry", asyncFn);
    ctx.builder->SetInsertPoint(entry);
    ctx.currentFunction = asyncFn;
    
    // 4. Emit LLVM coroutine intrinsics
    // llvm.coro.id - Identifies this function as a coroutine
    Function* coroId = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_id);
    Value* id = ctx.builder->CreateCall(coroId, {
        ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), 0),  // Alignment
        ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext)),  // Promise
        ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext)),  // Corofn
        ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext))   // Data
    }, "id");
    
    // llvm.coro.begin - Allocate coroutine frame
    Function* coroBegin = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_begin);
    Value* hdl = ctx.builder->CreateCall(coroBegin, {
        id,
        ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext))  // Allocfn result
    }, "hdl");
    
    // 5. Generate async body
    if (node->body) {
        node->body->accept(visitor);
    }
    
    // 6. Final suspend point
    // llvm.coro.suspend - Suspend execution
    Function* coroSuspend = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_suspend);
    Value* suspendResult = ctx.builder->CreateCall(coroSuspend, {
        ConstantTokenNone::get(ctx.llvmContext),  // Token
        ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 1)  // Final suspend = true
    }, "suspend");
    
    // Create switch on suspend result
    // 0 = resume, 1 = destroy, -1 = suspend
    SwitchInst* suspendSwitch = ctx.builder->CreateSwitch(suspendResult, 
        BasicBlock::Create(ctx.llvmContext, "suspend_unreachable", asyncFn), 2);
    
    // Case 0: Resume (should not happen for final suspend)
    BasicBlock* resumeBB = BasicBlock::Create(ctx.llvmContext, "resume", asyncFn);
    suspendSwitch->addCase(ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 0), resumeBB);
    ctx.builder->SetInsertPoint(resumeBB);
    ctx.builder->CreateUnreachable();
    
    // Case 1: Destroy
    BasicBlock* destroyBB = BasicBlock::Create(ctx.llvmContext, "destroy", asyncFn);
    suspendSwitch->addCase(ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 1), destroyBB);
    ctx.builder->SetInsertPoint(destroyBB);
    
    // llvm.coro.end - Finalize coroutine
    Function* coroEnd = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_end);
    ctx.builder->CreateCall(coroEnd, {
        hdl,
        ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 0)  // Unwind = false
    });
    ctx.builder->CreateRet(hdl);
    
    // Unreachable block for -1 case
    ctx.builder->SetInsertPoint(suspendSwitch->getDefaultDest());
    ctx.builder->CreateUnreachable();
    
    // 7. Restore context and call async function from caller
    ctx.builder->SetInsertPoint(callerBlock);
    ctx.currentFunction = prevFunc;
    
    // Call the async function (returns coroutine handle)
    Value* coroHandle = ctx.builder->CreateCall(asyncFn, {}, "async_handle");
    
    // TODO: Store handle for later resumption
    // For now, async blocks execute but don't integrate with a scheduler
    (void)coroHandle;  // Suppress unused variable warning
    
    // 8. Handle catch block if present
    if (node->catch_block) {
        // TODO: Implement error handling for async exceptions
        // This requires wrapping the async body in try/catch logic
        // For v0.0.7, we'll leave this as a placeholder
    }
}

// =============================================================================
// Await Expression
// =============================================================================

void AsyncCodeGen::visitAwaitExpr(frontend::AwaitExpr* node, ExprCodeGen& exprGen) {
    // await <expression>
    // Suspends current coroutine until the awaited expression completes
    
    if (!node->expression) {
        throw std::runtime_error("await expression requires an operand");
    }
    
    // Verify we're inside an async function
    if (!ctx.currentFunction) {
        throw std::runtime_error("await can only be used inside async functions");
    }
    
    // Check if this function was marked async (has coroutine setup)
    // Note: We detect this by checking for coro_id call in entry block
    bool isAsync = false;
    if (ctx.currentFunction) {
        for (auto& BB : *ctx.currentFunction) {
            for (auto& I : BB) {
                if (auto* call = dyn_cast<CallInst>(&I)) {
                    if (call->getCalledFunction() && 
                        call->getCalledFunction()->getName() == "llvm.coro.id") {
                        isAsync = true;
                        break;
                    }
                }
            }
            if (isAsync) break;
        }
    }
    
    if (!isAsync) {
        throw std::runtime_error("await can only be used inside async functions (use 'async func' keyword)");
    }
    
    // =====================================================================
    // COROUTINE SUSPENSION IMPLEMENTATION
    // =====================================================================
    // LLVM coroutines use a state machine approach:
    // 1. Save coroutine state before suspension
    // 2. Suspend execution (returns to caller)
    // 3. Resume when awaited operation completes
    
    // Step 1: Evaluate the awaited expression (should return a coroutine handle or result)
    Value* awaitedValue = exprGen.generate(node->expression.get());
    (void)awaitedValue;  // Suppress unused warning
    
    // Step 2: Save coroutine state
    // llvm.coro.save returns a token representing the suspension point
    Function* coroSave = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_save);
    
    // Get current coroutine handle (stored during async function setup)
    // We need to retrieve the handle from the coroutine frame
    Function* coroFrame = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_frame);
    Value* framePtr = ctx.builder->CreateCall(coroFrame, {}, "coro_frame");
    
    // Save suspension point
    Value* saveToken = ctx.builder->CreateCall(coroSave, {framePtr}, "save_point");
    
    // Step 3: Suspend coroutine execution
    // llvm.coro.suspend returns:
    //   -1: coroutine suspended (normal case)
    //    0: resume from suspension
    //    1: cleanup/destroy path
    Function* coroSuspend = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_suspend);
    Value* suspendResult = ctx.builder->CreateCall(coroSuspend, {
        saveToken,
        ConstantInt::getFalse(ctx.llvmContext)  // final = false (not a final suspend)
    }, "suspend_result");
    
    // Step 4: Create basic blocks for the state machine
    BasicBlock* suspendBB = BasicBlock::Create(ctx.llvmContext, "await_suspend", ctx.currentFunction);
    BasicBlock* resumeBB = BasicBlock::Create(ctx.llvmContext, "await_resume", ctx.currentFunction);
    BasicBlock* cleanupBB = BasicBlock::Create(ctx.llvmContext, "await_cleanup", ctx.currentFunction);
    
    // Switch on suspend result:
    // case -1: goto suspend (return to caller)
    // case  0: goto resume (continue after await)
    // case  1: goto cleanup (coroutine destroyed)
    SwitchInst* suspendSwitch = ctx.builder->CreateSwitch(suspendResult, suspendBB, 2);
    suspendSwitch->addCase(ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 0), resumeBB);
    suspendSwitch->addCase(ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 1), cleanupBB);
    
    // ========== SUSPEND PATH ==========
    // Coroutine yields control back to caller
    ctx.builder->SetInsertPoint(suspendBB);
    
    // =====================================================================
    // SCHEDULER INTEGRATION
    // =====================================================================
    // Wrap LLVM coroutine handle in CoroutineFrame for scheduler
    // The scheduler expects a CoroutineFrame* with coro_handle field
    
    // Define CoroutineFrame struct type if not already defined
    StructType* coroFrameType = StructType::getTypeByName(ctx.llvmContext, "CoroutineFrame");
    if (!coroFrameType) {
        // struct CoroutineFrame { void* coro_handle; void* data; CoroutineFrame* waiting_on; int state; char padding; }
        std::vector<Type*> frameFields = {
            PointerType::getUnqual(ctx.llvmContext),  // coro_handle
            PointerType::getUnqual(ctx.llvmContext),  // data
            PointerType::getUnqual(ctx.llvmContext),  // waiting_on (CoroutineFrame*)
            Type::getInt32Ty(ctx.llvmContext),        // state
            Type::getInt8Ty(ctx.llvmContext)          // padding
        };
        coroFrameType = StructType::create(ctx.llvmContext, frameFields, "CoroutineFrame");
    }
    
    // Allocate CoroutineFrame on heap
    Function* mallocFn = ctx.module->getFunction("malloc");
    if (!mallocFn) {
        FunctionType* mallocType = FunctionType::get(
            PointerType::getUnqual(ctx.llvmContext),
            {Type::getInt64Ty(ctx.llvmContext)},
            false
        );
        mallocFn = Function::Create(mallocType, Function::ExternalLinkage, "malloc", ctx.module.get());
    }
    
    Value* frameSize = ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 
        ctx.module->getDataLayout().getTypeAllocSize(coroFrameType));
    Value* frameAlloc = ctx.builder->CreateCall(mallocFn, {frameSize}, "coro_frame_alloc");
    
    // Store LLVM coroutine handle in CoroutineFrame.coro_handle
    Value* handleField = ctx.builder->CreateStructGEP(coroFrameType, frameAlloc, 0, "coro_handle_ptr");
    ctx.builder->CreateStore(framePtr, handleField);
    
    // Initialize state to SUSPENDED (1)
    Value* stateField = ctx.builder->CreateStructGEP(coroFrameType, frameAlloc, 3, "state_ptr");
    ctx.builder->CreateStore(ConstantInt::get(Type::getInt32Ty(ctx.llvmContext), 1), stateField);
    
    // Declare aria_scheduler_schedule if not already declared
    Function* schedulerSchedule = ctx.module->getFunction("aria_scheduler_schedule");
    if (!schedulerSchedule) {
        FunctionType* schedFuncType = FunctionType::get(
            Type::getVoidTy(ctx.llvmContext),
            {PointerType::getUnqual(ctx.llvmContext)},  // CoroutineFrame*
            false
        );
        schedulerSchedule = Function::Create(
            schedFuncType,
            Function::ExternalLinkage,
            "aria_scheduler_schedule",
            ctx.module.get()
        );
    }
    
    // Schedule the CoroutineFrame (not raw LLVM handle)
    ctx.builder->CreateCall(schedulerSchedule, {frameAlloc});
    
    // Return coroutine handle to caller (allows direct resumption if needed)
    // Use the frame pointer as the return value (coroutine handle)
    ctx.builder->CreateRet(framePtr);
    
    // ========== RESUME PATH ==========
    // Execution continues here after coroutine is resumed
    ctx.builder->SetInsertPoint(resumeBB);
    
    // The awaited value is now available (conceptually)
    // Store it for later use if needed
    // For now, we just continue execution
    // (In a full implementation, we'd extract the result from the awaited coroutine)
    
    // ========== CLEANUP PATH ==========
    // Coroutine is being destroyed before completion
    ctx.builder->SetInsertPoint(cleanupBB);
    
    // Placeholder: In full implementation, we'd free the coroutine frame if needed
    // For now, just end the coroutine
    Function* coroEnd = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_end);
    ctx.builder->CreateCall(coroEnd, {
        framePtr,
        ConstantInt::getFalse(ctx.llvmContext)  // unwind = false
    });
    ctx.builder->CreateRetVoid();
    
    // Continue insertion at resume point for subsequent code
    ctx.builder->SetInsertPoint(resumeBB);
}

// =============================================================================
// Spawn Expression
// =============================================================================

void AsyncCodeGen::visitSpawnExpr(frontend::SpawnExpr* node, ExprCodeGen& exprGen) {
    // spawn <expression>
    // Spawns expression (usually function call) on scheduler
    // Returns void for now (Future<T> in next iteration)
    
    // For v1: Just spawn without Future return
    // This requires the spawn runtime (spawn.h/spawn.cpp)
    
    if (!node->expression) {
        return;
    }
    
    // Currently, we only support spawning function calls
    // TODO: Support spawning lambdas and other expressions
    auto* call = dynamic_cast<aria::frontend::CallExpr*>(node->expression.get());
    if (!call) {
        throw std::runtime_error("spawn currently only supports function calls");
    }
    
    // Get the function being called
    std::string funcName = call->function_name;
    Function* targetFunc = ctx.module->getFunction(funcName);
    if (!targetFunc) {
        auto* sym = ctx.lookup(funcName);
        if (sym && !sym->is_ref) {
            targetFunc = dyn_cast_or_null<Function>(sym->val);
        }
    }
    
    if (!targetFunc) {
        throw std::runtime_error("spawn: cannot find function '" + funcName + "'");
    }
    
    // Generate wrapper function that captures the call
    // The wrapper has signature: void wrapper_N(void* task_ptr)
    // It casts to SpawnTask*, unpacks args, calls function, stores result
    
    static int wrapperCount = 0;
    std::string wrapperName = "spawn_wrapper_" + std::to_string(wrapperCount++);
    
    // Wrapper function type: void(void*)
    FunctionType* wrapperType = FunctionType::get(
        Type::getVoidTy(ctx.llvmContext),
        {PointerType::getUnqual(ctx.llvmContext)},  // void* task_ptr
        false
    );
    
    Function* wrapperFunc = Function::Create(
        wrapperType,
        Function::InternalLinkage,
        wrapperName,
        ctx.module.get()
    );
    
    // Generate wrapper body in new basic block
    BasicBlock* wrapperEntry = BasicBlock::Create(ctx.llvmContext, "entry", wrapperFunc);
    IRBuilder<> wrapperBuilder(wrapperEntry);
    
    // Get task pointer argument
    Value* taskPtr = wrapperFunc->arg_begin();
    
    // Get return type of target function
    FunctionType* targetFuncType = targetFunc->getFunctionType();
    Type* returnType = targetFuncType->getReturnType();
    bool hasReturnValue = !returnType->isVoidTy();
    
    // If function has arguments, unpack them from args struct
    std::vector<Value*> callArgs;
    if (!call->arguments.empty()) {
        // SpawnTask has: void (*function)(void*); void* args; Future* future; void (*completion)(...);
        // We need to load the 'args' field (index 1)
        StructType* spawnTaskType = StructType::get(ctx.llvmContext, {
            PointerType::getUnqual(ctx.llvmContext),  // function
            PointerType::getUnqual(ctx.llvmContext),  // args
            PointerType::getUnqual(ctx.llvmContext),  // future
            PointerType::getUnqual(ctx.llvmContext)   // completion
        });
        
        Value* argsFieldPtr = wrapperBuilder.CreateStructGEP(spawnTaskType, taskPtr, 1);
        Value* argsPtr = wrapperBuilder.CreateLoad(PointerType::getUnqual(ctx.llvmContext), argsFieldPtr);
        
        // Get argument types from target function
        std::vector<Type*> argTypes;
        for (unsigned i = 0; i < targetFuncType->getNumParams(); i++) {
            argTypes.push_back(targetFuncType->getParamType(i));
        }
        
        StructType* argsStructType = StructType::create(ctx.llvmContext, argTypes, "spawn_args");
        
        // Load each field and build call argument list
        for (size_t i = 0; i < argTypes.size(); i++) {
            Value* fieldPtr = wrapperBuilder.CreateStructGEP(argsStructType, argsPtr, i);
            Value* fieldVal = wrapperBuilder.CreateLoad(argTypes[i], fieldPtr);
            callArgs.push_back(fieldVal);
        }
    }
    
    // Call the target function and capture result
    Value* result = wrapperBuilder.CreateCall(targetFunc, callArgs);
    
    // If function returns a value, store it in the Future
    if (hasReturnValue) {
        // Get SpawnTask fields
        StructType* spawnTaskType = StructType::get(ctx.llvmContext, {
            PointerType::getUnqual(ctx.llvmContext),  // function
            PointerType::getUnqual(ctx.llvmContext),  // args
            PointerType::getUnqual(ctx.llvmContext),  // future
            PointerType::getUnqual(ctx.llvmContext)   // completion
        });
        
        // Load Future* (field index 2)
        Value* futureFieldPtr = wrapperBuilder.CreateStructGEP(spawnTaskType, taskPtr, 2);
        Value* futurePtr = wrapperBuilder.CreateLoad(PointerType::getUnqual(ctx.llvmContext), futureFieldPtr);
        
        // Allocate space for result on stack
        Value* resultPtr = wrapperBuilder.CreateAlloca(returnType);
        wrapperBuilder.CreateStore(result, resultPtr);
        
        // Call Future->set(result_ptr)
        // Future.set() signature: void set(void* value)
        Function* futureSetFunc = ctx.module->getFunction("_ZN6Future3setEPv");  // Mangled name
        if (!futureSetFunc) {
            // Declare it if not present
            FunctionType* setFuncType = FunctionType::get(
                Type::getVoidTy(ctx.llvmContext),
                {PointerType::getUnqual(ctx.llvmContext), PointerType::getUnqual(ctx.llvmContext)},  // this, void* value
                false
            );
            futureSetFunc = Function::Create(setFuncType, Function::ExternalLinkage, "_ZN6Future3setEPv", ctx.module.get());
        }
        
        wrapperBuilder.CreateCall(futureSetFunc, {futurePtr, resultPtr});
    }
    
    wrapperBuilder.CreateRetVoid();
    
    // Now in the original function, allocate args struct and populate it
    if (!call->arguments.empty()) {
        // Use TARGET FUNCTION parameter types
        FunctionType* targetFuncType = targetFunc->getFunctionType();
        std::vector<Type*> argTypes;
        std::vector<Value*> argValues;
        
        for (unsigned i = 0; i < call->arguments.size(); i++) {
            Value* argVal = exprGen.generate(call->arguments[i].get());
            Type* expectedType = targetFuncType->getParamType(i);
            
            // Cast argument to match target function's parameter type if needed
            if (argVal->getType() != expectedType) {
                if (argVal->getType()->isIntegerTy() && expectedType->isIntegerTy()) {
                    argVal = ctx.builder->CreateIntCast(argVal, expectedType, true);
                }
            }
            
            argTypes.push_back(expectedType);
            argValues.push_back(argVal);
        }
        
        StructType* argsStructType = StructType::create(ctx.llvmContext, argTypes, "spawn_args");
        
        // Allocate args struct on heap (it will be freed by the worker after execution)
        Function* mallocFunc = ctx.module->getFunction("malloc");
        if (!mallocFunc) {
            FunctionType* mallocType = FunctionType::get(
                PointerType::getUnqual(ctx.llvmContext),
                {Type::getInt64Ty(ctx.llvmContext)},
                false
            );
            mallocFunc = Function::Create(mallocType, Function::ExternalLinkage, "malloc", ctx.module.get());
        }
        
        uint64_t structSize = ctx.module->getDataLayout().getTypeAllocSize(argsStructType);
        Value* argsPtr = ctx.builder->CreateCall(
            mallocFunc,
            {ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), structSize)}
        );
        
        // Store each argument into the struct
        for (size_t i = 0; i < argValues.size(); i++) {
            Value* fieldPtr = ctx.builder->CreateStructGEP(argsStructType, argsPtr, i);
            ctx.builder->CreateStore(argValues[i], fieldPtr);
        }
        
        // Create Future for the return value
        Type* returnType = targetFuncType->getReturnType();
        Value* futurePtr = nullptr;
        
        if (!returnType->isVoidTy()) {
            // Allocate Future via aria_future_create(result_size)
            Function* futureCreateFunc = ctx.module->getFunction("aria_future_create");
            if (!futureCreateFunc) {
                FunctionType* createFuncType = FunctionType::get(
                    PointerType::getUnqual(ctx.llvmContext),
                    {Type::getInt64Ty(ctx.llvmContext)},  // size_t result_size
                    false
                );
                futureCreateFunc = Function::Create(createFuncType, Function::ExternalLinkage, "aria_future_create", ctx.module.get());
            }
            
            uint64_t resultSize = ctx.module->getDataLayout().getTypeAllocSize(returnType);
            futurePtr = ctx.builder->CreateCall(
                futureCreateFunc,
                {ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), resultSize)}
            );
        }
        
        // Create SpawnTask struct on heap
        // struct SpawnTask { void (*function)(void*); void* args; Future* future; void (*completion)(...); }
        StructType* spawnTaskType = StructType::create(ctx.llvmContext, {
            PointerType::getUnqual(ctx.llvmContext),  // function pointer
            PointerType::getUnqual(ctx.llvmContext),  // args
            PointerType::getUnqual(ctx.llvmContext),  // future
            PointerType::getUnqual(ctx.llvmContext)   // completion
        }, "SpawnTask");
        
        Value* taskPtr = ctx.builder->CreateCall(
            mallocFunc,
            {ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 
                ctx.module->getDataLayout().getTypeAllocSize(spawnTaskType))}
        );
        
        // Store wrapper function pointer
        Value* funcPtrField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 0);
        ctx.builder->CreateStore(wrapperFunc, funcPtrField);
        
        // Store args pointer
        Value* argsPtrField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 1);
        ctx.builder->CreateStore(argsPtr, argsPtrField);
        
        // Store future pointer (or null if void return)
        Value* futureField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 2);
        if (futurePtr) {
            ctx.builder->CreateStore(futurePtr, futureField);
        } else {
            ctx.builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext)), futureField);
        }
        
        // Store null for completion (not used yet - Future::set is called directly)
        Value* completionField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 3);
        ctx.builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext)), completionField);
        
        // Call aria_spawn_schedule(task)
        Function* scheduleFunc = ctx.module->getFunction("aria_spawn_schedule");
        if (!scheduleFunc) {
            FunctionType* scheduleType = FunctionType::get(
                Type::getVoidTy(ctx.llvmContext),
                {PointerType::getUnqual(ctx.llvmContext)},
                false
            );
            scheduleFunc = Function::Create(scheduleType, Function::ExternalLinkage, "aria_spawn_schedule", ctx.module.get());
        }
        
        ctx.builder->CreateCall(scheduleFunc, {taskPtr});
        
        // Note: currentSpawnFuture would be set here in the original code
        // but we don't have access to that member variable in this module
        // TODO: Return futurePtr through a different mechanism
    } else {
        // No arguments - simpler path
        // Get return type for Future creation
        FunctionType* targetFuncType = targetFunc->getFunctionType();
        Type* returnType = targetFuncType->getReturnType();
        Value* futurePtr = nullptr;
        
        if (!returnType->isVoidTy()) {
            // Allocate Future via aria_future_create(result_size)
            Function* futureCreateFunc = ctx.module->getFunction("aria_future_create");
            if (!futureCreateFunc) {
                FunctionType* createFuncType = FunctionType::get(
                    PointerType::getUnqual(ctx.llvmContext),
                    {Type::getInt64Ty(ctx.llvmContext)},
                    false
                );
                futureCreateFunc = Function::Create(createFuncType, Function::ExternalLinkage, "aria_future_create", ctx.module.get());
            }
            
            uint64_t resultSize = ctx.module->getDataLayout().getTypeAllocSize(returnType);
            futurePtr = ctx.builder->CreateCall(
                futureCreateFunc,
                {ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), resultSize)}
            );
        }
        
        // Create SpawnTask with null args
        StructType* spawnTaskType = StructType::create(ctx.llvmContext, {
            PointerType::getUnqual(ctx.llvmContext),  // function pointer
            PointerType::getUnqual(ctx.llvmContext),  // args
            PointerType::getUnqual(ctx.llvmContext),  // future
            PointerType::getUnqual(ctx.llvmContext)   // completion
        }, "SpawnTask");
        
        Function* mallocFunc = ctx.module->getFunction("malloc");
        if (!mallocFunc) {
            FunctionType* mallocType = FunctionType::get(
                PointerType::getUnqual(ctx.llvmContext),
                {Type::getInt64Ty(ctx.llvmContext)},
                false
            );
            mallocFunc = Function::Create(mallocType, Function::ExternalLinkage, "malloc", ctx.module.get());
        }
        
        Value* taskPtr = ctx.builder->CreateCall(
            mallocFunc,
            {ConstantInt::get(Type::getInt64Ty(ctx.llvmContext), 
                ctx.module->getDataLayout().getTypeAllocSize(spawnTaskType))}
        );
        
        Value* funcPtrField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 0);
        ctx.builder->CreateStore(wrapperFunc, funcPtrField);
        
        Value* argsPtrField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 1);
        ctx.builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext)), argsPtrField);
        
        // Store future pointer (or null if void return)
        Value* futureField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 2);
        if (futurePtr) {
            ctx.builder->CreateStore(futurePtr, futureField);
        } else {
            ctx.builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext)), futureField);
        }
        
        Value* completionField = ctx.builder->CreateStructGEP(spawnTaskType, taskPtr, 3);
        ctx.builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext)), completionField);
        
        Function* scheduleFunc = ctx.module->getFunction("aria_spawn_schedule");
        if (!scheduleFunc) {
            FunctionType* scheduleType = FunctionType::get(
                Type::getVoidTy(ctx.llvmContext),
                {PointerType::getUnqual(ctx.llvmContext)},
                false
            );
            scheduleFunc = Function::Create(scheduleType, Function::ExternalLinkage, "aria_spawn_schedule", ctx.module.get());
        }
        
        ctx.builder->CreateCall(scheduleFunc, {taskPtr});
        
        // Note: currentSpawnFuture would be set here
        // TODO: Return futurePtr through a different mechanism
    }
    
    // TODO: Return Future<T> instead of void
}

// =============================================================================
// Async Function Final Suspend
// =============================================================================
// Emits the final suspend sequence for async functions that are missing returns
// This is called at the end of an async function to properly suspend and cleanup

void AsyncCodeGen::emitAsyncFinalSuspend() {
    if (!ctx.builder->GetInsertBlock() || ctx.builder->GetInsertBlock()->getTerminator()) {
        return; // Already has terminator
    }
    
    Function* coroSuspend = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_suspend);
    Value* suspendResult = ctx.builder->CreateCall(coroSuspend, {
        ConstantTokenNone::get(ctx.llvmContext),
        ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 1)  // Final suspend
    }, "final_suspend");
    
    // Create suspend switch
    BasicBlock* suspendBB = BasicBlock::Create(ctx.llvmContext, "suspend", ctx.currentFunction);
    BasicBlock* destroyBB = BasicBlock::Create(ctx.llvmContext, "destroy", ctx.currentFunction);
    SwitchInst* suspendSwitch = ctx.builder->CreateSwitch(suspendResult, suspendBB, 2);
    suspendSwitch->addCase(ConstantInt::get(Type::getInt8Ty(ctx.llvmContext), 1), destroyBB);
    
    // Destroy path
    ctx.builder->SetInsertPoint(destroyBB);
    Function* coroEnd = Intrinsic::getDeclaration(ctx.module.get(), Intrinsic::coro_end);
    
    // Get the coroutine handle from the symbol table
    auto* coroHandleSym = ctx.lookup("__coro_handle__");
    Value* hdl = nullptr;
    if (coroHandleSym && coroHandleSym->val) {
        hdl = ctx.builder->CreateLoad(PointerType::getUnqual(ctx.llvmContext),
            coroHandleSym->val, "coro_hdl");
    } else {
        hdl = ConstantPointerNull::get(PointerType::getUnqual(ctx.llvmContext));
    }
    
    ctx.builder->CreateCall(coroEnd, {
        hdl,
        ConstantInt::get(Type::getInt1Ty(ctx.llvmContext), 0)
    });
    ctx.builder->CreateRet(hdl);
    
    // Suspend path (unreachable)
    ctx.builder->SetInsertPoint(suspendBB);
    ctx.builder->CreateUnreachable();
}

} // namespace backend
} // namespace aria
