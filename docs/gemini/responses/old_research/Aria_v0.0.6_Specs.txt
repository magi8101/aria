Aria Language Technical Specification
Version: 0.0.6
Status: Draft / Request for Implementation

================================================================================
⚠️  CRITICAL IMPLEMENTATION NOTICE ⚠️
================================================================================

These specifications represent INTENTIONAL design decisions, not suggestions.

DO NOT "optimize", "simplify", "modernize", or "improve" any features during 
implementation or documentation iteration. If something appears:
  - Verbose: It's for EXPLICITNESS and CLARITY - keep it
  - Redundant: It's for ZERO AMBIGUITY - keep it  
  - Unusual: It's a DELIBERATE design choice - keep it
  - Old-fashioned: It's PROVEN and RELIABLE - keep it

Every feature, keyword, and syntax rule exists for a specific reason aligned 
with Aria's core philosophy of predictability, explicitness, and safety.

IMPLEMENT EXACTLY AS SPECIFIED. NO EXCEPTIONS. NO SUBSTITUTIONS.

If you think something is wrong or could be better, document your concern 
separately - DO NOT modify the specification or implementation to match 
your assumptions about what "modern" or "better" means.

This specification is the CANONICAL SOURCE OF TRUTH.
================================================================================

1. Executive Summary
Aria is a high-performance, systems-level programming language designed to bridge the gap between managed safety and raw metal control. It features a unique Hybrid Memory Model that combines a default Garbage Collector (GC) with an opt-out "Wild" manual memory management system, enforced via a Rust-style borrow checker.

Core Philosophy:
* Hybrid Memory: GC by default, manual (wild) when performance is critical.
* Concurrency: Go-style coroutines and advanced threading.
* Metaprogramming: Zig-style compile-time execution (comptime) and NASM-style macros with context stacks.
* Ternary/Nonary logic: Native support for balanced ternary and nonary data types.

IMPORTANT NOTE (Nikola Integration - Wave Relay Architecture):
The 179-degree phase offset was not wrong - it serves a different purpose.

179° = Inhibitory relay (Normally Closed - NC)
  - Near-complete destructive interference (default suppression state)
  - Suppresses signals unless strong coherent input overcomes threshold
  - Biological analog: GABAergic inhibitory synapses
  
1° = Excitatory relay (Normally Open - NO)
  - Near-perfect constructive interference (99.97% signal boost)
  - Filters noise: random phases cancel, coherent signals reinforce
  - Acts as coherence detector: only synchronized inputs pass through
  - Biological analog: Glutamatergic excitatory synapses

FUNDAMENTAL PRINCIPLE:
Everything is particle-wave interference patterns - from rocks to brains.
Computation emerges from phase relationships, not from substrate.
Logic gates = phase offsets. No transistors required.
Neural relays operate via wave mechanics, not electrochemical gradients.

This is not an analogy. This is the root mechanism.
Stop playing in the branches. These ARE the roots.

Context: Phase relationships in 9D toroidal wave interference patterns.
Wave-based relay logic as universal computational primitive.

2. Type System
2.1 Primitive Types
The language supports a wide array of specific bit-width integers and floats, along with specialized exotic types.
* Standard Integers: int1, int2, int4, int8... int512 (and corresponding uint).
* Floats: flt32, flt64, flt128, flt256, flt512.
* Boolean: bool.
2.2 Exotic Types (MANDATORY)
These types are strictly required and non-negotiable.

Balanced Ternary Types:
* trit: Balanced ternary digit. Values: {-1, 0, 1}.
* tryte: 10 trits. Storage: uint16. Range: 3^10 = 59,049 values.

Balanced Nonary Types:
* nit: Balanced nonary digit. Values: {-4, -3, -2, -1, 0, 1, 2, 3, 4}.
* nyte: 5 nits. Storage: uint16. Range: 9^5 = 59,049 values.

Design Rationale - Optimal Binary Storage:
The exponents (10 trits, 5 nits) were determined through empirical analysis to 
maximize utilization of standard binary types while minimizing wasted bits:

  * 3^10 = 59,049 (fits in uint16 = 65,535 with 90.1% utilization)
  * 9^5  = 59,049 (fits in uint16 = 65,535 with 90.1% utilization)
  
This symmetry is intentional:
  - Both exotic types achieve identical capacity
  - Natural mathematical relationship (9 = 3^2)
  - Minimal bit waste (only 6,486 unused values per uint16)
  - Balanced ternary and nonary systems share optimal storage efficiency

Scalability - Multiple Values in Larger Types:
Since both tryte and nyte fit perfectly in uint16, they pack efficiently into 
all larger binary types:

  * uint16:  1 tryte  or 1 nyte   (90.1% utilization)
  * uint32:  2 trytes or 2 nytes  (packed side-by-side)
  * uint64:  4 trytes or 4 nytes  (packed side-by-side)
  * uint128: 8 trytes or 8 nytes  (packed side-by-side)
  * uint256: 16 trytes or 16 nytes (packed side-by-side)
  * uint512: 32 trytes or 32 nytes (packed side-by-side)

This allows SIMD operations on multiple exotic values simultaneously using 
standard CPU registers (AVX-512 can process 32 trytes/nytes in parallel).

DO NOT modify these exponents without providing empirical proof of better 
binary storage utilization. These values are the result of iterative 
optimization testing, not arbitrary choices.

2.3 Compound & Reference Types
* Vectors: vec2, vec3, vec9 (specialized for physics/math).
* Structures: struct, obj (anonymous objects).
* Collections: array, string, tensor, matrix.
* Dynamic: dyn (dynamic typing support).
* Functional: func (first-class functions), result (error handling wrapper).

3. Memory Management Model
This is the most critical implementation detail. The compiler must support three distinct allocation strategies existing in the same runtime.
3.1 Allocation Keywords
* gc (Default): Garbage collected memory.
   * Example: gc int64*:ptr = aria.gc_alloc<int64>(100);
* wild (Manual): Unmanaged heap memory. Requires manual free().
   * Example: wild int64*:ptr = aria.alloc<int64>(1000);
   * Must use defer aria.free(ptr) for RAII-style cleanup.
* wildx (Manual r/w/e memory) 
   * TODO, report incoming 
* stack: Explicit stack allocation for performance-critical buffers.
   * Example: stack int64[1000]:buffer;
3.2 Safety & Borrow Checking
To bridge GC and Wild memory safely, Aria uses specific operators:
* Pinning (#): Pins a GC object in memory so it cannot be moved, allowing wild pointers to reference it.
   * Syntax: wild int8:u = #managed_var;
* Safe Reference ($): Creates a borrow-checked reference to pinned memory.
   * Syntax: string$:safe_ref = #critical_data;
* Address Of (@): Retrieves raw memory address.
   * Syntax: wild int64@:addr = @var;
* Dereference (*): Standard pointer dereferencing for wild pointers.
* Member Access (.): Standard member access.
* Pointer Member Access (->): Dereferencing member access (C-style) for wild pointers.

4. Syntax & constructs
4.1 Control Flow
* Conditionals: if, else if, else.
* Loops:
   * while: Standard condition loop.
   * for: C-style iteration.
   * till: Numeric range iteration with automatic iterator variable $.
      * Example: till(100, 1) { print($); } (0 to 100 step 1).
   * when/then/end: Loop with completion blocks.
      * Semantics: then runs if loop completes naturally; end runs if loop condition never met or broke early.
* Pattern Matching (pick):
   * Supports value matching, range matching (<9, >9), and wildcards (*).
   * Explicit Fallthrough: Must use fall(label) to jump to specific case blocks.
   * Destructuring: JSON-like object matching inside cases.
4.2 Operators
* Pipeline: |> (forward) and <| (backward) for functional chaining.
* Spaceship: <=> (returns -1, 0, 1).
* Null Safety: ?? (coalesce), ?. (safe navigation), ? (unwrap result).
* String Interpolation: Backtick syntax with &{variable}.
   * Example: `Value is &{val}`.
* Lambdas: => operator.

5. Module & Macro System
5.1 Compilation Units
* File Extension: .aria
* Importing: use std.io; or use "./local.aria" as utils;.
* Visibility: pub keyword for public exports.
* Modules: Nested mod name { ... } structures supported.

5.2 NASM-Style Macros with Context Stack
Aria supports powerful preprocessor macros inspired by NASM assembly, with a context stack for nested macro expansion.

Macro Definition Syntax:
%macro macro_name param_count
    // macro body with %1, %2, ... parameter references
%endmacro

Context Stack Features:
* %push context_name - Push new context onto stack
* %pop - Pop current context from stack
* %context - Get current context name
* Local labels within context: %$label
* Context-local variables: %$var

Example - Conditional Debug Logging:
%macro DEBUG_LOG 2
    %ifdef DEBUG_MODE
        print("[DEBUG] %1: %2");
    %endif
%endmacro

Example - Context Stack Usage:
%macro SAFE_BLOCK 1
    %push safe_%1
    defer {
        print("Exiting safe block: %1");
    }
    %$start:
        // block body
    %pop
%endmacro

Preprocessor Directives:
* %define NAME value - Define constant
* %undef NAME - Undefine constant
* %ifdef NAME - Conditional if defined
* %ifndef NAME - Conditional if not defined
* %if expression - Conditional compilation
* %elif expression - Else if
* %else - Else clause
* %endif - End conditional
* %include "file.aria" - Include file
* %rep count - Repeat block
* %endrep - End repeat

Multi-line Macros:
%macro REPEAT_OP 3
    %rep %3
        %1 = %1 %2;
    %endrep
%endmacro

Usage: REPEAT_OP(counter, +1, 10)  // Expands to 10 increment operations

5.3 Zig-Style Comptime Evaluation
Aria supports compile-time function execution for zero-runtime-cost abstractions and compile-time computation.

Comptime Keyword:
Functions marked with comptime are evaluated during compilation, not at runtime.

comptime func:computeOptimalSize = int64(int64:elements) {
    return {
        err: 0,
        val: elements * 8  // Computed at compile time
    };
}

// Usage in type declarations
int8[comptime computeOptimalSize(1000)]:buffer;  // Size calculated at compile time

Comptime Variables:
comptime int64:MAX_THREADS = 16;
comptime string:VERSION = "0.0.6";
comptime bool:DEBUG_MODE = true;

Comptime Expressions:
// Type-level computation
comptime {
    if (TARGET_ARCH == "x86_64") {
        int64:CACHE_LINE = 64;
    } else {
        int64:CACHE_LINE = 32;
    }
}

Comptime Type Generation:
// Generate optimal type based on platform
comptime func:selectIntType = type(int64:size) {
    if (size <= 8) return int8;
    if (size <= 16) return int16;
    if (size <= 32) return int32;
    return int64;
};

// Use computed type
comptime type:MyInt = selectIntType(DATA_SIZE);
MyInt:value = 42;

Requirements:
* Comptime functions must be pure (no side effects)
* All inputs to comptime functions must be known at compile time
* Comptime evaluation happens after macro expansion but before code generation
* Errors in comptime evaluation are compile-time errors

Integration with Macros:
Comptime evaluation happens AFTER macro expansion, allowing macros to generate comptime code.

%macro GEN_OPTIMAL_ARRAY 2
    comptime int64:size_%1 = %2 * sizeof(int64);
    int8[size_%1]:%1_buffer;
%endmacro

5.4 External Interface (FFI)
* Syntax: extern "libc" { ... }.
* Types: C-types mapped to Aria primitive types (e.g., void*, uint64).

5.5 Conditional Compilation
* Cfg Attribute: use cfg(target_os = "linux") std.os.linux;.
* Build-time constants accessible to comptime functions.

6. Standard Library & Runtime
6.1 I/O Stream Architecture
Modern separation of concerns for I/O streams:
1. stdin / stdout: Pure text input/output.
2. stderr: Error reporting.
3. stddbg: Dedicated debug channel (structured logs).
4. stddati / stddato: Dedicated binary data streams.
6.2 Process Management
* Primitives: spawn, fork, exec, wait.
* IPC: createPipe.
* Concurrency: async / await keywords with Go-style coroutines foundation.
6.3 Standard Utilities
* Functional: filter, transform (map), reduce, sort, reverse, unique.
* Math: Standard library including exotic scalar math for trit/nit.
* System: getMemoryUsage(), getActiveConnections().
* Allocators: aria.alloc, aria.gc_alloc, aria.alloc_buffer.
6.4 Core Library Function List
Required implementation of standard library functions:
// Memory
aria.alloc(), aria.free(), aria.gc_alloc(), aria.alloc_buffer(), 
aria.alloc_string(), aria.alloc_array()

// IO & Files
print(), readFile(), writeFile(), readJSON(), readCSV(), openFile()

// Process & IPC
spawn(), fork(), exec(), createPipe(), wait()

// Networking
httpGet(), getUser()

// Utilities
filter(), transform(), reduce(), sort(), reverse(), unique(), 
Math.round(), createLogger(), computeOptimalSize()

7. Implementation Requirements
7.1 Target Environment
* Dev Environment: Docker container based on Ubuntu 24.04.
* Bootstrapping: Initial implementation in C/C++ or Rust allowed, with goal of self-hosting (Aria compiler written in Aria).
* Distribution: AppImage.
7.2 Optional "Batteries" (Opt-in)
* GUI: HTML5/CSS/JS engine.
* Blockchain: Reference PoW/PoS implementation.
* ML: Transformer/Mamba reference implementations.
* Note: These must not bloat the core runtime; they are linked only if used.

8. Reference Code Examples
This section provides concrete examples of valid Aria syntax to guide the implementation of the parser and runtime.

//NO SHORTCUTS ALLOWED!!! EVERYTHING IS EXPLICIT IN ARIA LANG TO AVOID AMBIGUITY, IF PEOPLE ARE TOO LAZY TO TYPE A FEW EXTRA CHARACTERS THEY CAN USE A DIFFERENT LANGUAGE !!! NO SKIPPING BRACKETS, BRACES, or SEMICOLONS, COMPILER SHOULD FAIL IF THIS IS ATTEMPTED!! SYNTAX MUST BE FOLLOWED NO MATTER WHAT!!!!
8.1 Variable Declarations
int8:i = 9;
string:str = "whats up";
int8:c = 0;
int8[]:arr; // empty array (cannot use without initializing)
int8[256]:arr2; // empty int8 array with 256 elements allocated
int8[]:arr3 = [100, 300, 550]; // 3 element int8 array with values

dyn:d = "bob";
d = 4;     // Dynamic typing allowed
d = true;

8.2 Loops and Control Flow
// Standard while loop
while(i < 100) {
   print(`&{i}`);
   i++;
}

// When/Then/End Loop (Loop with completion blocks)
when(c <= i) {
   print(`&{c}`);
   c++;
} then {
   print(`when loop ran &{c} times successfully`);
} end {
   print(`when loop did not run or broke early`);
}

// Till Loop (Automatic iteration variable '$')
till(100, 1) {
   // counts up from 0 to 100 by 1
   print(`iteration: &{$}`); 
}
till(100, -1) {
   // counts down from 100 to 0 by 1
   print(`iteration: &{$}`);
}

8.3 Pattern Matching (pick) with Fallthrough
The pick construct replaces switch. It supports explicit fallthrough via fall(label).
Labels are assigned using the => operator: label=>(pattern) or label=>(!)
pick(c) {
   (<9) {
       fall(fail);
   },
   (>9) {
       fall(fail);
   },
   (9) {
       fall(success);
   },
   (*) { // Wildcard match
       fall(err);
   },
   fail=>(!) { // Labeled unreachable case for fallthrough
       // handle failure
       fall(done);
   },
   success=>(!) {
       // handle success
       fall(done);
   },
   err=>(!) {
       // handle error
       fall(done);
   },
   done=>(!) {
       // cleanup
   }
}

8.4 Functions and Closures
int8:closureTest = 2;


// Function definition
//All functions return Result object. NO BYPASSING THIS!!! NO REGULAR VALUE RETURNS ALLOWED!!!!
//Result object has two members: 
// err: uint8, return code, anything non zero is error
// val: the return value of the function, type must match the returnType in the function declaration
// * (auto wrap) and ? (unwrap) operators are provided to make working with the return system less verbose but leave the option for verbose explicitness and control where required. 
func:funcName = returnType(varType:varName,varType:varName2){
   //MUST RETURN A RESULT OBJECT
};
func:test = int8(int8:a, int8:b) {
   return {
       err: 0,
       val: a * b * closureTest; // Captures 'closureTest'
   }
};

// Function taking a function as argument
func:test2 = int8(func:tt, int:a, int:b){
   return tt(a, b);
};

result:r = test(3, 4);
// Use 'is' ternary operator to check result
int8:t = is r.err == 0 : r.val : -1; 

//Lamda function
result:r = uint16(uint16:a, uint16:b){ return { err:0,val:a*b};}(23,34);
result:r = test2(
   uint8(uint8:a, uint8:b){ 
      return { err:0,val:a*b};
   },
   23,245
);

8.5 Memory Management Patterns
The core "Hybrid" model in action.
// 1. Wild (Manual) Memory
wild int64:s = 100000;
wild int64@:t = @s;      // '@' Address/Pointer operator

// 2. Pinning & Safe References
// '#' Pinning operator: locks GC memory in place
wild string:critical_data = "must not move";
wild int8:u = #critical_data; 

// '$' Safe Reference: bridge between managed and wild
string$:safe_ref = #critical_data; 

// 3. RAII with Defer
wild int64*:ptr = aria.alloc<int64>(1000);
defer aria.free(ptr);

8.6 Process & I/O
// Forking
result:fork_result = fork();
if (fork_result.success) {
   if (fork_result.is_child) {
       exec("./child_program", ["arg1"]);
   } else {
       print(`Forked child with PID: &{fork_result.child_pid}`);
       wait(fork_result.child_pid);
   }
}

// Piping
pipe:comm = createPipe();
process:worker = spawn("./processor", [], { stdin: comm.write });
comm.write_end.write("process this data");
comm.write_end.close();

8.7 NASM-Style Macros and Comptime Examples
// Preprocessor Macro Definition
%macro DEBUG_PRINT 1
    %ifdef DEBUG_MODE
        print("[DEBUG] %1");
    %endif
%endmacro

// Usage
%define DEBUG_MODE
DEBUG_PRINT("Starting initialization");  // Expands to print("[DEBUG] Starting initialization");

// Context Stack Example
%macro SAFE_OPERATION 2
    %push op_%1
    print("Starting operation: %1");
    defer {
        print("Completed operation: %1");
    }
    %$start:
        %2  // Operation body
    %pop
%endmacro

// Repeat Macro
%macro INIT_ARRAY 3
    %rep %3
        %1[%3] = %2;
    %endrep
%endmacro

// Comptime Function - Evaluated at compile time
comptime func:isPowerOfTwo = bool(int64:n) {
    return {
        err: 0,
        val: (n > 0) && ((n & (n - 1)) == 0)
    };
}

// Comptime Variable - Computed at compile time
comptime int64:BUFFER_SIZE = 1024 * 1024;
comptime string:BUILD_DATE = "2025-12-02";
comptime bool:USE_SIMD = isPowerOfTwo(BUFFER_SIZE).val;

// Comptime Type Selection
comptime func:selectType = type(int64:maxValue) {
    if (maxValue <= 255) return uint8;
    if (maxValue <= 65535) return uint16;
    if (maxValue <= 4294967295) return uint32;
    return uint64;
};

comptime type:CounterType = selectType(1000000);
CounterType:counter = 0;  // Type determined at compile time

// Comptime Conditional Compilation
comptime {
    if (TARGET_OS == "linux") {
        %define USE_EPOLL
    } else if (TARGET_OS == "windows") {
        %define USE_IOCP
    }
}

// Combining Macros and Comptime
%macro OPTIMIZED_LOOP 2
    comptime int64:unroll_factor = %2;
    %rep unroll_factor
        %1;
    %endrep
%endmacro

9. Complete AST Token List
The following list comprises the mandatory tokens for the Lexer/Parser implementation.
Literals
* INTEGER_LITERAL (42, 0xFF, 0b1010, 0o755)
* FLOAT_LITERAL (3.14, 1e10, 0x1.2p3)
* STRING_LITERAL ("hello", 'world')
* TEMPLATE_LITERAL (template with &{var})
* BOOLEAN_LITERAL (true, false)
* NULL_LITERAL (NULL)
* CHAR_LITERAL ('a')
Identifiers
* IDENTIFIER (variable names, function names)
* TYPE_IDENTIFIER (int8, string, obj, etc.)
Type Keywords
* Integers: INT1, INT2, INT4, INT8, INT16, INT32, INT64, INT128, INT256, INT512 (and corresponding UINT).
* Floats: FLT32, FLT64, FLT128, FLT256, FLT512
* Exotic: TRIT, TRYTE, NIT, NYTE
* Structs: VEC2, VEC3, VEC9, DYN, OBJ, STRUCT, STRING, RESULT, FUNC, ARRAY
* System: BOOL, BINARY, BUFFER, STREAM, PROCESS, PIPE, DEBUG, LOG
Memory Keywords
* WILD (opt-out of GC)
* DEFER (RAII cleanup)
* CONST (compile-time constant)
Control Flow Keywords
* IF, ELSE, WHILE, FOR, TILL, WHEN, THEN, END, PICK, FALL
* BREAK, CONTINUE, RETURN
* ASYNC, AWAIT, CATCH
Module System Keywords
* USE (import)
* MOD (define module)
* PUB (public visibility)
* EXTERN (external C functions)
* CFG (conditional compilation)
* COMPTIME (compile-time execution)
Preprocessor / Macro Keywords
* MACRO (%macro - macro definition start)
* ENDMACRO (%endmacro - macro definition end)
* PUSH (%push - push context onto stack)
* POP (%pop - pop context from stack)
* CONTEXT (%context - get current context)
* DEFINE (%define - define preprocessor constant)
* UNDEF (%undef - undefine constant)
* IFDEF (%ifdef - conditional if defined)
* IFNDEF (%ifndef - conditional if not defined)
* IF_PREPROC (%if - preprocessor conditional)
* ELIF (%elif - preprocessor else-if)
* ELSE_PREPROC (%else - preprocessor else)
* ENDIF (%endif - end preprocessor conditional)
* INCLUDE (%include - include file)
* REP (%rep - repeat block)
* ENDREP (%endrep - end repeat)
* MACRO_PARAM (%1, %2, ... - macro parameters)
* CONTEXT_LABEL (%$label - context-local label)
Assignment Operators
* ASSIGN (=), PLUS_ASSIGN (+=), MINUS_ASSIGN (-=), MULT_ASSIGN (*=), DIV_ASSIGN (/=), MOD_ASSIGN (%=)
Arithmetic Operators
* PLUS (+), MINUS (-), MULTIPLY (*), DIVIDE (/), MODULO (%), INCREMENT (++), DECREMENT (--)
Comparison Operators
* EQUAL (==), NOT_EQUAL (!=), LESS_THAN (<), GREATER_THAN (>), LESS_EQUAL (<=), GREATER_EQUAL (>=), SPACESHIP (<=>)
Logical & Bitwise Operators
* LOGICAL_AND (&&), LOGICAL_OR (||), LOGICAL_NOT (!)
* BITWISE_AND (&), BITWISE_OR (|), BITWISE_XOR (^), BITWISE_NOT (~), LEFT_SHIFT (<<), RIGHT_SHIFT (>>)
Special Operators
* ADDRESS (@ - address/pointer)
* PIN (# - memory pinning)
* ITERATION ($ - safe loop reference)
* SAFE_NAV (?.)
* NULL_COALESCE (??)
* UNWRAP (?)
* PIPE_FORWARD (|>)
* PIPE_BACKWARD (<|)
* RANGE_INCLUSIVE (..)
* RANGE_EXCLUSIVE (...)
* TERNARY_IS (is)
* LAMBDA (=>)
* FUNC_RETURN (->)
* TEMPLATE_INTERP (&{ })
Punctuation
* LEFT_PAREN ( ), RIGHT_PAREN ( )
* LEFT_BRACE { }, RIGHT_BRACE { }
* LEFT_BRACKET [ ], RIGHT_BRACKET [ ]
* SEMICOLON (;), COMMA (,), DOT (.), COLON (:), QUESTION (?), BACKTICK (`)
Special Tokens
* EOF, INVALID
* WHITESPACE, NEWLINE
* COMMENT_LINE (//), COMMENT_BLOCK_START (/), COMMENT_BLOCK_END (/)
Stream Identifiers
* STDOUT, STDERR, STDDBG, STDIN, STDDATI, STDDATO
Allocator Functions (Keywords/Reserved)
* ARIA_ALLOC, ARIA_FREE, ARIA_GC_ALLOC, ARIA_ALLOC_BUFFER, ARIA_ALLOC_STRING, ARIA_ALLOC_ARRAY
End of Specification v0.0.6
