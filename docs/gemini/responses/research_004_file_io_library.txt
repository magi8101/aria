Architectural Specification: Modern File I/O Subsystem for the Aria Language
1. Executive Summary
This research report presents a comprehensive architectural design for the File Input/Output (I/O) subsystem of the Aria programming language. As Aria targets the intersection of high-performance systems programming and memory safety—distinguished by its unique "Appendage Theory" memory model and Twisted Balanced Binary (TBB) arithmetic—the I/O library serves as a critical foundational component. The existing specification provides rudimentary capabilities (readFile, writeFile, openFile), but lacks the robustness, safety, and asynchrony required for modern systems applications.
This analysis proposes a multi-layered I/O architecture that integrates seamlessly with Aria's implicit result return types, TBB sticky error propagation, and hybrid garbage-collected/manual memory management. Key recommendations include:
1. Unified File Resource Handle: A RAII-compliant File structure leveraging defer for deterministic resource management, bridging the gap between managed GC lifecycles and OS file descriptors.
2. TBB-Integrated Error Handling: A novel error mapping strategy where operational errors (e.g., "File Not Found") populate the result.err field, while computational I/O errors (e.g., invalid seek offsets, buffer size overflows) utilize TBB ERR sentinels for sticky propagation, eliminating classic integer overflow vulnerabilities in I/O arithmetic.
3. Hybrid Async Runtime: A design that utilizes io_uring on Linux and I/O Completion Ports (IOCP) on Windows for true non-blocking asynchronous operations, exposed via Aria's async/await syntax and Future<T> types.
4. Zero-Copy Optimizations: Explicit support for wild memory buffers and memory-mapped files to bypass Garbage Collection overhead in high-throughput scenarios.
The report concludes with a detailed implementation roadmap, comparative analysis against Rust, Go, and Zig, and concrete API definitions compliant with the Aria 0.0.9 specification.
2. Introduction
The design of a standard library's I/O module is often the litmus test for a language's viability in systems programming. It requires a delicate balance between the raw performance of operating system syscalls and the safety guarantees of the language runtime. For Aria, this challenge is compounded by its unique features: a hybrid memory model involving "wild" (unmanaged) and "gc" (managed) heaps, and a numeric system based on Twisted Balanced Binary (TBB) integers which inherently carry error states.
2.1 The Current State of Aria I/O
The current Aria specification defines a minimal surface area for file interactions:


Code snippet




readFile(path: string) -> string
writeFile(path: string, content: string)
openFile(path: string, mode: string) -> File

While sufficient for scripting, this API is inadequate for system-level software. It forces the loading of entire files into memory (readFile), lacks explicit control over buffering, does not specify behavior for binary data, and leaves asynchronous interaction undefined. Furthermore, the relationship between TBB error sentinels and I/O failures remains unspecified.
2.2 Design Goals
The proposed architecture aims to satisfy the following objectives:
1. Safety: Prevent resource leaks (file descriptors), buffer overflows, and race conditions during async access.
2. Performance: Enable zero-copy operations where possible and minimize context switching via modern async polling mechanisms (e.g., io_uring).
3. Integration: seamless interoperation with Aria's TBB types for offset calculations and size management, ensuring arithmetic safety propagates to I/O operations.
4. Ergonomics: Provide idiomatic APIs using defer for cleanup, ? for error unwrapping, and pipelines (|>) for stream transformation.
3. Theoretical Framework: I/O in the Context of Aria
Before defining the API, we must establish how Aria's core features—specifically Result types, TBB arithmetic, and Memory Models—interact with Input/Output operations.
3.1 The Implicit Result Type
Aria functions implicitly return a result structure containing {err, val}.1 This differs fundamentally from Go's multiple return values (value, error) or Rust's Result<T, E> enum. In Aria, the error state is always present but may be NULL.
* Implication for I/O: Every I/O operation must be treated as potentially failing. The API must encourage the use of the unwrap operator (?) or explicit checks (is r.err == NULL).
* Design Decision: I/O functions will populate val with the requested data (or byte count) on success and err with a structured error object on failure.
3.2 TBB Sticky Error Propagation
TBB types (tbb8, tbb64, etc.) use their minimum representable value as an ERR sentinel.1 Any operation involving ERR results in ERR.
* Implication for I/O: File offsets, read lengths, and buffer sizes should ideally use TBB types (e.g., tbb64 for file sizes).
* Scenario: If a user calculates a seek offset and an overflow occurs, the offset becomes ERR. Passing this ERR value to seek() should not perform a syscall but immediately return a runtime error in result.err.
* Safety Gain: This eliminates a class of bugs where integer overflows lead to arbitrary file reads/writes. The "sticky" nature means a long chain of offset calculations need not be checked at every step; the final seek call will simply fail if any step produced ERR.
3.3 Memory Model: GC vs. Wild
Aria supports gc (garbage collected) and wild (manual) memory.1
* GC Memory: Safe, easy to use, but may be moved by a compacting collector. Passing a GC buffer to an OS syscall (which expects a stable address) requires pinning (# operator).
* Wild Memory: Stable addresses, suitable for high-performance I/O buffers, but requires manual deallocation (aria.free).
* Design Decision: The I/O API must accept both. For async operations, wild buffers are preferred to avoid pinning the GC heap for extended durations.
4. File I/O API Design
The API is designed to be modular, separating high-level convenience functions from low-level stream operations. We introduce the std.io module.
4.1 The File Structure
The core primitive is the File struct, representing an open file descriptor. It encapsulates the OS handle and provides methods for reading, writing, and seeking.


Code snippet




// std.io module definitions

// Constants for file modes (using bitflags logic if supported, or distinct objects)
const:READ_ONLY  = "r";
const:WRITE_ONLY = "w";
const:READ_WRITE = "rw";
const:APPEND     = "a";
const:CREATE     = "c"; // Create if not exists
const:TRUNCATE   = "t"; // Truncate on open

// The File struct definition (opaque implementation details hidden)
struct:File = {
   wild int32:fd,      // OS File Descriptor (wild/unmanaged)
   string:path,        // Path for debug/error context
   bool:is_open,       // State tracking
   
   // Core Methods
   func:read = int64(wild byte*:buffer, int64:len);
   func:write = int64(wild byte*:buffer, int64:len);
   func:seek = int64(tbb64:offset, int8:whence);
   func:close = void();
   func:sync = void(); // Flush to disk
};

4.2 Opening and Closing Files
We use a factory function pattern. The critical design element here is resource management via defer.
Function Signature:


Code snippet




func:open = File(string:path, string:mode, int32:perm_mode);

Usage Pattern (RAII Style):


Code snippet




use std.io;

func:processData = void() {
   // Open file,? unwraps result, fails if err!= NULL
   File:f = io.open("data.bin", "r", 0o644)? fail(result.err);
   
   // Ensure closure on scope exit
   defer f.close();

   // Usage...
   //...
};

Comparison with Other Languages:
* Rust (std::fs::File): Uses RAII (Drop trait) to close files automatically.2 Aria lacks implicit destructors for struct types in the current spec (only defer is explicit), so explicit defer f.close() is closer to the Go pattern but safer than C.
* Go (os.Open): Requires explicit defer f.Close().3 Aria adopts this explicit resource management, which aligns with its philosophy of explicit control (wild vs gc).
* Zig (std.fs.cwd().openFile): Uses defer file.close().4 Zig emphasizes handling the directory handle (Dir). Aria's current spec implies global path resolution, but a Dir struct could be added later for capability-based security.
4.3 Read and Write Operations
Aria's read and write functions must handle buffer management carefully. We provide overloads or separate functions for GC vs Wild buffers.
Low-Level API (Wild Buffers - Zero Copy):
These functions map directly to syscalls (read/write on POSIX).


Code snippet




// Reads 'len' bytes into 'buffer'. Returns bytes read.
func:read = int64(wild byte*:buffer, int64:len) {... }

High-Level API (GC Buffers):
Wrappers that handle pinning.


Code snippet




// Reads into a GC-managed array
func:readArray = int64(byte:buffer) {
   // Implicitly pin buffer if required by runtime implementation
   wild byte*:ptr = #buffer; // Pin operator
   return this.read(ptr, buffer.length);
}

Usage Example:


Code snippet




// Allocating a wild buffer for performance
wild byte*:buf = aria.alloc_buffer(4096);
defer aria.free(buf);

int64:bytes_read = f.read(buf, 4096)? 0;

4.4 Seek and TBB Integration
Here we leverage TBB types for safety. seek operations often involve calculating offsets relative to the current position or file end. In standard integers, current_pos + offset can overflow. In Aria, if offset is ERR (due to a bad calculation previously), seek detects this immediately.


Code snippet




// TBB-safe seek
// offset is tbb64. If offset is ERR, the function fails immediately.
func:seek = tbb64(tbb64:offset, int8:whence) {
   if (offset == ERR) {
       fail("Invalid offset: TBB Error Sentinel detected");
   }
   // Perform syscall...
};

Scenario:


Code snippet




tbb64:base = 1000;
tbb64:adjustment = -999999999999; // Assume this triggers underflow/ERR
tbb64:target = base + adjustment; // target becomes ERR due to sticky propagation

// This call fails gracefully with a clear error, not a random seek to a garbage address
f.seek(target, SEEK_SET); 

4.5 Standard Streams
Aria defines standard streams.1 These should be exposed as initialized File objects or compatible Stream interfaces.
* stdin, stdout, stderr: Text-based standard streams.
* stddbg: Debug stream (likely unbuffered or line-buffered).
* stddati, stddato: Binary data streams (pipeline friendly).
5. Error Handling Strategy
Aria's error handling for I/O is distinct because it must unify OS-level error codes (errno), Aria's result type structure, and TBB sentinels.
5.1 The Taxonomy of I/O Errors
We categorize errors into three types:
1. Operational Errors: Runtime conditions external to the program logic (e.g., File Not Found, Permission Denied, Disk Full).
2. Logic Errors: Programming mistakes (e.g., reading from a closed file, null pointer buffer).
3. Computational Errors: Numeric issues in calculating parameters (handled by TBB).
5.2 Mapping OS Errors to Aria Results
When a syscall fails, the OS returns an error code (e.g., ENOENT). Aria needs to map these to usable objects in the result.err field.
We define an IOError struct that wraps the system error code:


Code snippet




struct:IOError = {
   int32:code,      // System specific errno
   string:message,  // Human readable message
   string:op,       // Operation that failed ("read", "open")
   string:path      // Associated path (if any)
};

Error Constants (Platform Agnostic Mapping):
Instead of exposing raw ENOENT integers, the std.io module should provide constants that map correctly per platform (handled by cfg attributes).


Code snippet




// std.io error constants
const:ERR_NOT_FOUND = 1;  // Maps to ENOENT (Unix) / ERROR_FILE_NOT_FOUND (Win)
const:ERR_PERMISSION = 2; // Maps to EACCES
const:ERR_EOF = 3;        // End of file sentinel

5.3 Error Propagation Patterns
Pattern 1: The Unwrap-Or-Fail (?)
Used when the caller cannot handle the error and wants to propagate it up the stack.


Code snippet




func:loadConfig = string(string:path) {
   File:f = io.open(path, "r")? return {err: result.err, val: NULL};
   //...
}

Note: Since Aria functions implicitly return result, return {err:...} explicitly constructs the failure.
Pattern 2: The Coalesce (??)
Used for default values.


Code snippet




// If open fails, return default config string immediately (simplified logic)
File:f = io.open("config.txt", "r")?? return DEFAULT_CONFIG;

Pattern 3: TBB Sentinel Checking
Used for calculating sizes or offsets safely.


Code snippet




tbb64:size = f.size()? ERR; // If stat fails, size becomes ERR
tbb64:new_size = size + 1024; // Sticky: if size was ERR, new_size is ERR

if (new_size == ERR) {
   // Handle the math error or the I/O error unified here
   stderr.write("Failed to calculate new size");
}

5.4 Comparison with Other Languages
* Go: Returns (value, error). Requires if err!= nil boilerplate.3 Aria's ? operator reduces this verbosity significantly.
* Rust: Uses Result enum. Requires pattern matching or ?. Aria is similar but the result struct is a primitive, not an enum, meaning val is always accessible (though potentially invalid), requiring discipline via is or ?.
* Zig: Uses Error Unions (!T). Very similar to Aria's implicit result, but Zig forces handling. Aria allows ignoring err (unsafe), so tooling/linters must enforce checks.
6. Asynchronous I/O Integration
Async I/O is crucial for the "high-performance" claim of Aria. The language supports async/await and coroutines 1, which must be hooked into the I/O subsystem.
6.1 Architecture: The Scheduler and Reactor
The research indicates Aria uses a coroutine-based scheduler.1 For I/O, simply spawning threads is inefficient. The modern standard is a Proactor pattern using io_uring on Linux and IOCP on Windows.5
Proposed Runtime Architecture:
1. Submission: When async f.read() is called, the runtime constructs an io_uring submission queue entry (SQE) or an IOCP overlapped request.
2. Suspension: The calling coroutine is suspended. Its CoroutineFrame is parked in a "waiting" state.
3. Completion: When the OS completes the operation, it places an event in the completion queue (CQE).
4. Resumption: The scheduler polls the CQE, identifies the suspended coroutine, and wakes it up with the result.
6.2 Async API Design
The async API mirrors the sync API but is marked with async keywords and returns Future types implicitly.


Code snippet




// Async read function
async func:readAsync = int64(wild byte*:buffer, int64:len) {
   // 1. Prepare async request
   // 2. Submit to reactor (io_uring/IOCP)
   // 3. Suspend via await mechanism
   // 4. Return bytes read on resumption
}

Usage:


Code snippet




async func:processLog = void() {
   File:f = io.open("server.log", "r")? return;
   wild byte*:buf = aria.alloc_buffer(1024);
   
   // Non-blocking wait
   int64:bytes = await f.readAsync(buf, 1024);
   
   print(`Read &{bytes} bytes`);
   f.close();
}

6.3 Memory Safety in Async (The Pinning Problem)
A major challenge in async I/O with GC languages is buffer movement. If a GC cycle occurs while the OS is writing to a buffer, memory corruption ensues.7
Solution: Explicit Pinning or Wild Buffers
Aria's wild buffers are immune to GC movement, making them ideal for async I/O.
If a user wants to read into a GC array, the API must enforce pinning:


Code snippet




async func:readSafe = int64(byte:gc_buf) {
   // The # operator pins the memory, returning a stable wild pointer
   wild byte*:ptr = #gc_buf; 
   
   // The runtime must ensure the pin survives until the await completes
   // Ideally, the Future holds a reference to the pin token
   int64:res = await this.readAsync(ptr, gc_buf.length);
   
   return res; 
   // Pin is released when 'ptr' goes out of scope, 
   // but we must ensure await keeps 'ptr' alive.
}

6.4 Streaming Large Files
For large files, loading everything into memory is anti-pattern. Aria should support an AsyncIterator pattern.


Code snippet




// Concept for streaming lines asynchronously
async func:lines = stream<string>(File:f) {
   wild buffer:buf = aria.alloc_buffer(4096);
   defer aria.free(buf);
   
   while (true) {
       // Read chunk
       int64:n = await f.readAsync(buf, 4096);
       if (n == 0) break; // EOF
       
       // Yield lines (parsing logic omitted)
       yield line;
   }
}

7. Performance Optimizations
7.1 Memory Mapped Files
Research highlights mmap as superior for random access on large files.8 Aria should expose this via a MappedFile struct.


Code snippet




struct:MappedFile = {
   wild byte*:ptr,
   int64:len,
   func:close = void();
};

func:mmap = MappedFile(File:f, int64:len, int:prot, int:flags);

Using mmap fits perfectly with Aria's wild pointer semantics (byte*), allowing array-like access to file contents without explicit read/write calls.
7.2 Zero-Copy Splice
For networking (e.g., file server), moving data from disk to socket without user-space copying is vital.9


Code snippet




// splice: moves data between file descriptors without copying to user memory
func:transferTo = int64(File:source, File:dest, int64:count);

8. Implementation Roadmap
Phase 1: Core Synchronous API
1. Implement std.io.File struct wrapping int file descriptors.
2. Implement open, close, read, write, seek wrappers around C standard library (fopen/fread) or POSIX (open/read) for baseline functionality.
3. Define std.io.IOError and the constant mappings.
Phase 2: TBB Integration
1. Update seek to accept tbb64.
2. Implement the sticky error check: if (offset == ERR) return Error(...).
3. Ensure file size queries return tbb64.
Phase 3: Async Runtime (Linux)
1. Implement io_uring submission/completion queue management in the runtime.
2. Create the Future integration for I/O tasks.
3. Implement readAsync/writeAsync using IORING_OP_READV / IORING_OP_WRITEV.
Phase 4: High-Level Abstractions
1. Implement BufReader and BufWriter for buffered synchronous I/O.
2. Implement mmap wrappers.
3. Create convenience functions readAllText, writeAllText utilizing the robust primitives.
9. Conclusion
The proposed file I/O design for Aria leverages the language's unique strengths to create a system that is both performant and safe. By adopting explicit resource management (RAII/defer), integrating TBB sticky errors to prevent arithmetic vulnerabilities, and utilizing a modern async runtime based on io_uring, Aria can surpass legacy system languages in ease of use while matching them in raw throughput. The distinct separation of "wild" buffers for performance and pinned GC buffers for convenience solves the classic managed-language async I/O dilemma, positioning Aria as a formidable tool for modern systems programming.
________________
Detailed Analysis: File I/O Library Design for Aria
1. Context and Problem Definition
The Aria language specification currently provides a nascent interface for file operations: readFile, writeFile, and openFile. While these primitives allow for basic interaction with the filesystem, they lack the depth required for robust systems programming. In the context of a language that features "Twisted Balanced Binary" (TBB) types, a hybrid memory model ("Appendage Theory"), and first-class support for concurrency (async/await), a naive wrapper around C's stdio.h is insufficient.
The challenge lies in designing an API that:
1. Respects the Memory Model: Safely handles the interaction between Garbage Collected (GC) memory and OS system calls which require stable pointers.
2. Leverages TBB Types: Utilizes the symmetric integer ranges and sticky error propagation of TBB types to enhance safety in file seeking and size calculations.
3. Scales Asynchronously: integrating with the underlying scheduler without blocking OS threads, a requirement for high-concurrency applications like web servers.
This report synthesizes analysis of modern I/O patterns in Rust (tokio::fs, std::fs), Go (os, io), and Zig (std.fs) to propose a cohesive design for Aria.
2. API Design Philosophy
2.1 The Unified File Handle
At the core of the I/O library is the File structure. Unlike higher-level abstractions that might obscure the underlying OS resource, Aria's File should be a thin, transparent wrapper around the OS file descriptor (fd) or handle.
Structure Definition:


Code snippet




mod std {
   mod io {
       // The File struct acts as a handle to an OS resource.
       // It is not Copy, ensuring ownership semantics are clear.
       pub struct:File = {
           // Internal file descriptor. 
           // 'wild' indicates it is not managed by GC (it's an OS resource).
           wild int32:fd = -1; 
           
           // Path kept for error context/debugging
           string:path;
       };
   }
}

2.2 Resource Management (RAII vs. Defer)
Rust uses RAII (Resource Acquisition Is Initialization) where the Drop trait automatically closes files when they go out of scope.2 Go and Zig rely on defer statements to explicitly schedule cleanup.10
Recommendation for Aria:
Given Aria's explicit defer keyword 1, the idiomatic pattern should follow Go and Zig. While a finalizer (GC-based cleanup) can act as a safety net, it is non-deterministic. Systems programming requires deterministic resource release.
Idiom:


Code snippet




// Recommended Pattern
File:f = openFile("data.txt", "r")? fail(result.err);
defer f.close(); // Deterministic closing at scope exit

2.3 Opening Modes and Flags
Instead of C-style string modes ("r", "wb"), which are prone to runtime errors, or Rust's builder pattern (OpenOptions), Aria should use a strongly-typed approach compatible with its TBB bitwise capabilities.
Proposal: Use bitflags defined as constants.


Code snippet




// Constants for Open Options
const int32:O_READ   = 0x0001;
const int32:O_WRITE  = 0x0002;
const int32:O_CREATE = 0x0004;
const int32:O_TRUNC  = 0x0008;
const int32:O_APPEND = 0x0010;

// Usage
File:f = io.open("log.txt", O_WRITE | O_CREATE | O_APPEND);

2.4 The Buffer Abstraction
Modern I/O is buffer-centric. A major design decision is whether to use string (immutable), array (GC-managed), or buffer (wild/raw memory).
Recommendation:
* Synchronous API: Accept byte (GC array). The implementation handles pinning internally.
* Asynchronous API: Prefer wild buffer (raw memory) or explicitly pinned byte. This avoids the complexity of keeping GC objects pinned for indeterminate durations during async waits.
3. Error Handling with TBB and Results
Aria's error handling is unique due to the intersection of the implicit result type and TBB sticky errors.
3.1 Dual-Layer Error Reporting
1. Operational Errors (result.err): Failures derived from the environment (e.g., permission denied, disk full). These map to the err field of the return type.
2. Logic/Data Errors (TBB ERR): Failures derived from invalid calculations passed to I/O functions (e.g., negative offset where unsigned expected, overflow in size calculation).
3.2 TBB Sticky Error Integration
The tbb64 type is ideal for file offsets and sizes due to its huge symmetric range and error sentinel.
The Sticky Seek Pattern:
In standard C/POSIX, lseek returns -1 on error. In Aria, we can leverage TBB.


Code snippet




// Scenario: Calculating a seek position
tbb64:header_size = 1024;
tbb64:record_index = getIndex(); // Returns ERR if invalid
tbb64:record_size = 256;

// Sticky Propagation:
// If record_index is ERR, 'offset' becomes ERR automatically.
// No 'if (index == ERR)' check needed here.
tbb64:offset = header_size + (record_index * record_size);

// The I/O function 'seek' checks for the sentinel
// If input is ERR, it sets result.err to "Invalid Seek Offset"
f.seek(offset, SEEK_SET)? fail("Seek failed");

Mapping OS Errors:
Aria needs a standardized IOError type that wraps the OS errno.


Code snippet




// In std.io module
pub struct:IOError = {
   int32:errno,
   string:message,
   // Helper to check error types
   func:isNotFound = bool() { return this.errno == ENOENT; };
   func:isPermission = bool() { return this.errno == EACCES; };
};

4. Asynchronous I/O Architecture
Async I/O is non-negotiable for modern high-performance networking and file serving. Rust uses Tokio (Reactor/Poller).12 Aria's runtime appears to support coroutines (async/await).
4.1 Implementation Model: io_uring vs Thread Pool
* Thread Pool (Legacy/Compatibility): Like tokio::fs on non-Linux platforms.13 Blocking syscalls run on a separate thread pool. Easier to implement but higher overhead (context switches).
* io_uring (Modern Linux): True async file I/O. Zero-copy capabilities. Extremely high performance.14
Recommendation: Aria should implement a hybrid reactor.
* Linux: Use io_uring. The File struct holds a file descriptor registered with the ring. readAsync submits an SQE (Submission Queue Entry) and suspends the coroutine. The scheduler resumes it upon CQE (Completion Queue Entry).
* Windows: Use IOCP (I/O Completion Ports).6
* Fallback: Thread pool for other OSs.
4.2 Async API Surface
The async API should mirror the sync API but return Future objects (implicitly handled by await).


Code snippet




// Async read
async func:readBytes = result(wild byte*:buf, int64:len) {
   // Suspend coroutine until IO complete
   int64:read = await internal_io_read(this.fd, buf, len);
   pass(read);
}

4.3 Streaming
For large files, loading all content is prohibitive. Aria should support async streams (iterators).


Code snippet




// Usage Example: Async Line Reader
async func:processLog = void() {
   File:log = io.open("server.log", "r")? return;
   defer log.close();

   // 'lines()' returns an async iterator
   for (line in log.lines()) {
       await process(line);
   }
}

5. Comparative Analysis
Feature
	Rust (std::fs / tokio::fs)
	Go (os)
	Zig (std.fs)
	Aria Proposal
	Paradigm
	RAII + Result Enum
	Defer + Multiple Return
	Defer + Error Union
	Defer + Result Struct
	Async
	Separate crate (tokio), split ecosystem
	Goroutines (Green threads), blocking style
	Async/Await (integrated)
	Native Async/Await
	Error Handling
	Result<T, E>
	if err!= nil
	try / catch
	? operator + TBB Sticky
	Memory
	Ownership/Borrowing
	GC
	Manual Allocators
	Hybrid (GC + Wild)
	Buffering
	Explicit BufReader
	bufio package
	Explicit BufferedReader
	BufReader wrapper
	6. Implementation Plan & Examples
6.1 Low-Level Wrappers (Internal)
These map to C functions via extern.


Code snippet




extern "libc" {
   func:open = int32(string:path, int32:flags);
   func:close = int32(int32:fd);
   func:read = int64(int32:fd, wild byte*:buf, int64:count);
   func:write = int64(int32:fd, wild byte*:buf, int64:count);
}

6.2 The File Class Implementation


Code snippet




mod std {
   mod io {
       // TBB Error Sentinel for checks
       const tbb64:OFFSET_ERR = ERR;

       pub struct:File = {
           wild int32:fd = -1;
           
           // Sync Read
           pub func:read = int64(wild byte*:buf, int64:len) {
               if (fd < 0) fail("File closed");
               
               // Call libc read
               int64:res = extern.read(fd, buf, len);
               
               if (res < 0) {
                   // Map errno to Aria error
                   fail(getExternalError()); 
               }
               pass(res);
           };

           // TBB-Aware Seek
           pub func:seek = int64(tbb64:offset, int32:whence) {
               // TBB Safety Check: Sticky Error
               if (offset == OFFSET_ERR) {
                   fail("Invalid offset: Calculation error");
               }
               
               // Normal seek logic...
           };
       };
   }
}

6.3 Usage Example: High-Performance Copy
This example demonstrates defer, wild memory allocation, and TBB safety.


Code snippet




use std.io;
use std.aria; // For alloc

func:copyFile = void(string:src, string:dst) {
   // Open source
   File:in_file = io.open(src, io.O_READ)? fail(result.err);
   defer in_file.close();

   // Open dest (Create + Truncate)
   File:out_file = io.open(dst, io.O_WRITE | io.O_CREATE | io.O_TRUNC)? fail(result.err);
   defer out_file.close();

   // Allocate 64KB buffer in WILD memory (no GC overhead)
   tbb64:buf_size = 64 * 1024; 
   wild byte*:buf = aria.alloc(buf_size);
   defer aria.free(buf);

   // Copy loop
   while (true) {
       int64:read_bytes = in_file.read(buf, buf_size)? break; // Error or 0
       if (read_bytes == 0) break; // EOF

       out_file.write(buf, read_bytes)? fail("Write failed");
   }
}

7. Conclusions and Recommendations
The proposed file I/O design for Aria bridges the gap between Aria's innovative core features and the practical realities of systems programming. By enforcing RAII via defer, leveraging TBB for safe offset arithmetic, and providing first-class support for wild memory buffers in async contexts, Aria can offer a file I/O experience that is safer than C, more ergonomic than Go, and potentially faster than managed runtime alternatives.
Critical Next Steps:
1. Define IOError: Standardize the mapping of POSIX errno to Aria error types.
2. Implement BufReader: Essential for performance when reading lines or small data chunks.
3. Validate io_uring bindings: Ensure the Aria runtime scheduler correctly handles ring buffer submissions without blocking the main thread.
This library design ensures that "File I/O" becomes a robust, standard capability of Aria, ready for heavy workloads.
________________
Detailed Analysis: Error Handling Strategy & TBB Integration
1. The TBB Error Paradigm
Aria's Twisted Balanced Binary (TBB) types introduce a paradigm shift in error handling for numerical operations. Unlike standard integers where overflow wraps around (causing silent logic bugs), TBB types saturate at an ERR sentinel (the minimum representable value). This feature is "sticky," meaning ERR + 1 = ERR.
This behavior is particularly powerful in File I/O for offset arithmetic and buffer sizing.
1.1 TBB in File Seeking
File seeking involves calculating offsets. A classic vulnerability involves integer overflows in offset calculations allowing attackers to read arbitrary memory or file locations.
Standard Vulnerability (C/C++ style):


C




long offset = base + (index * record_size); // Overflow can result in valid positive offset
lseek(fd, offset, SEEK_SET); // Seeks to wrong location

Aria TBB Safety:


Code snippet




tbb64:base = 1000;
tbb64:index = input_from_user(); 
tbb64:size = 256;

// If (index * size) overflows tbb64 range:
// The result is immediately ERR.
// 'offset' becomes ERR.
tbb64:offset = base + (index * size); 

// The seek function checks input.
// If input == ERR sentinel, it aborts BEFORE the syscall.
file.seek(offset, SEEK_SET); // Fails safely.

1.2 Mapping System Errors to TBB?
A key research question was whether file system errors (like FileNotFound) should map to TBB ERR.
* Analysis: TBB ERR is a numerical sentinel. It has no payload (no error message, no code).
* Decision: Do not map FileNotFound to tbb32:ERR. FileNotFound is a distinct operational state that requires context (path, permission details).
* Strategy: Use TBB ERR strictly for computational validity (offsets, sizes, timeouts). Use the result.err object for operational failures.
2. The Result Object & Unwrap Operator
Aria's implicit result return type is the primary vehicle for I/O error propagation.
2.1 The result Structure
Every function implicitly returns:


Code snippet




struct Result<T> {
   obj:err; // NULL on success, Error Object on failure
   T:val;   // The return value (valid only if err is NULL)
}

2.2 Integration with ? (Unwrap)
The ? operator is syntactic sugar for "propagate error or give me value".
In File I/O:


Code snippet




// Without?
result:r = readFile("doc.txt");
if (r.err!= NULL) {
   // Handle error manually
   return r; // Propagate
}
string:content = r.val;

// With? (Idiomatic Aria)
// If readFile fails, the current function returns r.err immediately.
string:content = readFile("doc.txt")?; 

2.3 The Coalescing Operator (??)
Useful for fallback logic in I/O.


Code snippet




// Try to open user config, fallback to default if missing/error
File:config = io.open("user.cfg", "r")?? io.open("default.cfg", "r")?;

3. Error Codes vs Exception Objects
Since Aria aims for system-level efficiency, creating heavy exception objects for every EOF is wasteful.
Recommendation:
Use a lightweight Error struct that can wrap a simple integer code (for performance) but allows attaching a string message (for debugging).


Code snippet




// Lightweight error struct
struct:Error = {
   int16:code;      // e.g. ERR_EOF, ERR_NOENT
   string:msg;      // "File not found"
};

This hybrid approach satisfies both the performance needs of tbb logic (checking code) and the usability needs of higher-level logic (printing msg).
________________
Detailed Analysis: Async I/O Integration
1. The Need for Async I/O
File I/O is blocking by nature. In a synchronous model, a thread blocked on read() cannot do useful work. For a language targeting servers (like Aria), this is unacceptable.
2. Integration with Aria Scheduler
Aria uses coroutines (async/await). The I/O subsystem must interface with the scheduler to park and wake coroutines.
2.1 The Future Handle
When async file.read() is called, it returns a Future.
* State: PENDING, COMPLETED, FAILED.
* Action: When await is called on the Future, if it is PENDING, the current coroutine yields execution to the scheduler.
2.2 Backend: io_uring (Linux)
The most efficient implementation for Aria on Linux is io_uring.5
Mechanism:
1. Submission: The runtime writes a "Read Op" to the io_uring Submission Queue (SQ) ring buffer. It attaches the CoroutineID as user data.
2. Syscall: A single io_uring_enter syscall submits the request (or it might be polled).
3. Yield: The coroutine suspends.
4. Completion: The kernel performs the DMA transfer directly into the wild buffer provided. It writes a completion event to the Completion Queue (CQ).
5. Wakeup: The scheduler polls the CQ, sees the CoroutineID, and marks that coroutine as READY.
2.3 Backend: Thread Pool (Fallback)
For OSs without high-performance async I/O (or for compatibility), Aria must implement a thread pool.
1. async read spawns a task on a dedicated "Blocking I/O" thread pool.
2. The main thread yields the coroutine.
3. The blocking thread performs read().
4. Upon completion, it signals the main scheduler (via channel or atomic flag) to wake the coroutine.
3. Streaming and Iterators
Reading a 10GB file into a string (readFile) causes OOM. Aria needs AsyncIterator.
Design:


Code snippet




// Interface for async iteration
trait:AsyncIterator<T> = {
   async func:next = result(T:val); // Returns NULL/EOF when done
};

// File implements AsyncIterator<byte> (chunks)
async func:processLargeFile = void() {
   File:f = io.open("huge.log", "r")?;
   
   // 'chunks(size)' returns an iterator
   // 'for await' syntax handles the async iteration
   for await (chunk in f.chunks(4096)) {
       process(chunk);
   }
}

4. Memory-Mapped Files (mmap)
For random access patterns, mmap is superior.8 It maps file pages directly to memory addresses.
Integration with Aria:
* mmap returns a wild byte* pointer.
* Safety: The OS manages paging. Accessing the pointer might trigger a page fault (blocking), but logically it looks like memory access.
* TBB Safety: TBB types can prevent accessing out-of-bounds memory on the mmap region.


Code snippet




// mmap API
func:mapFile = result(wild byte*:ptr, int64:len) {... }

// Usage
result:map = f.map(PROT_READ, MAP_PRIVATE);
wild byte*:data = map.val;
// Access data[i] directly

Conclusion on Async:
Aria's async I/O should be "Zero-Cost" where possible, utilizing io_uring and wild buffers to avoid copying data between kernel, runtime, and user space. This aligns with the language's high-performance goals.
Works cited
1. aria_specs.txt
2. File in std::fs - Rust, accessed December 11, 2025, https://doc.rust-lang.org/stable/std/fs/struct.File.html
3. What are the best practices for error handling in Go applications? : r/golang - Reddit, accessed December 11, 2025, https://www.reddit.com/r/golang/comments/1pdzpbh/what_are_the_best_practices_for_error_handling_in/
4. Best practices writing to stdout - Explain - Ziggit, accessed December 11, 2025, https://ziggit.dev/t/best-practices-writing-to-stdout/2760
5. Is epoll a better API than io_uring? - Stack Overflow, accessed December 11, 2025, https://stackoverflow.com/questions/76598320/is-epoll-a-better-api-than-io-uring
6. I/O Completion Ports - Win32 apps - Microsoft Learn, accessed December 11, 2025, https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports
7. Possible to mix garbage collection and manual memory management?, accessed December 11, 2025, https://langdev.stackexchange.com/questions/2956/possible-to-mix-garbage-collection-and-manual-memory-management
8. mmap() vs. read(): A Performance Comparison for Efficient File Access | by Harshilshah | Cosmos Code | Medium, accessed December 11, 2025, https://medium.com/cosmos-code/mmap-vs-read-a-performance-comparison-for-efficient-file-access-3e5337bd1e25
9. Zero-Copy I/O: From sendfile to io_uring – Evolution and Impact on Latency in Distributed Logs - Codemia, accessed December 11, 2025, https://codemia.io/blog/path/Zero-Copy-IO-From-sendfile-to-iouring--Evolution-and-Impact-on-Latency-in-Distributed-Logs
10. Writing to Files in Go: A Comprehensive Guide | Leapcell, accessed December 11, 2025, https://leapcell.io/blog/writing-to-files-in-go-a-comprehensive-guide
11. Zig Language Reference - Documentation - The Zig Programming Language, accessed December 11, 2025, https://ziglang.org/documentation/master/
12. I/O | Tokio - An asynchronous Rust runtime, accessed December 11, 2025, https://tokio.rs/tokio/tutorial/io
13. tokio::fs - Rust, accessed December 11, 2025, https://docs.rs/tokio/latest/tokio/fs/index.html
14. Missing Manuals - io_uring worker pool - The Cloudflare Blog, accessed December 11, 2025, https://blog.cloudflare.com/missing-manuals-io_uring-worker-pool/