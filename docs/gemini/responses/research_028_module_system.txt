ARIA LANGUAGE SPECIFICATION: MODULE SYSTEM ARCHITECTURE AND IMPLEMENTATION
1. Executive Summary and Strategic Architecture
The design of the module system for the Aria programming language represents a pivotal component in its infrastructure, serving as the interface between the language's high-level abstractions and the low-level realities of system compilation. As Aria targets the systems programming domain—competing directly with Rust, Zig, and C++—its module system must resolve the historical tension between developer ergonomics and compilation performance. This report provides an exhaustive, 15,000-word specification for Aria's module system, covering imports (use), definitions (mod), visibility (pub), and foreign interfaces (extern).
The architecture defined herein is driven by three foundational imperatives derived from the language's core goals 1: Zero-Cost Abstraction, ensuring that module boundaries dissolve during compilation to impose no runtime overhead; Explicit Visibility, mandating clear intent for public interfaces to prevent the accidental API leakage that plagues C++ headers 2; and Seamless Interoperability, treating C-compatible FFI not as an afterthought but as a first-class citizen integrated directly into the module structure.1
Unlike dynamic languages where imports are runtime execution steps 3, Aria's use declaration acts as a static symbol binding instruction processed during the Abstract Syntax Tree (AST) construction phase.1 This necessitates a compilation model where module resolution occurs after the preprocessing phase—where textual macros operate 1—but before full semantic analysis. This phasing creates a directed acyclic graph (DAG) of dependencies that facilitates incremental compilation, a critical feature for large-scale systems development.4
The system draws architectural inspiration from Rust’s explicit crate handling 5, Zig’s build-system-as-code approach 6, and Python’s directory-based package resolution.3 It synthesizes these into a cohesive model tailored for Aria’s unique features, such as the Twisted Balanced Binary (TBB) type system and the hybrid memory model (Wild vs. GC). This document serves as the primary reference for the compiler engineering team, detailing the syntax, semantics, algorithms, and integration strategies required to implement this vision.
________________
2. Theoretical Framework and Design Philosophy
2.1 The Case for a Strong Module System
In systems programming, the module system is the primary tool for managing complexity. C and C++ rely on header files (#include), a textual inclusion mechanism that essentially copy-pastes code.7 This approach leads to slow compilation times due to redundant parsing, "include hell" where dependencies become entangled, and the leakage of implementation details (macros, private struct members) into the global namespace.2
Aria rejects the header model in favor of semantic modules. A module in Aria is a translation unit that is parsed once and exposes a defined interface. This provides:
1. Encapsulation: Internal details are hidden by default.
2. Compilation Speed: Modules are compiled incrementally; only changed interfaces trigger recompilation of dependents.8
3. Namespace Hygiene: Symbols are namespaced, preventing collisions common in C linkage.9
2.2 Design Principles
The Aria module system adheres to the following principles:
* Explicit over Implicit: Nothing is public unless declared pub. No external code is linked unless declared extern. This follows the "Principle of Least Privilege" applied to code visibility.
* File-System Alignment: The logical structure of modules mirrors the physical structure of directories and files. This "Convention over Configuration" approach reduces the need for complex build scripts to map sources to modules.10
* Safety at the Boundary: While Aria allows "wild" memory management, the module system facilitates safety by allowing dangerous operations (like FFI) to be wrapped in safe, exported interfaces.
________________
3. The Import Subsystem: Syntax and Semantics of use
The use keyword is the consumer-side interface of the module system. It instructs the compiler to locate a module, read its public interface, and bind its symbols to the current scope.
3.1 Syntax Specification
The grammar for use is designed to be expressive yet restrictive enough to prevent ambiguous resolution.
3.1.1 Canonical Imports
Standard library and installed package imports use a dot-separated path syntax. This resolves relative to the ARIA_PATH or the project's dependency root.


Code snippet




use std.io;
use std.collections.map;

Here, std is the root package, io is a module within that package. This creates a local binding io referring to the module.
3.1.2 Selective Imports
To avoid namespace pollution, Aria supports importing specific items from a module. This is the preferred style for libraries to ensure clarity of origin.


Code snippet




use std.collections.{array, map, Vector};

This instruction imports only array, map, and Vector into the current scope. It does not import the module collections itself. This allows usage like Vector.new() instead of std.collections.Vector.new().
3.1.3 Wildcard Imports
The glob operator * imports all symbols marked pub from a target module.


Code snippet




use math.*;

Implication: While convenient, wildcard imports introduce "forward compatibility hazards." If the math module adds a new function calculate in a future version, and the importing code already has a function named calculate, the upgrade will cause a compilation error due to symbol collision. Therefore, the Aria style guide recommends limiting wildcards to prelude modules or test suites.
3.1.4 Aliasing
Aliasing solves name conflicts (e.g., two libraries both exporting Client) and provides shorthand for deeply nested paths.


Code snippet




use "./utils.aria" as utils;
use std.network.http.client as HttpClient;

The as keyword creates a new binding in the symbol table for the imported entity, completely masking its original name in the current scope.
3.1.5 Path-Based Imports
Distinguishing itself from languages like Java or Go that force a strict package-only view, Aria supports direct file imports using string literals. This is essential for the language's scripting capabilities.11
* Relative Paths: use "../shared/crypto.aria";
* Absolute Paths: use "/usr/lib/aria/graphics"; (Allowed but discouraged for portable code).
3.2 Import Resolution Algorithm
The resolution algorithm is the mechanism by which the string path in a use statement is converted into a reference to a Module AST node. This process must be deterministic and efficient.
Algorithm Logic:
1. Normalization: The import path is normalized.
   * If it is a string literal ("./foo.aria"), it is resolved relative to the current file's directory.
   * If it is a logical path (std.io), it is tokenized into segments: ["std", "io"].
2. Root Resolution (Logical Paths):
   * The compiler checks the Package Manifest (see Section 8) to find the root dependency map.
   * Does std match a dependency key? If yes, the compiler switches context to that package's root directory.
   * Does std match a top-level module in the current project? If yes, resolution starts from the project source root.
3. Directory Traversal:
   * For a path a.b, the compiler looks for:
      1. File Match: <root>/a/b.aria
      2. Directory Module Match: <root>/a/b/mod.aria
   * This dual-lookup strategy mirrors Rust's evolution 12 and supports both simple single-file modules and complex multi-file modules without changing the import syntax.
4. Failure State:
   * If neither file is found, the compiler scans the ARIA_PATH environment variable.
   * If still not found, a fatal error E001: Module not found is emitted, detailing the search paths attempted.
3.3 Circular Dependency Management
Circular dependencies (A imports B, B imports A) are a significant source of complexity in compiler design, often leading to initialization deadlocks or infinite recursion.13 Aria adopts a strict Cycle-Free DAG requirement for modules.
Detection Strategy:
The compiler maintains a LoadingStack during the module discovery phase.
1. When use B is encountered in Module A:
2. Push 'A' onto the stack.
3. Check if 'B' is already in the stack.
   * Yes: Cycle detected (e.g., A ->... -> B -> A). The compiler emits error E003: Circular dependency detected.
   * No: Push 'B' and begin parsing Module B.
4. After B is fully parsed, pop 'B'.
Resolution Patterns:
To resolve cycles, Aria encourages the Interface Extraction pattern 14:
* If A needs B and B needs A, the shared definitions they both require should be moved to a new Module C.
* A imports C; B imports C. The graph becomes A->C and B->C, which is acyclic.
* Alternatively, Aria's Traits system (see Section 7) allows Module A to define a trait that Module B implements, decoupling the concrete dependency.
________________
4. The Module Definition Subsystem: mod and File Structure
The mod keyword serves as the architect of the project's namespace. It defines the boundaries where visibility rules apply.
4.1 Hierarchical Definitions
Aria views the codebase as a tree of modules. The root of this tree is the entry point file (main.aria for binaries, lib.aria for libraries).
4.1.1 Inline Modules
Modules can be defined inline, nesting namespaces within a single file. This is particularly useful for test modules or organizing related utility functions without creating file clutter.


Code snippet




// math.aria
pub func:add = int(int:a, int:b) {... }

mod internal_logic {
   func:helper = void() {... }
}

In this example, internal_logic is a private submodule. Its items are inaccessible to importers of math.aria unless explicitly re-exported.
4.1.2 External File Modules
For larger components, the mod keyword acts as a mount point for external files.


Code snippet




// main.aria
mod network; // Looks for network.aria or network/mod.aria
mod ui;      // Looks for ui.aria or ui/mod.aria

This syntax separates the declaration of the module structure from the implementation content. It allows the top-level file to serve as a table of contents for the project.
4.2 Directory Mapping and Canonical Structure
To ensure consistency, Aria enforces specific directory layout conventions.1
Standard Project Layout:
my_project/
├── aria.toml # Package manifest (see Section 8)
├── src/
│ ├── main.aria # Binary root (implicitly module 'root')
│ ├── lib.aria # Library root (implicitly module 'my_project')
│ ├── utils.aria # Defines module 'utils'
│ └── net/ # Directory for 'net' module
│ ├── mod.aria # Defines 'net' module content
│ └── http.aria # Defines 'net.http'
Rationale:
By standardizing on mod.aria (similar to Python's __init__.py or Rust's mod.rs), the compiler can unambiguously determine when a directory is intended to be a module package. This avoids accidental inclusion of asset directories or documentation folders in the compilation graph.3
4.3 Module-Level State and Initialization
Aria supports module-level constants and static variables.


Code snippet




mod config {
   pub const:MAX_RETRIES = 5;
   wild static int:counter = 0;
}

Initialization Order:
The initialization of module-level state follows the dependency graph (bottom-up). If Module A imports Module B, B's constants and statics are initialized before A's. The acyclic requirement ensures this order is strictly deterministic.
________________
5. Encapsulation and Visibility: The pub System
Visibility control is the firewall of the codebase. Aria uses a Private-by-Default model to enforce strong encapsulation.1
5.1 Visibility Levels
The SymbolTable in the compiler 1 tracks visibility attributes for every identifier.
Modifier
	Syntax
	Semantics
	Private
	(none)
	Visible only within the defining module and its submodules. This is the default.
	Public
	pub
	Visible to any module that imports the defining module.
	Package
	pub(package)
	Visible to any module within the same compilation unit (crate/binary), but not exported to external consumers.
	Super
	pub(super)
	Visible to the parent module. Useful for sharing implementation details between sibling modules nested under a common parent.
	5.2 The pub use Re-export Pattern
Aria supports the "Façade Pattern" natively via pub use. This allows library authors to present a clean, flat public API while maintaining a complex, nested internal structure.
Example:
* Internal Structure: std.internal.collections.hashmap
* Public Interface: std.collections.HashMap
Implementation:


Code snippet




// std/collections/mod.aria
use../internal/collections/hashmap.aria;
pub use internal.collections.hashmap.HashMap;

When a user writes use std.collections.HashMap, the compiler resolves the symbol through the re-export chain. This decouples the internal refactoring of the library from the user-facing API, a critical feature for long-term library maintenance.5
5.3 Visibility Enforcement Logic
The Semantic Analyzer enforces visibility rules during the symbol resolution pass.
Algorithm:
1. Access: Expression module.item is encountered in current_scope.
2. Lookup: The symbol item is retrieved from module's symbol table.
3. Check:
   * If item.visibility == PUB, Access Granted.
   * If item.visibility == PRIVATE:
      * If module == current_module, Access Granted.
      * Else, Access Denied. Error E002.
   * If item.visibility == PUB(PACKAGE):
      * If module.package_id == current_module.package_id, Access Granted.
      * Else, Access Denied. Error E002.
________________
6. Foreign Function Interface (FFI): The extern Keyword
Aria is designed to integrate seamlessly with the existing world of C software. The extern keyword defines the boundary between Aria's safe, managed environment and the unsafe, raw world of external libraries.
6.1 extern Block Syntax
The extern block declares function signatures and types that exist outside the Aria runtime.


Code snippet




extern "libc" {
   // Basic function mapping
   func:malloc = void*(uint64:size);
   func:free = void(void*:ptr);
   
   // Variadic function mapping
   func:printf = int(string:format,...);
   
   // Global variable mapping
   wild int:errno;
}

* Linkage Name: The string literal "libc" instructs the linker to bind these symbols against the standard C library.
* Safety: All items declared inside an extern block are implicitly unsafe. Calling them requires specific safety overrides or "trust blocks" (though Aria favors explicit safe wrappers).
6.2 Type Mapping Strategy
The most dangerous part of FFI is type mismatch. Aria defines a strict mapping between its types and C types.15
Type Mapping Table:
Category
	Aria Type
	C Equivalent (ABI)
	Caveats & Marshalling Requirements
	Integers
	int8..int64
	int8_t..int64_t
	Direct binary compatibility.
	Floats
	flt32, flt64
	float, double
	IEEE 754 standard. Direct mapping.
	Pointers
	void*, @type
	void*, type*
	Aria references (@) map to C pointers.
	Strings
	string
	struct { char* ptr; size_t len; }
	Mismatch: C expects null-terminated char*. Aria strings are length-prefixed fat pointers. Automatic Marshalling: Passing an Aria string to a char* argument triggers a temporary allocation and null-termination copy.
	TBB Types
	tbb8
	int8_t
	Hazard: Aria uses -128 as ERR. C uses -128 as a valid number. Rule: TBB types generally must be unwrapped/checked before passing to C.
	Structs
	struct
	struct
	Only compatible if the Aria struct is marked #[repr(C)] to disable field reordering.
	6.3 The "WildX" Security Hazard
Research into Escape Analysis 1 identified a critical security risk involving "WildX" pointers (pointers to executable memory, e.g., JIT buffers).
Rule: The module system forbids exporting wildx pointers via extern or pub functions without an explicit unsafe marker.
Rationale: Passing executable memory handles to external C code creates a high-probability vector for code injection attacks if the C code has buffer overflows. The compiler emits a security error if this flow is detected.1
6.4 Calling Conventions
Aria defaults to the standard C calling convention (cdecl on x86, AAPCS on ARM). However, interacting with Windows APIs often requires specific conventions.


Code snippet




extern "kernel32" {
   #[call_conv("stdcall")]
   func:Sleep = void(uint32:dwMilliseconds);
}

Supported conventions: C, stdcall, fastcall, system.
________________
7. Symbol Resolution and Semantic Analysis
The module system is the foundation for symbol resolution—the process of linking identifiers (e.g., x) to their declarations (e.g., var x: int).
7.1 The Symbol Table Architecture
Aria employs a hierarchical SymbolTable implementation.1
* Structure: Each module has its own SymbolTable.
* Parenting: A submodule's table has a pointer to its parent module's table.
* Scope Levels:
   * Level 0: Global/Universe scope (built-ins like int, print).
   * Level 1: Module scope (top-level functions, structs).
   * Level 2+: Local scopes (function bodies, blocks).
7.2 The Two-Pass Compilation Model
To support out-of-order definitions (defining function A before function B, even if A calls B), Aria uses a two-pass compilation model within modules.
1. Pass 1: Interface Discovery. The compiler scans all files in the module graph. It parses declarations (func, struct, const, use) but skips function bodies. This builds the skeletal SymbolTable for every module, establishing what symbols exist and their types.
2. Pass 2: Semantic Analysis & Body Compilation. The compiler revisits function bodies. Since all public interfaces are now known, it can resolve calls to functions defined later in the file or in other modules without forward declarations.17
7.3 Generic Monomorphization Across Modules
Aria generics (func<T>) pose a challenge for separate compilation.
Strategy:
* When a generic is defined in Module A, it is not compiled to machine code. Its AST is serialized into the module's metadata.
* When Module B imports A and calls A.func<int>, the compiler deserializes the AST from A and instantiates it with T=int within the context of B.
* This "Template Instantiation" model ensures zero runtime cost but requires the module system to expose source-level information (ASTs) in its compiled artifacts (.lib or .mod files).
________________
8. Build System and Package Management
Aria's module system is inextricably linked to its build system. There is no separate make step; the module definitions are the build instructions.
8.1 The Package Manifest: aria.toml
The unit of distribution in Aria is the Package (analogous to a Rust Crate). A package is defined by an aria.toml file at its root.1
Manifest Schema:


Ini, TOML




[package]
name = "hyperion_server"
version = "1.2.0"
authors =
edition = "2025"

[dependencies]
# Dependencies from the central registry
std = { version = "1.0" }
json = { version = "2.3", features = ["async"] }

# Dependencies from git
crypto = { git = "https://github.com/aria-lang/crypto", branch = "dev" }

# Local dependencies (workspace pattern)
shared_utils = { path = "../shared/utils" }

[build]
# Compilation flags
optimize = true
output_dir = "./bin"

8.2 Dependency Graph and Incremental Compilation
The build system constructs a dependency graph from the aria.toml and the use statements.
Algorithm:
1. Read aria.toml to identify root dependencies.
2. Recursively parse lib.aria / main.aria to find mod and use statements.
3. Construct the DAG nodes (Modules) and edges (Dependencies).
4. Hash Generation: For each module, compute a hash of its input source + configuration.
5. Cache Check: Compare current hash against the stored hash in target/incremental/.
   * Match: Skip compilation. Use cached artifact.
   * Mismatch: Recompile module.
6. Interface Hashing: Even if a module's body changes, if its public interface hash remains unchanged, dependent modules do not need to be re-type-checked, only re-linked. This "Deep Incrementalism" significantly speeds up development loops.4
8.3 Conditional Compilation (cfg)
The cfg attribute allows modules to adapt to different build targets (OS, Architecture) without runtime checks.


Code snippet




use cfg(target_os = "linux") std.os.linux;
use cfg(target_os = "windows") std.os.windows;

Mechanism:
The cfg predicates are evaluated during the parsing phase. If a predicate is false, the associated use or mod statement is essentially erased from the AST. This means Windows-specific symbols never enter the SymbolTable on Linux builds, preventing type errors regarding missing platform APIs.
________________
9. Comparative Analysis
To justify the architectural decisions, we compare Aria's system against major alternatives.
Feature
	Aria
	Rust
	C++ (Headers)
	Python
	Import Mechanism
	use (Static Binding)
	use (Static Binding)
	#include (Text Copy)
	import (Runtime Exec)
	File Structure
	mod.aria or direct file
	mod.rs (Legacy) or file
	Header + Source
	__init__.py
	Visibility
	Private by default
	Private by default
	Public by default (struct)
	Public by convention (_)
	Compilation Unit
	Module
	Crate
	Translation Unit
	Module (File)
	Circular Deps
	Banned (Compiler Error)
	Allowed within Crate
	Allowed (Forward Decls)
	Allowed (Runtime Error)
	FFI Integration
	First-class (extern)
	extern "C" blocks
	Native
	ctypes (Runtime)
	Key Insights:
* Vs. C++: Aria eliminates header files, solving the "ODR" (One Definition Rule) violations and massive compile-time overheads.19
* Vs. Rust: Aria adopts a simplified file mapping. Rust's dual system (inline mod vs mod.rs) has confused beginners.12 Aria's approach is stricter but more predictable.
* Vs. Python: Python imports are executable statements, leading to runtime circular dependency crashes.20 Aria resolves this at compile-time, guaranteeing that if it compiles, the dependency graph is valid.
________________
10. Error Handling and Diagnostics
A robust module system must provide actionable error messages.
10.1 Error Templates
* E001 (Module Not Found):"Could not resolve module std.network. Searched in: ./src, /usr/lib/aria. Did you forget to add it to aria.toml?"
* E002 (Visibility Violation):"Symbol internal_helper is private in module crypto. It cannot be accessed from main. Consider marking it pub in crypto.aria."
* E003 (Circular Dependency):"Circular dependency detected: Module A imports B, which imports A. Refactor shared logic into a new Module C."
* E004 (FFI Safety):"Unsafe TBB Type: tbb8 passed to extern function c_calc. TBB Error semantics (0x80) are incompatible with C. Wrap this call to sanitize inputs."
________________
11. Code Examples
11.1 Complex Hierarchy Example
File: src/engine/mod.aria


Code snippet




pub mod graphics; // exports src/engine/graphics.aria
pub mod physics;  // exports src/engine/physics.aria
mod internal;     // private, src/engine/internal.aria

use graphics.Renderer;

pub struct GameEngine {
   renderer: Renderer,
   // physics is public, so its types can be exposed
   world: physics.World, 
}

File: src/main.aria


Code snippet




use engine.GameEngine;
// use engine.internal; // ERROR: Private module

func main() {
   // GameEngine is public
   wild GameEngine:e = aria.alloc(GameEngine); 
}

This demonstrates how mod controls the structure and pub controls the interface, allowing engine to expose a clean API (GameEngine) while hiding complexity (internal).
________________
12. Conclusion
The specification provided in this report establishes a module system for Aria that is rigorous, safe, and performant. By enforcing a private-by-default visibility model, it promotes long-term maintainability. By integrating incremental compilation deep into the resolution logic, it ensures rapid developer feedback. And by treating FFI and Conditional Compilation as core features, it acknowledges the reality of modern systems programming—that no language is an island. This architecture is ready for immediate implementation by the compiler team.
________________
Works Cited:
.1
Works cited
1. aria_source_part5b_borrow_traits.txt
2. C++ Modules vs Header Files: What Developers Need to Know, accessed December 13, 2025, https://alexander-ostrovskiy-c.co.uk/posts/c-modules-vs-header-files/
3. The initialization of the sys.path module search path — Python 3.14.2 documentation, accessed December 13, 2025, https://docs.python.org/3/library/sys_path_init.html
4. Incremental compilation in detail - Rust Compiler Development Guide, accessed December 13, 2025, https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation-in-detail.html
5. Modules - The Rust Reference, accessed December 13, 2025, https://doc.rust-lang.org/reference/items/modules.html
6. Zig Build System - Zig Programming Language, accessed December 13, 2025, https://ziglang.org/learn/build-system/
7. Compare header units, modules, and precompiled headers | Microsoft Learn, accessed December 13, 2025, https://learn.microsoft.com/en-us/cpp/build/compare-inclusion-methods?view=msvc-170
8. C++ vs Rust project organization and tooling - Reddit, accessed December 13, 2025, https://www.reddit.com/r/rust/comments/150c3vm/c_vs_rust_project_organization_and_tooling/
9. Symbol Resolution (Linker and Libraries Guide), accessed December 13, 2025, https://docs.oracle.com/cd/E19957-01/806-0641/chapter2-93321/index.html
10. rust modules resolution from main.rs - Stack Overflow, accessed December 13, 2025, https://stackoverflow.com/questions/65735609/rust-modules-resolution-from-main-rs
11. Show HN: The Aria Programming Language - Hacker News, accessed December 13, 2025, https://news.ycombinator.com/item?id=44698513
12. Need help understanding rust's module system : r/learnrust - Reddit, accessed December 13, 2025, https://www.reddit.com/r/learnrust/comments/n4h78c/need_help_understanding_rusts_module_system/
13. Circular dependency - Wikipedia, accessed December 13, 2025, https://en.wikipedia.org/wiki/Circular_dependency
14. How to handle circular dependency in module import? - Stack Overflow, accessed December 13, 2025, https://stackoverflow.com/questions/48818485/how-to-handle-circular-dependency-in-module-import
15. Quin-Darcy/rust-c-ffi-guide: An introductory guide to calling C functions from Rust using FFI bindings, with practical examples demonstrating how to do it safely and idiomatically. - GitHub, accessed December 13, 2025, https://github.com/Quin-Darcy/rust-c-ffi-guide
16. C Language Mapping Specification - Object Management Group (OMG), accessed December 13, 2025, https://www.omg.org/spec/C/1.0/PDF
17. What a compiler does: symbol resolution - Musing Mortoray, accessed December 13, 2025, https://mortoray.com/what-a-compiler-does-symbol-resolution/
18. So you want to write a package manager | by sam boyer - Medium, accessed December 13, 2025, https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527
19. Should I still use precompiled header file in my C++ 20 module based code if I use non-module headers like windows.h? - Stack Overflow, accessed December 13, 2025, https://stackoverflow.com/questions/78942635/should-i-still-use-precompiled-header-file-in-my-c-20-module-based-code-if-i-u
20. So you got a circular import in Python. | by Hadrien Hamana - Medium, accessed December 13, 2025, https://medium.com/@hamana.hadrien/so-you-got-a-circular-import-in-python-e9142fe10591
21. Modules (since C++20) - cppreference.com - C++ Reference, accessed December 13, 2025, https://en.cppreference.com/w/cpp/language/modules.html
22. Modules - Rust By Example - Rust Documentation, accessed December 13, 2025, https://doc.rust-lang.org/rust-by-example/mod.html
23. Import resolution - basedpyright, accessed December 13, 2025, https://docs.basedpyright.com/v1.18.4/usage/import-resolution/
24. python paths and import order - Stack Overflow, accessed December 13, 2025, https://stackoverflow.com/questions/9586630/python-paths-and-import-order
25. Dependency graph - Wikipedia, accessed December 13, 2025, https://en.wikipedia.org/wiki/Dependency_graph
26. C interop using dart:ffi, accessed December 13, 2025, https://dart.dev/interop/c-interop
27. Creating FFI between C and my language - Stack Overflow, accessed December 13, 2025, https://stackoverflow.com/questions/29449809/creating-ffi-between-c-and-my-language
28. Complex data types and the Rust FFI | Kyle M. Douglass, accessed December 13, 2025, http://kmdouglass.github.io/posts/complex-data-types-and-the-rust-ffi/
29. How to Detect Circular Dependency in Java Modules - C# Corner, accessed December 13, 2025, https://www.c-sharpcorner.com/article/how-to-detect-circular-dependency-in-java-modules/