# RESEARCH TASK: Functional Types (result, func, array)

**Task ID:** research_016_functional_types
**Priority:** HIGH
**Category:** Type System
**Status:** PENDING
**Created:** 2025-12-11
**Estimated Complexity:** High

---

## PROBLEM STATEMENT

Design specification for Aria's functional programming types: result (error handling), func (functions/closures), and array (dynamic collections).

---

## SCOPE

- **Result Type**: result<T, E> for error handling with {err, val} struct
- **Func Type**: Function pointers, closures, and async functions
- **Array Type**: Fixed-size array<T, N> and dynamic T[] arrays

---

## DEPENDENCIES

- research_001_borrow_checker
- research_010_macro_comptime

---

## KEY QUESTIONS


**Result:**
- What is the exact {err, val} struct layout?
- What monadic operations are built-in (map, flatMap, and_then)?
- How does the ? operator work (unwrap with default)?
- How do TBB ERR sentinels propagate through result?
- How does pattern matching work in pick statements?
- What is the memory model (how are errors stored)?

**Func:**
- What are the closure capture semantics (by-value, by-reference, wild)?
- How are function signatures represented in the type system?
- What calling convention (C ABI vs Aria native)?
- How are async functions represented (Future/Promise)?
- How do functions work in comptime (functions as first-class values)?
- What is the memory model for closures (GC heap for captures)?

**Array:**
- How do fixed-size (stack) vs dynamic (heap) arrays differ?
- Is bounds checking always on, debug-only, or never?
- What is the slicing syntax (arr[2..5], arr[...10])?
- What is the memory model (GC vs wild arrays)?
- Are multi-dimensional arrays supported (arr[10][20] vs tensor)?
- What SIMD integration exists (vectorized operations)?

---

## DELIVERABLES

1. result type specification (200-250 lines)
2. func type specification (250-300 lines)
3. array type specification (200-250 lines)
4. Monadic operation semantics
5. Closure capture strategy
6. Bounds checking implementation
7. Memory layout diagrams

---

## CONTEXT FILES

- /docs/info/aria_specs.txt (result type, func syntax, array usage)
- /docs/gemini/responses/research_001_borrow_checker.txt (closure captures)
- /docs/gemini/responses/research_007_threading_library.txt (async functions)

---

## INSTRUCTIONS FOR GEMINI

**Your Task:**
Provide a comprehensive specification document covering all key questions and deliverables listed above.

**Format:**
- Clear section headings
- Code examples where appropriate
- Design rationale explanations
- Platform-specific considerations (Linux, Windows, macOS)
- Integration notes with existing research
- Performance implications
- Security/safety considerations

**Style:**
- Technical and precise
- Include pseudo-code or actual Aria syntax examples
- Reference relevant research papers or existing implementations
- Provide comparison with similar features in other languages

**Length:** Aim for {task.get('target_length', '500-800')} lines of detailed technical content.

---

## SUCCESS CRITERIA

Research complete when we have:
1. Complete specification covering all key questions
2. Design decisions documented with rationale
3. Integration strategy with existing compiler components
4. Code examples demonstrating usage
5. Implementation roadmap or guidance

---

**PRIORITY:** {task['priority'].upper()} - {task.get('description', '')[:100]}...
