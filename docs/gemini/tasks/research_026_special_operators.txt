# RESEARCH TASK: Special Operators (@, #, $, ?, ?., ??, |>, <|, .., &{ })

**Task ID:** research_026_special_operators
**Priority:** MEDIUM
**Category:** Operators
**Status:** PENDING
**Created:** 2025-12-11
**Estimated Complexity:** High

---

## PROBLEM STATEMENT

Complete specification for Aria's unique special-purpose operators: memory operators (@, #, $), error handling (?, ?., ??), pipeline (|>, <|), range (..), and closures (&{ }).

---

## SCOPE

- **Memory Operators**: @ (wild ptr), # (ptr arithmetic), $ (wildx ptr)
- **Error Handling**: ? (propagate), ?. (safe navigation), ?? (null coalescing)
- **Pipeline**: |> (forward pipe), <| (reverse pipe)
- **Range**: .. (range creation)
- **Closure**: &{ } (anonymous function syntax)

---

## DEPENDENCIES

- research_022_wild_wildx_memory
- research_016_functional_types

---

## KEY QUESTIONS


**Memory Operators:**
- What is @ operator precedence and associativity?
- How does # pointer arithmetic work (# + offset)?
- What is $ wildx pointer calling syntax?
- How do these interact with borrow checker?
- What safety checks exist?

**Error Handling:**
- What is ? operator desugaring (early return on ERR)?
- How does ?. safe navigation work (obj?.field)?
- What is ?? null coalescing semantics (val ?? default)?
- How do these compose (??.?)?
- What short-circuit behavior exists?
- How does ? integrate with result type?

**Pipeline:**
- What is |> forward pipe desugaring (x |> f → f(x))?
- What is <| reverse pipe desugaring (f <| x → f(x))?
- How do pipelines chain (x |> f |> g |> h)?
- What operator precedence (|> vs +)?
- How does pipeline work with methods (x |> .method())?
- What optimization exists (inline entire chain)?

**Range Operator:**
- What is .. semantics (inclusive vs exclusive)?
- What types support ranges (int, char)?
- How do ranges work in loops (for i in 0..10)?
- What range types exist (Range, RangeInclusive)?
- How are infinite ranges represented (0..)?
- What step control exists (0..10:2 for even numbers)?

**Closure Syntax:**
- What is &{ } closure syntax (&{|x| x + 1})?
- How are captures specified (by-value, by-ref)?
- What closure type inference exists?
- How do closures integrate with func type?
- What optimization exists (inline, devirtualize)?

---

## DELIVERABLES

1. Memory operator specification (200-250 lines)
2. Error handling operator specification (250-300 lines)
3. Pipeline operator specification (150-200 lines)
4. Range operator specification (150-200 lines)
5. Closure syntax specification (200-250 lines)
6. Operator precedence integration
7. Code examples for all operators
8. Performance analysis and optimization

---

## CONTEXT FILES

- /docs/info/aria_specs.txt (special operator examples)
- /docs/gemini/responses/research_022_wild_wildx_memory.txt (@ # $ operators)
- /docs/gemini/responses/research_016_functional_types.txt (closure captures)
- /src/frontend/parser.cpp (operator parsing)

---

## INSTRUCTIONS FOR GEMINI

**Your Task:**
Provide a comprehensive specification document covering all key questions and deliverables listed above.

**Format:**
- Clear section headings
- Code examples where appropriate
- Design rationale explanations
- Platform-specific considerations (Linux, Windows, macOS)
- Integration notes with existing research
- Performance implications
- Security/safety considerations

**Style:**
- Technical and precise
- Include pseudo-code or actual Aria syntax examples
- Reference relevant research papers or existing implementations
- Provide comparison with similar features in other languages

**Length:** Aim for {task.get('target_length', '500-800')} lines of detailed technical content.

---

## SUCCESS CRITERIA

Research complete when we have:
1. Complete specification covering all key questions
2. Design decisions documented with rationale
3. Integration strategy with existing compiler components
4. Code examples demonstrating usage
5. Implementation roadmap or guidance

---

**PRIORITY:** {task['priority'].upper()} - {task.get('description', '')[:100]}...
