/* TEST OF SYNTAX FROM ORIGINAL SPECS */
// !!! DO NOT MODIFY EXCEPT TO COMMENT/UNCOMMENT SECTIONS OR FILL IN STUBS, SYNTAX IS NOT NEGOTIABLE 


int8:i = 9;
string:str = "whats up";
int8:c = 0;
int8[]arr; //empty array, cannot use without initializing properly
int8[256]arr2; //empty int8 array with 256 elements
int8[]:arr3=[100,300,550]; //3 element int8 array with values

//standard while loop
while(i < 100){
    print(`&{i}`);
    i++;
}

when(c <= i){
    print(`&{c}`);
    c++;
}then{
    print(`when loop ran c times`);
}end{
    print(`when loop did not run`);
}

//normal for for familiarity and ease transitioing to till or more advanced uses
for(int:i = 0; i < 100; i ++){
    print(`&{i}`); 
}

//automatically tracks iteration via $ variable
till(100,1){
    //print(`iteration: &{$}`)
    //should count up from 0 to 100 by 1
}
till(100,-1){
    //print(`iteration: &{$}`)
    //should count down from 100 to 0 by 1
}

//*matches any condition, ! means unreachable by match, labels optional but required for explicit fallthrough via fall(label), sorry, they dont get a normal switch this time. i was nice with the while lol. 
pick(c){
    (<9){
        fall(fail);
    },
    (>9){
        fall(fail);
    },
    (9){
        fall(success);
    },
    (*){
        fall(err);
    },
    fail:(!){
        //do fail stuff here
        fall(done);
    },
    success:(!){
        //do success stuff here
        fall(done);
    },
    err(!){
        //do error stuff here
        fall(done);
    },
    done:(!){
        //cleanup or whatever
    }
}

result:r;
int8:t;
int8:closureTest = 2;
func:test = int8(int8:a,int8:b){
    return {
        err:NULL,
        val:a*b*closureTest; //if this isn't int8 as specified above, compile should fail
    }
};
r=test(3,4);
t = is r.err == NULL : r.val : -1; //t should be 24 if closure worked
func:test2 = int8(func:tt,int8:a,int8:b){
    return tt(a,b);//should return { err:NULL,val:24} with input of 3,4
};
r=test2(3,4);
t = is r.err == NULL :r.val : -1; //t should be 24 if closure worked
t = test2(3,5) ? -1; //use unwrap operator to abvoid above

dyn:d = "bob";
d = 4; 
d = true;
d= -2;

wild int64:s=100000;
wild int64@:t = @s; //@ address or pointer operator
wild int8:u = #d; //# memory pinning operator

obj:config = {
    version:"0.0.5",
    name:"Aria",
    highTime:420
}

//lambda with optional immediate execution

func:returnFunc func(){
    return {
        err: NULL,
        val: int8(int8:a,int8:b){ return { err:NULL, val: a*b } }
    }
}

result:res = int8(int8:a,int8:b){ return { err:NULL, val: a*b } }(10,2);
