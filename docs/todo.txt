ARIA COMPILER - COMPLETE IMPLEMENTATION ROADMAP
================================================
Created: December 14, 2025
Version: v0.1.0 - Fresh Start from Archived v0.0.17
Status: Ready for systematic, research-driven implementation

███████████████████████████████████████████████████████████████████████
██ ARCHIVE COMPLETE ✅                                                ██
███████████████████████████████████████████████████████████████████████

v0.0.17 archived to: archive/v0.0.17_20251214_215757/
- All previous source code preserved
- Modular architecture achieved but starting fresh
- Research-driven approach from ground up

███████████████████████████████████████████████████████████████████████
██ RESEARCH FOUNDATION (100% COMPLETE) ✅                             ██
███████████████████████████████████████████████████████████████████████

All 31 research documents completed in: docs/gemini/responses/

research_001 - Borrow Checker - Complete lifetime analysis algorithm
research_002 - Balanced Ternary - TBB arithmetic (tbb8, tbb16, tbb32, tbb64)
research_003 - Balanced Nonary - Nit/nyte arithmetic
research_004 - File I/O Library - Complete file operations
research_005 - Process Management - spawn, fork, exec, pipes
research_006 - Modern Streams - Six-channel I/O system
research_007 - Threading Library - Thread creation and synchronization
research_008 - Atomics Library - Atomic operations
research_009 - Timer/Clock Library - Time and timing functions
research_010-011 - Macro/CompTime - Macro system & compile-time evaluation
research_012 - Standard Integers - int1-512, uint8-512 specifications
research_013 - Floating Point - flt32-512 specifications
research_014 - Composite Part 1 - Arrays, pointers, strings
research_015 - Composite Part 2 - Structs, enums, unions
research_016 - Functional Types - func, result, lambdas, closures
research_017 - Mathematical Types - matrix, tensor, vec9
research_018 - Looping Constructs - while, for, loop, till, when
research_019 - Conditionals - if, pick, pattern matching
research_020 - Control Transfer - break, continue, defer, result monad
research_021 - GC System - Complete garbage collector specification
research_022 - Wild/WildX - Manual and executable memory management
research_023 - Runtime Assembler - JIT compilation for wildx
research_024 - Arithmetic/Bitwise - All arithmetic operators
research_025 - Comparison/Logical - All comparison operators
research_026 - Special Operators - @, $, #, |>, <|, ?., ??, .., etc.
research_027 - Generics - Templates and monomorphization
research_028 - Module System - use, mod, pub, extern
research_029 - Async/Await - Async runtime and futures
research_030 - Const/CompTime - Compile-time evaluation
research_031 - Essential Stdlib - Standard library bootstrap

███████████████████████████████████████████████████████████████████████
██ IMPLEMENTATION PHILOSOPHY                                          ██
███████████████████████████████████████████████████████████████████████

**MODULAR FROM DAY ONE:**
- NO monolithic files (maximum 1000 lines per file)
- One clear responsibility per module
- Clean interfaces between components
- Each module independently testable

**DEVELOPMENT WORKFLOW:**
- All work on `development` branch
- Commit frequently with clear, descriptive messages
- Run tests before each commit
- Only merge to `main` when section is VERIFIED and ALL TESTS PASS
- NEVER lose working code

**RESEARCH-DRIVEN DEVELOPMENT:**
- Each task references specific research document(s): [research_NNN]
- Complete specifications already exist - no guessing
- Implement exactly as specified in research
- Validate against research document requirements

**TESTING DISCIPLINE:**
- Write unit tests for each module
- Write integration tests for each phase
- Test before moving to next component
- Keep test coverage high
- Performance benchmarks for critical paths

███████████████████████████████████████████████████████████████████████
██ PHASE 0: PROJECT FOUNDATION & BUILD INFRASTRUCTURE                 ██
███████████████████████████████████████████████████████████████████████

Goal: Clean slate with proper build system and directory structure.

═══════════════════════════════════════════════════════════════════════
0.0: Repository Cleanup
═══════════════════════════════════════════════════════════════════════

[ ] 0.0.1: Remove build artifacts from root
    Location: ./
    Action: Remove all .o files from repository root
    Command: find . -maxdepth 1 -name "*.o" -delete
    Reason: Keep root clean before starting fresh implementation
    Files to remove: test_*.o (17 files)
    Test: ls *.o returns "No such file or directory"
    
[ ] 0.0.2: Verify archive is complete
    Location: archive/v0.0.17_20251214_215757/
    Action: Verify all old source code is safely archived
    Test: Directory exists and contains previous implementation
    
[ ] 0.0.3: Verify .gitignore is current
    File: .gitignore
    Action: Ensure *.o files are ignored
    Test: git check-ignore test.o returns positive result

═══════════════════════════════════════════════════════════════════════
0.1: Build System Setup
═══════════════════════════════════════════════════════════════════════

[ ] 0.1.1: Clean CMakeLists.txt
    Location: ./CMakeLists.txt
    Action: Remove all old source file references
    - Remove references to archived source files
    - Keep LLVM configuration (LLVM 20.1.2)
    - Set C++17 standard minimum
    - Configure proper warning flags (-Wall -Wextra)
    Test: CMake configures without errors
    
[ ] 0.1.2: Create directory structure
    Action: Create all necessary directories
    mkdir -p src/frontend/lexer
    mkdir -p src/frontend/parser
    mkdir -p src/frontend/ast
    mkdir -p src/frontend/sema
    mkdir -p src/frontend/module
    mkdir -p src/backend/ir
    mkdir -p src/backend/codegen
    mkdir -p src/runtime/gc
    mkdir -p src/runtime/allocators
    mkdir -p src/runtime/io
    mkdir -p src/runtime/process
    mkdir -p include/frontend
    mkdir -p include/backend
    mkdir -p include/runtime
    mkdir -p tests/unit
    mkdir -p tests/integration
    mkdir -p tests/benchmarks
    Test: All directories exist
    
[ ] 0.1.3: Create build scripts
    File: build.sh
    - Clean build script (rm -rf build && mkdir build && cd build && cmake .. && make)
    - Colorized output
    - Error checking
    Make executable: chmod +x build.sh
    
    File: test.sh
    - Run all unit tests
    - Run all integration tests
    - Report pass/fail summary
    Make executable: chmod +x test.sh
    
    File: clean.sh
    - Remove build artifacts
    - Keep source intact
    Make executable: chmod +x clean.sh
    
    Test: Each script runs without error
    
[ ] 0.1.4: Create .gitignore
    Action: Update .gitignore for clean repo
    Ignore: build/, *.o, *.so, *.a, *.ll, *.bc, core, a.out
    Keep: src/, include/, tests/, docs/, lib/
    Test: git status shows only tracked files

═══════════════════════════════════════════════════════════════════════
0.2: Testing Infrastructure
═══════════════════════════════════════════════════════════════════════

[ ] 0.2.1: Choose unit test framework
    Decision: Use simple assert-based tests or integrate Catch2/Google Test
    Recommendation: Start with assert-based, upgrade later if needed
    
[ ] 0.2.2: Create test runner
    File: tests/test_runner.cpp
    - Discovers and runs all test files
    - Reports results
    - Returns non-zero exit code on failure
    
[ ] 0.2.3: Create test helpers
    File: tests/test_helpers.h
    - Assertion macros
    - Test setup/teardown utilities
    - Common test data
    
[ ] 0.2.4: Integration test harness
    File: tests/integration/runner.sh
    - Compiles .aria files
    - Runs compiled executables
    - Checks output against expected
    - Reports pass/fail
    Make executable
    
[ ] 0.2.5: Add tests to CMakeLists.txt
    - Add test targets
    - Link with testing framework
    - Enable CTest integration
    Test: ctest runs (even if no tests yet)
    
[ ] 0.2.6: Setup memory leak detection
    File: tests/test_helpers.h
    Action: Configure AddressSanitizer (ASAN) and Valgrind support
    Add to CMakeLists.txt: -fsanitize=address for debug builds
    Purpose: Catch memory leaks during development
    Test: Build with ASAN, run simple test
    
[ ] 0.2.7: Setup code coverage
    File: CMakeLists.txt
    Action: Add --coverage flag for GCC/Clang
    Create: tools/coverage.sh script to generate coverage reports
    Purpose: Track test coverage
    Test: Run coverage script, generates report
    
[ ] 0.2.8: Setup fuzzing infrastructure (optional, future)
    File: tests/fuzz/README.md
    Document: How to add fuzz tests later
    Note: Will use with libFuzzer or AFL++ in Phase 1-2 testing

═══════════════════════════════════════════════════════════════════════
0.3: Example Files (Test Cases)
═══════════════════════════════════════════════════════════════════════

[ ] 0.3.1: Create examples directory structure
    mkdir -p examples/basic
    mkdir -p examples/advanced
    mkdir -p examples/stdlib
    mkdir -p examples/features
    Test: Directories exist
    
[ ] 0.3.2: examples/basic/01_hello_world.aria
    Content: Basic print statement
    ```aria
    print("Hello, World!");
    ```
    
[ ] 0.3.3: examples/basic/02_variables.aria
    Content: All type declarations
    ```aria
    int8:x = 42;
    string:name = "Aria";
    bool:flag = true;
    flt32:pi = 3.14;
    tbb8:safe = 100;
    ```
    
[ ] 0.3.4: examples/basic/03_functions.aria
    Content: Function definitions, calls
    ```aria
    func:add = int8(int8:a, int8:b) {
        return a + b;
    };
    int8:result = add(3, 4) ? 0;
    ```
    
[ ] 0.3.5: examples/basic/04_control_flow.aria
    Content: if, while, for, loop, till, when, pick
    Reference all control flow constructs [research_018, research_019]
    
[ ] 0.3.6: examples/basic/05_memory.aria
    Content: gc (default), wild, stack allocations
    ```aria
    int8:gc_var = 100;  // GC managed (default)
    wild int8:wild_var = 200;  // Manual memory
    stack int8[100]:buffer;  // Stack allocated
    ```
    
[ ] 0.3.7: examples/features/06_modules.aria
    Content: use statements, mod definitions, pub, extern
    Reference: [research_028]
    
[ ] 0.3.8: examples/features/07_generics.aria
    Content: Generic functions, type inference
    Reference: [research_027]
    
[ ] 0.3.9: examples/features/08_async.aria
    Content: async functions, await
    Reference: [research_029]
    
[ ] 0.3.10: examples/features/09_tbb_arithmetic.aria
    Content: TBB types, ERR handling, sticky error propagation
    Reference: [research_002]
    
[ ] 0.3.11: examples/advanced/10_complete_app.aria
    Content: Full application with:
    - File I/O [research_004]
    - Process management [research_005]
    - Modern streams [research_006]
    - Error handling
    - Multiple functions
    - Module system
    Purpose: Integration test for complete compiler

COMMIT CHECKPOINT: Phase 0 - Build infrastructure ready
Tag: v0.1.0-phase0-complete
Merge to main: YES (infrastructure is foundation)

███████████████████████████████████████████████████████████████████████
██ PHASE 1: LEXER - TOKENIZATION FOUNDATION                           ██
███████████████████████████████████████████████████████████████████████

Goal: Convert source text into stream of tokens.
Reference: [research_012] for type tokens, aria_specs.txt for all tokens

═══════════════════════════════════════════════════════════════════════
1.1: Token Definitions (Must be complete before lexer implementation)
═══════════════════════════════════════════════════════════════════════

[ ] 1.1.1: Create token type enum
    File: include/frontend/token.h
    Content: Complete TokenType enum with ALL tokens
    Categories:
    - Keywords (75+ tokens)
    - Operators (50+ tokens)
    - Literals (7 types)
    - Punctuation (12+ tokens)
    - Special (EOF, ERROR, etc.)
    
    Keyword tokens to include:
    // Memory qualifiers
    TOKEN_KW_WILD, TOKEN_KW_WILDX, TOKEN_KW_STACK, TOKEN_KW_GC,
    
    // Control flow
    TOKEN_KW_IF, TOKEN_KW_ELSE, TOKEN_KW_WHILE, TOKEN_KW_FOR,
    TOKEN_KW_LOOP, TOKEN_KW_TILL, TOKEN_KW_WHEN, TOKEN_KW_THEN, TOKEN_KW_END,
    TOKEN_KW_PICK, TOKEN_KW_BREAK, TOKEN_KW_CONTINUE, TOKEN_KW_RETURN,
    TOKEN_KW_DEFER, TOKEN_KW_FALL,
    TOKEN_KW_ASYNC, TOKEN_KW_AWAIT, TOKEN_KW_CATCH,
    
    // Declarations
    TOKEN_KW_FUNC, TOKEN_KW_TYPE, TOKEN_KW_STRUCT, TOKEN_KW_USE,
    TOKEN_KW_MOD, TOKEN_KW_PUB, TOKEN_KW_EXTERN, TOKEN_KW_CONST,
    TOKEN_KW_CFG,
    
    // Types - Integers
    TOKEN_KW_INT1, TOKEN_KW_INT2, TOKEN_KW_INT4, TOKEN_KW_INT8,
    TOKEN_KW_INT16, TOKEN_KW_INT32, TOKEN_KW_INT64, TOKEN_KW_INT128,
    TOKEN_KW_INT256, TOKEN_KW_INT512,
    
    // Types - Unsigned Integers
    TOKEN_KW_UINT8, TOKEN_KW_UINT16, TOKEN_KW_UINT32, TOKEN_KW_UINT64,
    TOKEN_KW_UINT128, TOKEN_KW_UINT256, TOKEN_KW_UINT512,
    
    // Types - TBB (Twisted Balanced Binary)
    TOKEN_KW_TBB8, TOKEN_KW_TBB16, TOKEN_KW_TBB32, TOKEN_KW_TBB64,
    
    // Types - Floating Point
    TOKEN_KW_FLT32, TOKEN_KW_FLT64, TOKEN_KW_FLT128, TOKEN_KW_FLT256, TOKEN_KW_FLT512,
    
    // Types - Special
    TOKEN_KW_BOOL, TOKEN_KW_STRING, TOKEN_KW_DYN, TOKEN_KW_OBJ,
    TOKEN_KW_RESULT, TOKEN_KW_VOID,
    
    // Types - Balanced Ternary/Nonary
    TOKEN_KW_TRIT, TOKEN_KW_TRYTE, TOKEN_KW_NIT, TOKEN_KW_NYTE,
    
    // Types - Vectors/Math
    TOKEN_KW_VEC2, TOKEN_KW_VEC3, TOKEN_KW_VEC9,
    TOKEN_KW_MATRIX, TOKEN_KW_TENSOR,
    
    // Types - I/O and System
    TOKEN_KW_BINARY, TOKEN_KW_BUFFER, TOKEN_KW_STREAM,
    TOKEN_KW_PROCESS, TOKEN_KW_PIPE, TOKEN_KW_DEBUG, TOKEN_KW_LOG,
    
    // Special keywords
    TOKEN_KW_IS, TOKEN_KW_NULL,
    
    // Literals
    TOKEN_KW_TRUE, TOKEN_KW_FALSE, TOKEN_KW_ERR,
    
    Operator tokens:
    // Arithmetic
    TOKEN_PLUS, TOKEN_MINUS, TOKEN_STAR, TOKEN_SLASH, TOKEN_PERCENT,
    TOKEN_PLUS_PLUS, TOKEN_MINUS_MINUS,
    
    // Assignment
    TOKEN_EQUAL, TOKEN_PLUS_EQUAL, TOKEN_MINUS_EQUAL,
    TOKEN_STAR_EQUAL, TOKEN_SLASH_EQUAL, TOKEN_PERCENT_EQUAL,
    
    // Comparison
    TOKEN_EQUAL_EQUAL, TOKEN_BANG_EQUAL,
    TOKEN_LESS, TOKEN_LESS_EQUAL,
    TOKEN_GREATER, TOKEN_GREATER_EQUAL,
    TOKEN_SPACESHIP, // <=>
    
    // Logical
    TOKEN_AND_AND, TOKEN_OR_OR, TOKEN_BANG,
    
    // Bitwise
    TOKEN_AMPERSAND, TOKEN_PIPE, TOKEN_CARET, TOKEN_TILDE,
    TOKEN_SHIFT_LEFT, TOKEN_SHIFT_RIGHT,
    
    // Special operators
    TOKEN_AT, TOKEN_DOLLAR, TOKEN_HASH,
    TOKEN_ARROW, TOKEN_SAFE_NAV, TOKEN_NULL_COALESCE,
    TOKEN_QUESTION, TOKEN_PIPE_RIGHT, TOKEN_PIPE_LEFT,
    TOKEN_DOT_DOT, TOKEN_DOT_DOT_DOT,
    
    // Template literal tokens
    TOKEN_BACKTICK_START,    // ` (start of template)
    TOKEN_BACKTICK_END,      // ` (end of template)
    TOKEN_TEMPLATE_TEXT,     // text between interpolations
    TOKEN_INTERP_START,      // &{ (interpolation start)
    TOKEN_INTERP_END,        // } (interpolation end, contextual)
    
    // Punctuation
    TOKEN_DOT, TOKEN_COMMA, TOKEN_COLON, TOKEN_SEMICOLON,
    TOKEN_LEFT_PAREN, TOKEN_RIGHT_PAREN,
    TOKEN_LEFT_BRACE, TOKEN_RIGHT_BRACE,
    TOKEN_LEFT_BRACKET, TOKEN_RIGHT_BRACKET,
    TOKEN_BACKTICK,          // ` (standalone backtick)
    
    // Special tokens
    TOKEN_EOF, TOKEN_ERROR, TOKEN_IDENTIFIER,
    
    Test: Enum compiles, all values unique
    
[ ] 1.1.2: Create Token struct
    File: include/frontend/token.h (same file)
    Content:
    ```cpp
    struct Token {
        TokenType type;
        std::string lexeme;      // Raw text from source
        int line;                // Line number (1-indexed)
        int column;              // Column number (1-indexed)
        
        // Value storage (union for efficiency)
        union {
            int64_t int_value;
            double float_value;
            bool bool_value;
        } value;
        
        std::string string_value; // For strings (separate due to complex type)
        
        // Constructor
        Token(TokenType t, std::string lex, int ln, int col);
        
        // Helpers
        bool isKeyword() const;
        bool isOperator() const;
        bool isLiteral() const;
        std::string toString() const; // For debugging
    };
    ```
    Test: Token creation, field access works
    
[ ] 1.1.3: Implement Token methods
    File: src/frontend/lexer/token.cpp
    Implement: Constructor, isKeyword(), isOperator(), isLiteral(), toString()
    Test: All methods work correctly

═══════════════════════════════════════════════════════════════════════
1.2: Lexer Core Implementation
═══════════════════════════════════════════════════════════════════════
Reference: [research_012], [research_002], [research_003]

[ ] 1.2.1: Create Lexer class definition
    File: include/frontend/lexer/lexer.h
    Content:
    ```cpp
    class Lexer {
    private:
        std::string source;       // Source code
        size_t current;           // Current position
        size_t start;             // Start of current token
        int line;                 // Current line (1-indexed)
        int column;               // Current column (1-indexed)
        
        std::vector<std::string> errors; // Error messages
        
        // Helpers
        char advance();
        char peek() const;
        char peekNext() const;
        bool isAtEnd() const;
        bool match(char expected);
        
        void skipWhitespace();
        void skipLineComment();
        void skipBlockComment();
        
        Token makeToken(TokenType type);
        Token errorToken(const std::string& message);
        
        Token scanNumber();
        Token scanIdentifier();
        Token scanString();
        Token scanTemplateLiteral();
        Token scanOperator();
        
        TokenType identifierType(); // Check if identifier is keyword
        TokenType checkKeyword(int start, int length, const char* rest, TokenType type);
        
    public:
        explicit Lexer(const std::string& src);
        Token nextToken();
        const std::vector<std::string>& getErrors() const;
        bool hasErrors() const;
    };
    ```
    Test: Class compiles
    
[ ] 1.2.2: Implement Lexer constructor and basic helpers
    File: src/frontend/lexer/lexer.cpp
    Implement:
    - Lexer(const std::string& src) - Initialize members
    - advance() - Move to next char, update line/column
    - peek() - Look at current char without consuming
    - peekNext() - Look ahead 2 chars
    - isAtEnd() - Check if at EOF
    - match(char) - Consume if matches
    - makeToken() - Create token with current position
    - errorToken() - Create error token
    
    Test: Can create lexer, advance through string
    
[ ] 1.2.3: Implement whitespace handling
    File: src/frontend/lexer/lexer.cpp
    Implement:
    - skipWhitespace() - Skip spaces, tabs, newlines (track line numbers!)
    - skipLineComment() - Skip // comments
    - skipBlockComment() - Skip /* */ comments (handle nesting!)
    
    Test cases:
    - Mixed whitespace
    - Line comments
    - Block comments
    - Nested block comments
    - Comments at EOF
    
[ ] 1.2.4: Implement number lexing
    File: src/frontend/lexer/lexer.cpp
    Function: Token scanNumber()
    Handle:
    - Decimal: 123, 456
    - Hex: 0xFF, 0xDEADBEEF
    - Binary: 0b1010, 0b11110000
    - Octal: 0o755, 0o644
    - Floats: 3.14, 1.5e10, 0x1.2p3
    - Underscores: 1_000_000, 0xFF_FF
    
    Store value in token.value union
    
    Test cases:
    - All number formats
    - Edge cases (0, -1, MAX_INT)
    - Invalid numbers (error recovery)
    
[ ] 1.2.5: Implement identifier and keyword lexing
    File: src/frontend/lexer/lexer.cpp
    Function: Token scanIdentifier()
    - Lex identifier: [a-zA-Z_][a-zA-Z0-9_]*
    - Call identifierType() to check if keyword
    - Return TOKEN_IDENTIFIER or keyword token
    
    Function: TokenType identifierType()
    - Use trie or hash map for keyword lookup
    - Implement checkKeyword() helper for trie traversal
    
    Test cases:
    - All keywords recognized
    - Identifiers don't match keywords
    - Edge cases (i, x, _var, var123)
    
[ ] 1.2.6: Implement string lexing
    File: src/frontend/lexer/lexer.cpp
    Function: Token scanString()
    - Handle "double quoted" strings
    - Handle 'single quoted' strings
    - Escape sequences: \n, \t, \r, \\, \", \'
    - Unicode escapes: \u{1F600}
    - Detect unterminated strings (error)
    - Store content in token.string_value
    
    Test cases:
    - Basic strings
    - All escape sequences
    - Unicode
    - Unterminated strings
    - Empty strings
    
[ ] 1.2.7: Implement template literal lexing
    File: src/frontend/lexer/lexer.cpp
    Function: Token scanTemplateLiteral()
    Strategy: Lex `backtick strings` with &{interpolation}
    
    STATE MACHINE SPECIFICATION:
    Add lexer state tracking:
    ```cpp
    enum LexerState {
        NORMAL,           // Normal lexing
        IN_TEMPLATE,      // Inside `...` template
        IN_INTERPOLATION  // Inside &{...} interpolation
    };
    std::vector<LexerState> state_stack; // Stack for nested states
    int brace_depth;      // Track {} nesting in interpolations
    ```
    
    TOKEN SEQUENCE:
    - TOKEN_BACKTICK_START: ` (enter IN_TEMPLATE)
    - TOKEN_TEMPLATE_TEXT: text parts (accumulate until &{ or `)
    - TOKEN_INTERP_START: &{ (push IN_INTERPOLATION, track brace_depth)
    - (lex expression tokens normally, tracking {} depth)
    - TOKEN_INTERP_END: } (at depth 0, pop to IN_TEMPLATE)
    - TOKEN_BACKTICK_END: ` (pop to NORMAL)
    
    ALGORITHM:
    1. When see `, push IN_TEMPLATE, return TOKEN_BACKTICK_START
    2. In IN_TEMPLATE:
       - If see &{ -> push IN_INTERPOLATION, brace_depth=0, return TOKEN_INTERP_START
       - If see ` -> pop to NORMAL, return TOKEN_BACKTICK_END
       - If see \` -> add ` to text (escaped)
       - Otherwise accumulate text, return TOKEN_TEMPLATE_TEXT when done
    3. In IN_INTERPOLATION:
       - Lex tokens normally
       - If see { -> increment brace_depth
       - If see } -> if brace_depth > 0, decrement; else pop state, return TOKEN_INTERP_END
    
    NESTED INTERPOLATION EXAMPLE:
    `value: &{obj.get("key")}`
    Tokens: BACKTICK_START, TEMPLATE_TEXT("value: "), INTERP_START,
            IDENTIFIER(obj), DOT, IDENTIFIER(get), LEFT_PAREN,
            STRING("key"), RIGHT_PAREN, INTERP_END, BACKTICK_END
    
    Handle:
    - Multiple interpolations: `&{a} + &{b}` 
    - Nested braces: `&{arr[i + (j * 2)]}`
    - Escape sequences: \`, \n, \t, \\
    - Empty interpolations: `&{}`
    - Adjacent interpolations: `&{a}&{b}`
    
    Test cases:
    - Simple: `hello world`
    - Single interpolation: `value: &{x}`
    - Multiple: `&{a} + &{b} = &{a+b}`
    - Nested braces: `&{arr[i]}`
    - Function calls: `&{func(1, 2)}`
    - Object access: `&{obj.prop.nested}`
    - Escaped backtick: `backtick: \` here`
    - Mixed: `text &{expr} more &{expr2} end`
    
[ ] 1.2.8: Implement operator lexing
    File: src/frontend/lexer/lexer.cpp
    Function: Token scanOperator()
    Strategy: Maximal munch (longest match wins)
    
    Multi-char operators to handle:
    - <=>, ?., ??, |>, <|, .., ..., ->
    - ++, --, ==, !=, <=, >=, &&, ||
    - <<, >>, +=, -=, *=, /=, %=
    
    Use cascading if/match:
    if (peek() == '=') {
        if (peekNext() == '=') { /* ... */ }
    }
    
    Test cases:
    - All operators
    - Disambiguation (< vs <= vs <=> vs <|)
    
[ ] 1.2.9: Implement main tokenization loop
    File: src/frontend/lexer/lexer.cpp
    Function: Token nextToken()
    
    Algorithm:
    1. Skip whitespace and comments
    2. Save start position
    3. If at end, return TOKEN_EOF
    4. Read first char, dispatch:
       - Digit or . followed by digit -> scanNumber()
       - Letter or _ -> scanIdentifier()
       - " or ' -> scanString()
       - ` -> scanTemplateLiteral()
       - Operator char -> scanOperator()
       - Punctuation -> single-char token
       - Unknown -> errorToken()
    5. Return token
    
    Test: Can lex complete programs
    
[ ] 1.2.10: Implement error recovery
    File: src/frontend/lexer/lexer.cpp
    Functions:
    - errorToken() - Create TOKEN_ERROR
    - Store error message
    - Continue lexing (don't crash)
    
    Strategy for errors:
    - Unknown character: Skip, report error, continue
    - Unterminated string: Report error, return partial string
    - Invalid number: Report error, return 0
    
    Test: Lexer finds multiple errors in one pass

═══════════════════════════════════════════════════════════════════════
1.3: Lexer Testing
═══════════════════════════════════════════════════════════════════════

[ ] 1.3.1: Unit test - Numbers
    File: tests/unit/test_lexer_numbers.cpp
    Test cases:
    - Decimal integers: 0, 123, 999999
    - Hex: 0x0, 0xFF, 0xDEADBEEF
    - Binary: 0b0, 0b1, 0b11111111
    - Octal: 0o0, 0o7, 0o755
    - Floats: 0.0, 3.14, 1e10, 1.5e-10
    - Underscores: 1_000_000
    - Invalid: 0x, 0b, 1.2.3 (expect errors)
    Run: ./test.sh unit_lexer_numbers
    
[ ] 1.3.2: Unit test - Strings
    File: tests/unit/test_lexer_strings.cpp
    Test cases:
    - Basic: "hello", 'world'
    - Empty: "", ''
    - Escapes: "line\nbreak", "tab\there"
    - Unicode: "\u{1F600}"
    - Unterminated: "hello (expect error)
    Run: ./test.sh unit_lexer_strings
    
[ ] 1.3.3: Unit test - Template literals
    File: tests/unit/test_lexer_templates.cpp
    Test cases:
    - Simple: `hello`
    - Interpolation: `value: &{x}`
    - Multiple: `&{a} + &{b} = &{a+b}`
    - Nested: `&{x + (y * 2)}`
    - Escape: `backtick: \``
    Run: ./test.sh unit_lexer_templates
    
[ ] 1.3.4: Unit test - Operators
    File: tests/unit/test_lexer_operators.cpp
    Test all operators individually
    Test disambiguation: < vs <= vs <=> vs <|
    Run: ./test.sh unit_lexer_operators
    
[ ] 1.3.5: Unit test - Keywords
    File: tests/unit/test_lexer_keywords.cpp
    Test all 75+ keywords recognized
    Test keywords vs identifiers (while vs while123)
    Run: ./test.sh unit_lexer_keywords
    
[ ] 1.3.6: Integration test - Complete file
    File: tests/integration/test_lexer_full.cpp
    Test: Lex complete valid Aria program
    Verify: All tokens correct
    Test error cases: Invalid syntax caught
    Run: ./test.sh integration_lexer_full
    
[ ] 1.3.7: Benchmark - Lexer performance
    File: tests/benchmarks/bench_lexer.cpp
    Test: Large file (10,000+ lines)
    Measure: Tokens per second
    Target: > 100,000 tokens/sec
    Run: ./test.sh bench_lexer

COMMIT CHECKPOINT: Phase 1 - Lexer complete
Tag: v0.1.0-phase1-lexer-complete
All tests pass
Merge to main: YES (lexer is foundation)

███████████████████████████████████████████████████████████████████████
██ PHASE 2: PARSER & AST - SYNTAX TREE CONSTRUCTION                   ██
███████████████████████████████████████████████████████████████████████

Goal: Parse token stream into Abstract Syntax Tree (AST).
Reference: [research_014-020, research_024-028]

═══════════════════════════════════════════════════════════════════════
2.1: AST Node Definitions
═══════════════════════════════════════════════════════════════════════
Reference: All research docs for complete language constructs

[ ] 2.1.1: Create base AST node interface
    File: include/frontend/ast/ast_node.h
    Content: Base class for all AST nodes
    ```cpp
    class ASTNode {
    public:
        enum NodeType {
            // Expressions
            LITERAL, IDENTIFIER, BINARY_OP, UNARY_OP, CALL, INDEX,
            MEMBER_ACCESS, LAMBDA, TEMPLATE_LITERAL, RANGE,
            // Statements
            VAR_DECL, FUNC_DECL, RETURN, IF, WHILE, FOR, LOOP, TILL,
            WHEN, PICK, BREAK, CONTINUE, DEFER, BLOCK,
            // Types
            TYPE_ANNOTATION, GENERIC_TYPE,
            // Modules
            USE, MOD, EXTERN
        };
        
        NodeType type;
        int line, column;
        
        virtual ~ASTNode() = default;
        virtual std::string toString() const = 0;
    };
    ```
    Test: Base class compiles
    
[ ] 2.1.2: Create expression AST nodes
    File: include/frontend/ast/expr.h
    Node types:
    - LiteralExpr (int, float, string, bool, null)
    - IdentifierExpr (variable/function names)
    - BinaryExpr (left op right) [research_024, research_025]
    - UnaryExpr (op expr) [research_024, research_025]
    - CallExpr (callee, args)
    - IndexExpr (array[index])
    - MemberExpr (obj.member, ptr->member)
    - LambdaExpr (params, body) [research_016]
    - TemplateExpr (parts, interpolations) [research_026]
    - RangeExpr (start..end, start...end) [research_026]
    - TernaryExpr (is cond : true_val : false_val)
    - SafeNavExpr (?.)  [research_026]
    - NullCoalesceExpr (??)  [research_026]
    - PipelineExpr (|>, <|)  [research_026]
    Test: All expression nodes compile
    
[ ] 2.1.3: Create statement AST nodes
    File: include/frontend/ast/stmt.h
    Node types:
    - VarDeclStmt (type, name, initializer) [research_012-017]
    - FuncDeclStmt (name, params, return_type, body) [research_016]
    - ReturnStmt (expr)
    - IfStmt (condition, then_block, else_block) [research_019]
    - WhileStmt (condition, body) [research_018]
    - ForStmt (init, condition, increment, body) [research_018]
    - LoopStmt (start, limit, step, body) [research_018]
    - TillStmt (limit, step, body) [research_018]
    - WhenStmt (condition, body, then_block, end_block) [research_018]
    - PickStmt (expr, cases, default) [research_019]
    - BreakStmt, ContinueStmt [research_020]
    - DeferStmt (stmt) [research_020]
    - BlockStmt (stmts[])
    Test: All statement nodes compile
    
[ ] 2.1.4: Create type annotation nodes
    File: include/frontend/ast/type.h
    Node types:
    - SimpleType (int8, string, etc.)
    - PointerType (T*)
    - ArrayType (T[], T[N])
    - FuncType (params -> return) [research_016]
    - GenericType (T<U, V>) [research_027]
    - ResultType (result) [research_016]
    Test: Type nodes compile
    
[ ] 2.1.5: Create module/import nodes
    File: include/frontend/ast/module.h
    Reference: [research_028]
    Node types:
    - UseStmt (path, items, alias, conditional)
    - ModStmt (name, body)
    - ExternStmt (lib, declarations)
    Test: Module nodes compile

═══════════════════════════════════════════════════════════════════════
2.2: Parser Infrastructure
═══════════════════════════════════════════════════════════════════════

[ ] 2.2.1: Define operator precedence table
    File: include/frontend/parser/precedence.h
    Reference: [research_024], [research_025], [research_026]
    
    Precedence levels (lowest to highest):
    1. Pipeline: |>, <|
    2. Ternary: is ? :
    3. Null coalescing: ??
    4. Logical OR: ||
    5. Logical AND: &&
    6. Comparison: ==, !=, <, >, <=, >=, <=>
    7. Range: .., ...
    8. Bitwise OR: |
    9. Bitwise XOR: ^
    10. Bitwise AND: &
    11. Shift: <<, >>
    12. Addition: +, -
    13. Multiplication: *, /, %
    14. Unary: -, !, ~, @, #, $
    15. Postfix: ++, --, ., ->, ?., [], (), ?
    16. Primary: literals, identifiers, (expr)
    
    Test: Precedence table is correct
    
[ ] 2.2.2: Create Parser class
    File: include/frontend/parser/parser.h
    ```cpp
    class Parser {
    private:
        std::vector<Token> tokens;
        size_t current;
        std::vector<std::string> errors;
        
        // Helpers
        Token peek() const;
        Token previous() const;
        Token advance();
        bool check(TokenType type) const;
        bool match(std::initializer_list<TokenType> types);
        Token consume(TokenType type, const std::string& message);
        void synchronize();  // Error recovery
        
        // Parsing methods (recursive descent)
        ASTNode* parseProgram();
        ASTNode* parseDeclaration();
        ASTNode* parseStatement();
        ASTNode* parseExpression();
        ASTNode* parsePrimary();
        // ... (many more parse methods)
        
    public:
        Parser(const std::vector<Token>& toks);
        ASTNode* parse();
        const std::vector<std::string>& getErrors() const;
        bool hasErrors() const;
    };
    ```
    Test: Parser class compiles
    
[ ] 2.2.3: Implement parser utilities
    File: src/frontend/parser/parser.cpp
    Implement:
    - Constructor
    - peek(), previous(), advance()
    - check(), match(), consume()
    - synchronize() for error recovery
    Test: Utilities work correctly

═══════════════════════════════════════════════════════════════════════
2.3: Expression Parsing
═══════════════════════════════════════════════════════════════════════

[ ] 2.3.1: Implement primary expression parsing
    File: src/frontend/parser/parse_expr.cpp
    Function: ASTNode* parsePrimary()
    Handle:
    - Literals (int, float, string, bool, null, true, false, ERR)
    - Identifiers
    - Parenthesized expressions
    - Lambda expressions [research_016]
    - Template literals [research_026]
    Test: Parse all primary expressions
    
[ ] 2.3.2: Implement precedence climbing for binary ops
    File: src/frontend/parser/parse_expr.cpp
    Function: ASTNode* parseExpression(int precedence = 0)
    Algorithm: Precedence climbing (Pratt parsing)
    Reference: [research_024], [research_025], [research_026]
    Handle all binary operators with correct precedence
    Test: Parse complex expressions with mixed operators
    
[ ] 2.3.3: Implement unary expression parsing
    File: src/frontend/parser/parse_expr.cpp
    Function: ASTNode* parseUnary()
    Handle: -, !, ~, @, #, $ operators [research_024-026]
    Test: Parse unary expressions
    
[ ] 2.3.4: Implement postfix expression parsing
    File: src/frontend/parser/parse_expr.cpp
    Function: ASTNode* parsePostfix()
    Handle:
    - Function calls: func(args)
    - Array indexing: arr[index]
    - Member access: obj.member
    - Pointer member: ptr->member
    - Safe navigation: obj?.member [research_026]
    - Postfix increment/decrement: x++, x--
    - Unwrap operator: result? [research_026]
    Test: Parse all postfix expressions
    
[ ] 2.3.5: Implement special operator parsing
    File: src/frontend/parser/parse_expr.cpp
    Functions:
    - parseTernary() - is cond : true : false
    - parseRange() - start..end, start...end
    - parsePipeline() - |>, <|
    - parseNullCoalesce() - ??
    Reference: [research_026]
    Test: Parse special operators

═══════════════════════════════════════════════════════════════════════
2.4: Statement Parsing (December 14-15, 2025)
═══════════════════════════════════════════════════════════════════════

[X] 2.4.1: Implement variable declaration parsing - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: ASTNode* parseVarDecl()
    Syntax: type:name = expr;
    Status: Implemented in Phase 2.4 (commit 1e07fe0)
    Test: Variable declarations working in all tests
    
[X] 2.4.2: Implement function declaration parsing - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: ASTNode* parseFuncDecl()
    Syntax: func:name = returnType(params) { body };
    Status: Implemented (commit 21c73ee)
    Features: Parameter parsing, lookahead for func: vs func(), body parsing
    Test: 8 comprehensive tests (no params, single, multiple, complex bodies)
    Note: Basic functions working. Generics/closures deferred to future phases
    
[X] 2.4.3: Implement control flow parsing - if/else - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: ASTNode* parseIfStatement()
    Status: Implemented (commit ed728f9)
    Test: All if/else tests passing
    
[X] 2.4.4: Implement loop parsing - while, for - COMPLETE
    File: src/frontend/parser/parser.cpp
    Functions: parseWhileStatement(), parseForStatement()
    Status: Implemented (commit e89233c)
    Test: All while/for tests passing
    
[X] 2.4.5: Implement loop parsing - break, continue - COMPLETE
    File: src/frontend/parser/parser.cpp
    Functions: parseBreakStatement(), parseContinueStatement()
    Status: Implemented (commit 087c6b9)
    Test: All break/continue tests passing
    
[X] 2.4.6: Implement Aria-specific loops - till, loop, when - COMPLETE
    File: src/frontend/parser/parser.cpp
    Functions: parseTillStatement(), parseLoopStatement(), parseWhenStatement()
    Status: Implemented (commit 1589435)
    Test: All Aria-specific loop tests passing
    
[X] 2.4.7: Implement pick (pattern matching) - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: parsePickStatement(), parseFallStatement()
    Status: Implemented with fall() support (commit 5c54f2b)
    Test: All pick/fall tests passing
    
[X] 2.4.8: Implement defer statement - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: parseDeferStatement()
    Status: Implemented (commit db37534)
    Test: All defer tests passing (169 tests, 779 assertions)
    
[X] 2.4.9: Implement pass/fail statements (Result Monad) - COMPLETE
    File: src/frontend/parser/parser.cpp
    Functions: parsePassStatement(), parseFailStatement()
    Status: Implemented (commit 965f39e)
    Reference: [research_020] Control Transfer
    Test: All pass/fail tests passing (181 tests, 821 assertions)
    Note: Simplified implementation (returns directly, not result object)
    TODO: Implement ObjectLiteralExpr for full {err, val} construction

═══════════════════════════════════════════════════════════════════════
2.5: Type and Module Parsing
═══════════════════════════════════════════════════════════════════════

[X] 2.5.1: Implement type annotation parsing - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: ASTNode* parseType()
    Status: Implemented (commit 3b45f18)
    Reference: [research_027] Generics, [research_012] Integer Types, [research_014] Composite Types
    Features:
    - Simple types: int8, string, bool, obj, dyn, uint8-512, flt32-512, tbb8-64
    - Generic types: Array<int8>, Map<string, int32> with recursive parsing
    - Nested generics: Array<Array<int32>> (unlimited depth)
    - Pointer types: int64@, string@ (Aria native @ syntax, NOT *)
    - Array types: int8[] (dynamic), int8[100] (sized)
    - Function types: deferred to Phase 3 (semantic analysis)
    Implementation:
    - Upgraded existing parseType() stub to full ~75-line implementation
    - Uses TOKEN_AT (@) for pointers (Aria), not TOKEN_STAR (*) (extern only)
    - Recursive calls for nested generic type arguments
    - Accepts both type keywords and identifiers (Array, Map, custom types)
    - Fixed TOKEN_KW_OBJ missing from isTypeKeyword() function
    - Fixed type keyword ambiguity in parseStatement() with lookahead for colon
    Test: 15 comprehensive type tests added (235 total tests, 1119 assertions)
    Note: AST nodes (SimpleType, GenericType, PointerType, ArrayType) were pre-existing
    
[X] 2.5.2: Implement use statement parsing - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: ASTNode* parseUseStatement()
    Reference: [research_028]
    Status: Implemented (commit unknown, verified working)
    Features:
    - Simple: use std.io;
    - Nested paths: use std.io.file;
    - Selective: use std.{array, map};
    - Wildcard: use math.*;
    - Alias: use "./file.aria" as name;
    - Relative paths: use "./local.aria", "../parent.aria"
    - Absolute paths: use "/usr/lib/aria/core.aria"
    Test: 11 comprehensive use tests passing (all forms covered)
    
[X] 2.5.3: Implement mod statement parsing - COMPLETE
    File: src/frontend/parser/parser.cpp  
    Function: ASTNode* parseModStatement()
    Reference: [research_028]
    Status: Implemented (commit 5a98554)
    Test: All 9 mod tests passing (216 total tests, 1036 assertions)
    Note: Supports both external mod {...} and inline mod:name statements
    
[X] 2.5.4: Implement extern statement parsing - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: ASTNode* parseExternStatement()
    Syntax: extern "libname" { func_signatures; var_decls; }
    Reference: [research_028] lines 250-350
    Status: Implemented (commit 133ac30)
    Features:
    - ExternStmt AST node with libraryName and declarations vector
    - Parses FFI function signatures without bodies (C-style void*, int*)
    - Parses FFI variable declarations (qualifiers + type:name)
    - Handles pointer types (* suffix) in return types and parameters
    - Accepts C type identifiers (void) + Aria types in extern blocks
    Test: All 7 extern tests passing (223 total tests, 1082 assertions)
    Note: In Aria, pointer syntax is type@ (e.g., int64@), but extern blocks
          use C-style syntax type* (e.g., void*) for FFI compatibility

═══════════════════════════════════════════════════════════════════════
2.6: Parser Error Handling - COMPLETE
═══════════════════════════════════════════════════════════════════════

[X] 2.6.1: Implement error recovery - synchronization - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: void synchronize()
    Status: Implemented and enhanced (commit 62ccc00)
    Strategy: Skip tokens until next statement boundary
    Boundaries: 
    - Semicolons (statement boundaries)
    - Control flow keywords: if, else, while, for, loop, till, when, pick
    - Function keywords: func, return, pass, fail
    - Flow control: break, continue, defer
    - Module keywords: use, mod, extern, struct
    Test: 9 error handling tests passing (244 total tests, 1133 assertions)
    
[X] 2.6.2: Implement helpful error messages - COMPLETE
    File: src/frontend/parser/parser.cpp
    Function: void error(const std::string& message)
    Status: Enhanced with better formatting (commit 62ccc00)
    Features:
    - Multi-line error format for readability
    - Line and column numbers in error message
    - Token context (e.g., "Found: identifier 'x'", "Found: token ';'")
    - Special handling for EOF, identifiers, literals
    Example output:
      Parse error at line 1, column 12:
        Expected ';' after variable declaration
        Found: end of file
    Test: Error message format validation test passing
    
[X] 2.6.3: Implement panic mode for cascading errors - COMPLETE
    File: src/frontend/parser/parser.cpp
    Status: Working (commit 62ccc00)
    Strategy: synchronize() called after error to skip to safe point
    Prevents: Hundreds of errors from single mistake
    Test: No cascade test validates single error doesn't cause many errors
    Result: Parser recovers and continues parsing after errors

═══════════════════════════════════════════════════════════════════════
2.7: Parser Testing
═══════════════════════════════════════════════════════════════════════

[ ] 2.7.1: Unit test - Expression parsing
    File: tests/unit/test_parser_expr.cpp
    Test: All expression types parse correctly
    Test: Operator precedence is correct
    Test: Complex nested expressions work
    
[ ] 2.7.2: Unit test - Statement parsing
    File: tests/unit/test_parser_stmt.cpp
    Test: All statement types parse correctly
    Test: Nested statements work
    
[ ] 2.7.3: Unit test - Type parsing
    File: tests/unit/test_parser_type.cpp
    Test: All type annotations parse correctly
    
[ ] 2.7.4: Unit test - Module parsing
    File: tests/unit/test_parser_module.cpp
    Test: use, mod, extern parse correctly
    
[ ] 2.7.5: Unit test - Error recovery
    File: tests/unit/test_parser_errors.cpp
    Test: Parser recovers from syntax errors
    Test: Error messages are helpful
    
[ ] 2.7.6: Integration test - Parse example files
    File: tests/integration/test_parser_examples.cpp
    Test: Parse all files in examples/ directory
    Verify: AST structure is correct
    
[ ] 2.7.7: Integration test - Parse invalid files
    File: tests/integration/test_parser_invalid.cpp
    Test: Parser correctly rejects invalid syntax
    Test: Error messages point to problems

COMMIT CHECKPOINT: Phase 2 - Parser complete
Tag: v0.1.0-phase2-parser-complete
All tests pass
Merge to main: YES (parser enables semantic analysis)


███████████████████████████████████████████████████████████████████████
██ PHASE 3: SEMANTIC ANALYSIS - TYPE CHECKING & VALIDATION            ██
███████████████████████████████████████████████████████████████████████

Goal: Validate AST semantics, type check, resolve symbols.
Reference: [research_001, research_012-017, research_027-028]

═══════════════════════════════════════════════════════════════════════
3.1: Symbol Table Implementation
═══════════════════════════════════════════════════════════════════════

[✓] 3.1.1: Create symbol table data structures (commit d8fa39c)
    File: include/frontend/sema/symbol_table.h
    Content:
    - Symbol struct (name, kind, type, scope, location, visibility, mutability)
    - SymbolKind enum (VARIABLE, FUNCTION, PARAMETER, TYPE, MODULE, CONSTANT)
    - Scope class (parent scope, children scopes, symbols map, kind)
    - ScopeKind enum (GLOBAL, FUNCTION, BLOCK, STRUCT, MODULE)
    - SymbolTable class (root scope, current scope, symbol ownership)
    Methods:
    - enterScope(kind, name), exitScope()
    - defineSymbol(name, kind, type, line, col), lookupSymbol(name), resolveSymbol(name)
    - isDefined(name), getCurrentScope(), hasErrors(), getErrors()
    - Scope: lookup(name), resolve(name), enterScope(), exitScope()
    Type System Stub:
    - include/frontend/sema/type.h with Type, PrimitiveType, UnknownType, ErrorType
    - TypeSystem factory with primitive caching (int1-512, uint8-512, flt32-512, tbb8-64, bool, string, obj, dyn)
    Tests: 20 comprehensive tests (264 total, 1187 assertions, all passing)
    Features: Hierarchical scoping, symbol shadowing, duplicate detection, parent scope resolution
    Status: Complete and tested
    
[✓] 3.1.2: Implement scoped symbol resolution (included in 3.1.1 - commit d8fa39c)
    File: src/frontend/sema/symbol_table.cpp
    Implementation:
    - Scope::lookup(name) - searches ONLY current scope
    - Scope::resolve(name) - searches current THEN parent scopes recursively
    - SymbolTable::lookupSymbol(name) - current scope only
    - SymbolTable::resolveSymbol(name) - current + parent scopes (delegates to Scope::resolve)
    Handle: All nested scopes (GLOBAL, FUNCTION, BLOCK, STRUCT, MODULE)
    Tests:
    - symbol_table_nested_scopes: Verifies resolution across scope boundaries
    - symbol_table_shadowing: Verifies inner scope shadows outer scope
    - symbol_table_function_parameters: Verifies function scope resolution
    - symbol_table_block_scope: Verifies block scope resolution
    Status: Complete and tested (part of 264 tests, 1187 assertions)
    
[✓] 3.1.3: Implement module-level symbol table (commit 03633cb)
    Files: include/frontend/sema/module_table.h, src/frontend/sema/module_table.cpp
    Purpose: Track symbols across modules with visibility control
    Implementation:
    - Module class: hierarchical parent/child relationships, per-module symbol table, export/import management
    - ModuleTable class: module registry, import resolution, circular dependency detection, visibility enforcement
    Visibility Levels (research_028 Section 5):
    - PRIVATE (default): visible only within defining module
    - PUBLIC (pub): visible to all importers
    - PACKAGE (pub(package)): visible within compilation unit
    - SUPER (pub(super)): visible to parent module
    Import Types (research_028 Section 3):
    - Basic: use std.io
    - Aliased: use std.io as stdio
    - Wildcard: use math.*
    - Selective: use std.collections.{array, map}
    Features:
    - Import resolution with logical path support (std.io)
    - Circular dependency detection with recursion stack (A->B->A cycles caught at compile time)
    - Re-export support (pub use pattern)
    - Module hierarchy with full path tracking (std.io.file)
    Tests: 20 comprehensive tests (284 total, 1235 assertions, all passing)
    Status: Complete and tested

═══════════════════════════════════════════════════════════════════════
3.2: Type System Implementation
═══════════════════════════════════════════════════════════════════════
Reference: [research_012-017]

[X] 3.2.1: Create type representation (COMPLETE - Commit ac8173d)
    File: include/frontend/sema/type.h, src/frontend/sema/type.cpp
    Completed:
    - Type base class with TypeKind enum (12 variants)
    - PrimitiveType: Enhanced with bitWidth, isSigned, isFloating, isTBB
    - PointerType (T@): with mutability and wild pointer support
    - ArrayType (T[N]): fixed-size and dynamic arrays
    - VectorType (vec2-vec9): SIMD vectors with component types
    - FunctionType: params, return, async, variadic flags
    - StructType: nominal typing with fields, layout, alignment
    - UnionType: nominal typing with variants
    - GenericType: type parameters (T, U, V)
    - ResultType: error handling (result<T>)
    - TypeSystem factory: pre-cached 50+ primitives, factory methods
    - All operations: equals(), isAssignableTo(), toString()
    Research: research_012-016 (integers, floats, TBB, composites, vectors, functions)
    Tests: All 284 tests still passing (backward compatible)
    Status: Complete and ready for type checking
    
[X] 3.2.2: Implement type checking for expressions (COMPLETE - Commit 4d33714)
    Files: include/frontend/sema/type_checker.h, src/frontend/sema/type_checker.cpp
    Completed:
    - TypeChecker class with inferType() main entry point
    - Literal type inference: int64, flt64, string, bool, null
    - Identifier type resolution via symbol table lookup
    - Binary operators (research_024, research_025):
      * Arithmetic (+, -, *, /, %): numeric type promotion/widening
      * Bitwise (&, |, ^, <<, >>): UNSIGNED MANDATE enforcement
      * Comparison (==, !=, <, <=, >, >=): result is bool
      * Logical (&&, ||): STRICT BOOLEAN requirement (no truthiness!)
      * Spaceship (<=>): three-way comparison returning int
      * Assignment (=, +=, -=, *=, /=, %=): assignability checking
    - Unary operators (-, !, ~): type validation with strict boolean logic
    - Ternary operator (is cond : true : false): bool condition enforcement
    - Type coercion system: findCommonType(), canCoerce()
    - Widening rules: int8→int16→int32→int64, int→float, tbb8→tbb16→tbb32→tbb64
    - No narrowing (requires explicit cast), no standard↔TBB mixing
    - Error accumulation and reporting with line/column info
    Tests: 29 comprehensive tests (literals, identifiers, operators, coercion, complex expressions)
    Results: 313 tests total, 1322 assertions, all passing
    Status: Complete - expression type checking fully operational
    
[X] 3.2.3: Implement type checking for statements
    File: src/frontend/sema/type_checker.cpp
    Function: void checkStatement(ASTNode* stmt)
    Handle:
    - Variable declarations: check initializer type
    - Assignments: check type compatibility
    - Return statements: match function return type
    - Control flow: check condition types
    Test: Statement type checking works
    
[X] 3.2.4: Implement TBB type validation
    File: src/frontend/sema/tbb_checker.cpp
    Reference: [research_002]
    Validate:
    - tbb8: range [-127, +127], ERR = -128
    - tbb16: range [-32767, +32767], ERR = -32768
    - tbb32, tbb64: symmetric ranges with ERR sentinels
    - Operations produce ERR on overflow
    - ERR is sticky (propagates through operations)
    Test: TBB semantics enforced
    
[X] 3.2.5: Implement balanced ternary/nonary validation
    File: src/frontend/sema/balanced_checker.cpp
    Reference: [research_003]
    Validate:
    - trit: values {-1, 0, 1}
    - tryte: 10 trits stored in uint16
    - nit: values {-4, -3, -2, -1, 0, 1, 2, 3, 4}
    - nyte: 5 nits stored in uint16
    Test: Balanced type semantics enforced

═══════════════════════════════════════════════════════════════════════
3.3: Borrow Checker Integration ✓ COMPLETE (Commit: dddd6af)
═══════════════════════════════════════════════════════════════════════
Reference: [research_001]
Completion Date: [Current]
Files: borrow_checker.h (344 lines), borrow_checker.cpp (617 lines)
Tests: 13 new tests, 376 total tests passing (1388 assertions)

[✓] 3.3.1: Implement lifetime tracking
    File: src/frontend/sema/borrow_checker.cpp
    Implemented:
    - Scope depth tracking with LifetimeContext
    - Variable registration and depth lookup
    - Appendage Theory: Depth(Host) ≤ Depth(Reference)
    - Lifetime validation for borrows and pins
    Test: ✓ All lifetime tests pass
    
[✓] 3.3.2: Implement borrow rules
    File: src/frontend/sema/borrow_checker.cpp
    Implemented:
    - Rust-style exclusivity: 1 mutable XOR N immutable borrows
    - Loan tracking with borrower/host relationships
    - Pinning support (# operator) prevents GC movement
    - Active loan and pin state management
    Test: ✓ All borrow rule tests pass
    
[✓] 3.3.3: Implement memory safety validation
    File: src/frontend/sema/borrow_checker.cpp
    Implemented:
    - Wild memory leak detection
    - Use-after-free prevention  
    - Double-free detection
    - State tracking (ALLOCATED/FREED/MOVED)
    Test: ✓ All memory safety tests pass
    
Additional Features:
- Control flow analysis: If/else branching with phi node merging
- While/for loop handling
- Conservative state merging
- Comprehensive AST traversal (10 statement + 4 expression visitors)
- Borrow/pin detection in variable declarations

═══════════════════════════════════════════════════════════════════════
3.4: Generic Type Resolution ✓ IN PROGRESS (67% Complete)
═══════════════════════════════════════════════════════════════════════
Reference: [research_027]
Start Date: December 16, 2025

[✓] 3.4.1: Generic Infrastructure (Commit f89e35f)
    Files: include/frontend/sema/generic_resolver.h, src/frontend/sema/generic_resolver.cpp
    Implemented:
    - GenericParam structure with name and constraints
    - TypeSubstitution map (type parameter -> concrete type)
    - SpecializationKey for cache lookups
    - Specialization storage for monomorphized functions
    - GenericResolver class with inference and validation
    - Monomorphizer class with cloning and substitution
    Tests: Basic infrastructure in place
    Status: Complete ✓
    
[✓] 3.4.2: AST Cloning and Type Substitution (Commit e6e9883)
    Files: src/frontend/sema/monomorphization.cpp
    Implemented:
    - Deep cloning for all AST node types (statements, expressions, types)
    - Type substitution algorithm (*T -> concrete type)
    - Recursive traversal for nested structures
    - Support for generic function bodies, parameters, return types
    Tests: 6 cloning/substitution tests (all passing)
    Status: Complete ✓
    
[✓] 3.4.3: Parser Support for Generic Syntax (Commit db3021f)
    Files: include/frontend/parser/parser.h, src/frontend/parser/parser.cpp
    Implemented:
    - parseGenericParams(): Parse <T, U> type parameter lists
    - isGenericTypeReference(): Detect *T pattern in code
    - parseFuncDecl(): Parse func<T>:name declarations
    - parseVarDecl(): Parse *T:variable syntax
    - parseStatement(): Enhanced lookahead for generic functions and variables
    Syntax Support:
    - Generic function declarations: func<T>:identity
    - Generic type references: *T in return types, parameters, variables
    - Multiple type parameters: func<T, U>:pair
    - Mixed generic/concrete types: func<T>:print = void(*T, int32)
    Tests: 5 comprehensive parser tests (all passing)
    Status: Complete ✓
    
[✓] 3.4.4: Trait Constraint Parsing (Commit efae301)
    Files: include/frontend/ast/stmt.h, src/frontend/parser/parser.cpp
    Implemented:
    - GenericParamInfo struct (name + vector<string> constraints)
    - parseGenericParams(): Parse T: Trait1 & Trait2 syntax
    - FuncDeclStmt updated to store GenericParamInfo instead of strings
    - toString() displays constraints in readable format
    Syntax Support:
    - Single constraints: func<T: Addable>:add
    - Multiple constraints: func<T: Addable & Display>:printAdd
    - Mixed parameters: func<T: Trait, U>:pair
    Tests: 3 new constraint tests + 5 updated tests (all passing)
    Status: Complete ✓
    
[ ] 3.4.5: Turbofish Syntax (Explicit Type Instantiation)
    Files: src/frontend/parser/parser.cpp
    Reference: research_027 section 2.4
    Implement:
    - parseExplicitTypeArgs(): Parse ::<T, U> syntax
    - Modify parseCallExpression(): Handle turbofish operator
    - Update CallExpr AST node to store explicit type arguments
    Syntax: identity::<int32>(42) for explicit instantiation
    Purpose: Disambiguate from comparison operators, allow explicit types
    Test: Turbofish parsing works correctly
    Status: Not started
    
[ ] 3.4.6: Generic Type Inference (Type Inference Algorithm)
    Files: src/frontend/sema/generic_resolver.cpp
    Reference: research_027 section 4
    Function: inferTypeArgs(FuncDecl*, CallExpr*, vector<Type*>)
    Strategy: Local bidirectional type inference
    Algorithm:
    1. Constraint generation (top-down): Collect type requirements from arguments
    2. Unification (bottom-up): Solve for type parameters
    3. Validation: Check completeness and consistency
    Handle: Type parameter inference from call site arguments
    Test: Generic types inferred correctly from context
    Status: Partial (infrastructure exists, needs completion)
    
[ ] 3.4.7: Monomorphization Engine
    Files: src/frontend/sema/monomorphization.cpp
    Reference: research_027 section 3
    Function: requestSpecialization(FuncDecl*, TypeSubstitution)
    Strategy: Lazy instantiation on demand
    Features:
    - Specialization cache with deduplication
    - Name mangling: _Aria_M_<name>_<hash>_<types>
    - Depth limit (64) with cycle detection
    - Link-time merging for cross-module duplicates
    Purpose: Zero-cost generics (like C++ templates, Rust)
    Test: Specialized functions generated correctly
    Status: Partial (cloning works, needs cache and mangling)
    
[ ] 3.4.8: Constraint Validation
    Files: src/frontend/sema/generic_resolver.cpp
    Reference: research_027 section 5
    Functions: checkConstraints(GenericParam, Type*), validateConstraints()
    Implement:
    - Trait system integration (requires trait definitions)
    - Definition-time checking (verify body only uses declared traits)
    - Instantiation-time checking (verify concrete type implements traits)
    - Built-in traits: Copy, Drop, Add, Sub, Mul, Div, Send
    Handle: Type bounds (e.g., T: Addable means T must support operator+)
    Test: Constraints enforced at both definition and instantiation time
    Status: Partial (parsing complete, validation needs trait system)
    
[ ] 3.4.9: TBB-Aware Monomorphization
    Files: src/backend/codegen/tbb_lowerer.cpp
    Reference: research_027 section 6
    Implement:
    - Semantic polymorphism: Different codegen for int32 vs tbb32
    - Standard types: Single-cycle CPU instructions
    - TBB types: Sticky ERR propagation, sentinel checks, overflow detection
    - Example: func<T>:add generates different IR for add_int32 vs add_tbb32
    Purpose: Zero overhead for standard types, safety for TBB types
    Test: Generic arithmetic generates appropriate IR for each type
    Status: Not started (requires codegen phase)
    
[ ] 3.4.10: Memory Model Integration
    Files: src/backend/codegen/gc_integration.cpp
    Reference: research_027 section 6.2
    Implement:
    - GC metadata generation for generic containers
    - Wild pointer detection: Vector<wild int*> = no GC scanning
    - Managed types: Vector<string> = GC map with pointer tracing
    - Write barrier insertion for managed generic types
    Purpose: Memory model agnostic generics
    Test: Generic containers adapt to memory model of contained type
    Status: Not started (requires GC implementation)

Current Status: 405 tests passing (1496 assertions)
Commits: f89e35f, e6e9883, db3021f, efae301
Progress: 4/10 tasks complete (40% core features, 67% of high-priority parsing)
Next: Turbofish syntax, then complete type inference

═══════════════════════════════════════════════════════════════════════
3.5: Module System Semantic Analysis
═══════════════════════════════════════════════════════════════════════
Reference: [research_028]

[ ] 3.5.1: Implement module resolution
    File: src/frontend/sema/module_resolver.cpp
    Function: resolveModule(UseStmt*)
    Handle:
    - Find module file from use path
    - Resolve relative paths: ./file.aria
    - Resolve absolute paths: /usr/lib/aria/
    - Handle selective imports: use std.{a, b}
    - Handle aliases: use file as name
    Test: Modules resolve correctly
    
[ ] 3.5.2: Implement visibility checking
    File: src/frontend/sema/visibility_checker.cpp
    Function: checkVisibility(Symbol*)
    Rules:
    - pub symbols accessible from other modules
    - Non-pub symbols only in same module
    - Respect module boundaries
    Test: Visibility rules enforced
    
[ ] 3.5.3: Implement circular dependency detection
    File: src/frontend/sema/module_resolver.cpp
    Function: detectCycle(Module[])
    Algorithm: Tarjan's strongly connected components
    Error: Report circular dependencies
    Test: Cycles detected and reported
    
[ ] 3.5.4: Implement extern validation
    File: src/frontend/sema/extern_checker.cpp
    Validate:
    - extern "libname" { ... } syntax
    - C function declarations
    - Type compatibility with C
    Test: Extern declarations validated

═══════════════════════════════════════════════════════════════════════
3.6: Semantic Analysis Testing
═══════════════════════════════════════════════════════════════════════

[ ] 3.6.1: Unit test - Symbol table
    File: tests/unit/test_symbol_table.cpp
    Test: Symbol definition, lookup, scoping
    
[ ] 3.6.2: Unit test - Type checking
    File: tests/unit/test_type_checker.cpp
    Test: All type rules enforced
    Test: Type inference works
    
[ ] 3.6.3: Unit test - TBB semantics
    File: tests/unit/test_tbb_sema.cpp
    Test: TBB range validation
    Test: ERR sentinel handling
    
[ ] 3.6.4: Unit test - Borrow checker
    File: tests/unit/test_borrow_checker.cpp
    Test: Borrow rules enforced
    Test: Lifetime errors caught
    
[ ] 3.6.5: Unit test - Generics
    File: tests/unit/test_generics.cpp
    Test: Type inference works
    Test: Monomorphization generates correct code
    
[ ] 3.6.6: Unit test - Module system
    File: tests/unit/test_module_sema.cpp
    Test: Module resolution works
    Test: Visibility rules enforced
    Test: Circular dependencies detected
    
[ ] 3.6.7: Integration test - Semantic analysis on examples
    File: tests/integration/test_sema_examples.cpp
    Test: All example files pass semantic analysis
    Test: Invalid examples caught

COMMIT CHECKPOINT: Phase 3 - Semantic analysis complete
Tag: v0.1.0-phase3-sema-complete
All tests pass
Merge to main: YES (semantic analysis enables IR generation)


███████████████████████████████████████████████████████████████████████
██ PHASE 4: IR GENERATION - LLVM BACKEND                               ██
███████████████████████████████████████████████████████████████████████

Goal: Generate LLVM IR from validated AST.
Reference: All research docs + LLVM 20.1.2 documentation

═══════════════════════════════════════════════════════════════════════
4.1: LLVM Infrastructure Setup
═══════════════════════════════════════════════════════════════════════

[ ] 4.1.1: Create IR generator class
    File: include/backend/ir/ir_generator.h
    ```cpp
    class IRGenerator {
    private:
        llvm::LLVMContext context;
        llvm::Module* module;
        llvm::IRBuilder<> builder;
        std::map<std::string, llvm::Value*> named_values;
        std::map<std::string, llvm::Type*> type_map;
        
    public:
        IRGenerator(const std::string& module_name);
        llvm::Value* codegen(ASTNode* node);
        llvm::Module* getModule();
        void dump();  // Debug output
    };
    ```
    Test: Class compiles, LLVM links correctly
    
[ ] 4.1.2: Implement Aria type to LLVM type mapping
    File: src/backend/ir/type_mapper.cpp
    Reference: [research_012-017]
    Mappings:
    - int8 -> i8, int16 -> i16, int32 -> i32, int64 -> i64
    - int128 -> i128, int256 -> i256, int512 -> i512
    - uint8-512 -> equivalent LLVM types
    - flt32 -> float, flt64 -> double, flt128 -> fp128
    - tbb8-64 -> same as int types (semantic difference only)
    - bool -> i1
    - Pointers -> LLVM pointer types
    - Arrays -> LLVM array types
    - Structs -> LLVM struct types
    Test: All Aria types map correctly
    
[ ] 4.1.3: Implement TBB arithmetic code generation
    File: src/backend/ir/tbb_codegen.cpp
    Reference: [research_002]
    Generate:
    - Range validation for tbb types
    - ERR sentinel checks (min value of type)
    - Overflow detection (result > max or < -max)
    - Sticky ERR propagation (if input is ERR, output is ERR)
    Example for tbb8 add:
    ```llvm
    %is_err_a = icmp eq i8 %a, -128
    %is_err_b = icmp eq i8 %b, -128
    br i1 %is_err_a, label %return_err, label %check_b
    ; ... overflow checking ...
    ```
    Test: TBB operations generate correct IR

═══════════════════════════════════════════════════════════════════════
4.2: Expression Code Generation
═══════════════════════════════════════════════════════════════════════

[ ] 4.2.1: Implement literal code generation
    File: src/backend/ir/codegen_expr.cpp
    Function: llvm::Value* codegenLiteral(LiteralExpr*)
    Handle: int, float, string, bool, null literals
    Test: Literals generate correct constants
    
[ ] 4.2.2: Implement variable reference code generation
    File: src/backend/ir/codegen_expr.cpp
    Function: llvm::Value* codegenIdentifier(IdentifierExpr*)
    Lookup: Variable in symbol table
    Generate: Load instruction
    Test: Variable loads work
    
[ ] 4.2.3: Implement binary operator code generation
    File: src/backend/ir/codegen_expr.cpp
    Function: llvm::Value* codegenBinary(BinaryExpr*)
    Reference: [research_024-025]
    Handle:
    - Arithmetic: add, sub, mul, div, mod
    - Comparison: eq, ne, lt, le, gt, ge
    - Logical: and, or
    - Bitwise: and, or, xor, shl, shr
    Test: Binary operations work
    
[ ] 4.2.4: Implement unary operator code generation
    File: src/backend/ir/codegen_expr.cpp
    Function: llvm::Value* codegenUnary(UnaryExpr*)
    Handle: neg, not, address (@), deref (*)
    Test: Unary operations work
    
[ ] 4.2.5: Implement function call code generation
    File: src/backend/ir/codegen_expr.cpp
    Function: llvm::Value* codegenCall(CallExpr*)
    Generate: Call instruction with arguments
    Handle: Return value
    Test: Function calls work
    
[ ] 4.2.6: Implement special operator code generation
    File: src/backend/ir/codegen_expr.cpp
    Reference: [research_026]
    Functions:
    - codegenTernary() - is ? : operator
    - codegenNullCoalesce() - ?? operator
    - codegenSafeNav() - ?. operator
    - codegenUnwrap() - ? operator
    - codegenPipeline() - |>, <| operators
    Test: Special operators work

═══════════════════════════════════════════════════════════════════════
4.3: Statement Code Generation
═══════════════════════════════════════════════════════════════════════

[ ] 4.3.1: Implement variable declaration code generation
    File: src/backend/ir/codegen_stmt.cpp
    Function: void codegenVarDecl(VarDeclStmt*)
    Generate: Alloca + store instructions
    Handle: Stack vs wild vs GC allocation
    Test: Variable declarations work
    
[ ] 4.3.2: Implement function declaration code generation
    File: src/backend/ir/codegen_stmt.cpp
    Function: llvm::Function* codegenFuncDecl(FuncDeclStmt*)
    Generate: Function with parameters, body
    Handle: Return type, closures
    Test: Function declarations work
    
[ ] 4.3.3: Implement if/else code generation
    File: src/backend/ir/codegen_stmt.cpp
    Function: void codegenIf(IfStmt*)
    Generate: Branch instructions, basic blocks
    Test: If statements work
    
[ ] 4.3.4: Implement loop code generation
    File: src/backend/ir/codegen_stmt.cpp
    Functions:
    - codegenWhile(), codegenFor() [research_018]
    - codegenLoop(), codegenTill() [research_018]
    - codegenWhen() [research_018]
    Generate: Loop basic blocks, phi nodes
    Test: All loop constructs work
    
[ ] 4.3.5: Implement pick (pattern matching) code generation
    File: src/backend/ir/codegen_stmt.cpp
    Function: void codegenPick(PickStmt*)
    Reference: [research_019]
    Generate: Switch or cascading comparisons
    Handle: Wildcard, fall() explicit fallthrough
    Test: Pick statements work
    
[ ] 4.3.6: Implement control flow code generation
    File: src/backend/ir/codegen_stmt.cpp
    Functions:
    - codegenReturn() - return statement
    - codegenBreak() - break from loop
    - codegenContinue() - continue loop
    - codegenDefer() - RAII cleanup
    Reference: [research_020]
    Test: Control transfer works

═══════════════════════════════════════════════════════════════════════
4.4: Memory Model Implementation
═══════════════════════════════════════════════════════════════════════

[ ] 4.4.1: Implement GC allocation code generation
    File: src/backend/ir/memory_codegen.cpp
    Function: llvm::Value* codegenGCAlloc(Type*, size_t)
    Generate: Call to runtime GC allocator
    Default: All non-wild, non-stack allocations use GC
    Reference: [research_021]
    Test: GC allocations work
    
[ ] 4.4.2: Implement wild allocation code generation
    File: src/backend/ir/memory_codegen.cpp
    Function: llvm::Value* codegenWildAlloc(Type*, size_t)
    Generate: Call to aria.alloc() (manual memory)
    Reference: [research_022]
    Test: Wild allocations work
    
[ ] 4.4.3: Implement wildx allocation code generation
    File: src/backend/ir/memory_codegen.cpp
    Function: llvm::Value* codegenWildxAlloc(size_t)
    Generate: Call to aria.alloc_wildx() (executable memory)
    Reference: [research_022, research_023]
    Purpose: JIT code generation at runtime
    Test: WildX allocations work
    
[ ] 4.4.4: Implement stack allocation code generation
    File: src/backend/ir/memory_codegen.cpp
    Function: llvm::Value* codegenStackAlloc(Type*, size_t)
    Generate: Alloca instruction
    Purpose: Fast, automatic cleanup
    Test: Stack allocations work
    
[ ] 4.4.5: Implement defer code generation
    File: src/backend/ir/memory_codegen.cpp
    Function: void codegenDefer(DeferStmt*)
    Strategy: Register cleanup handlers
    Execute: At scope exit (RAII pattern)
    Reference: [research_020]
    Test: Defer executes at scope exit

═══════════════════════════════════════════════════════════════════════
4.5: Advanced Features Code Generation
═══════════════════════════════════════════════════════════════════════

[ ] 4.5.1: Implement generic instantiation
    File: src/backend/ir/generic_codegen.cpp
    Function: llvm::Function* instantiateGeneric(FuncDecl*, TypeArgs[])
    Strategy: Generate separate function for each type combination
    Reference: [research_027]
    Test: Generic functions work with multiple types
    
[ ] 4.5.2: Implement closure code generation
    File: src/backend/ir/closure_codegen.cpp
    Function: llvm::Value* codegenClosure(LambdaExpr*)
    Strategy: Capture environment, create function pointer
    Reference: [research_016]
    Test: Closures capture variables correctly
    
[ ] 4.5.3: Implement async/await code generation
    File: src/backend/ir/async_codegen.cpp
    Reference: [research_029]
    Functions:
    - codegenAsync() - Create coroutine
    - codegenAwait() - Suspend/resume points
    Strategy: LLVM coroutine intrinsics
    Test: Async functions work
    
[ ] 4.5.4: Implement compile-time evaluation
    File: src/backend/ir/comptime_codegen.cpp
    Reference: [research_030]
    Function: llvm::Constant* evalConstExpr(ASTNode*)
    Strategy: Evaluate at compile time, emit constant
    Test: Const expressions evaluated at compile time

═══════════════════════════════════════════════════════════════════════
4.6: IR Generation Testing
═══════════════════════════════════════════════════════════════════════

[ ] 4.6.1: Unit test - Type mapping
    File: tests/unit/test_type_mapper.cpp
    Test: All Aria types map to correct LLVM types
    
[ ] 4.6.2: Unit test - Expression codegen
    File: tests/unit/test_codegen_expr.cpp
    Test: All expression types generate correct IR
    
[ ] 4.6.3: Unit test - Statement codegen
    File: tests/unit/test_codegen_stmt.cpp
    Test: All statement types generate correct IR
    
[ ] 4.6.4: Unit test - TBB codegen
    File: tests/unit/test_tbb_codegen.cpp
    Test: TBB operations generate overflow checks
    Test: ERR propagation works
    
[ ] 4.6.5: Unit test - Memory model codegen
    File: tests/unit/test_memory_codegen.cpp
    Test: GC, wild, stack allocations work
    
[ ] 4.6.6: Integration test - Compile and run examples
    File: tests/integration/test_compile_examples.cpp
    Test: Compile all example files to executables
    Test: Run executables, verify output
    
[ ] 4.6.7: Integration test - Optimization
    File: tests/integration/test_optimization.cpp
    Test: LLVM optimization passes work
    Test: Generated code is efficient

COMMIT CHECKPOINT: Phase 4 - IR generation complete
Tag: v0.1.0-phase4-ir-complete
All tests pass
Merge to main: YES (can now compile to executables)

███████████████████████████████████████████████████████████████████████
██ PHASE 5: RUNTIME IMPLEMENTATION - GC, I/O, PROCESSES                ██
███████████████████████████████████████████████████████████████████████

Goal: Implement runtime support libraries.
Reference: [research_004-009, research_021-023]

═══════════════════════════════════════════════════════════════════════
5.1: Garbage Collector Implementation
═══════════════════════════════════════════════════════════════════════
Reference: [research_021]

[ ] 5.1.1: Implement GC allocator
    File: src/runtime/gc/allocator.cpp
    Function: void* gc_alloc(size_t size)
    Strategy: Bump allocator with freelist
    Test: Can allocate memory
    
[ ] 5.1.2: Implement mark phase
    File: src/runtime/gc/mark.cpp
    Function: void gc_mark()
    Strategy: Mark reachable objects from roots
    Roots: Stack, globals, registers
    Test: Marks reachable objects
    
[ ] 5.1.3: Implement sweep phase
    File: src/runtime/gc/sweep.cpp
    Function: void gc_sweep()
    Strategy: Free unmarked objects
    Test: Reclaims unreachable memory
    
[ ] 5.1.4: Implement GC trigger
    File: src/runtime/gc/gc.cpp
    Function: void gc_collect()
    Trigger: Allocation threshold, explicit call
    Test: GC runs automatically
    
[ ] 5.1.5: Implement write barrier (for generational GC)
    File: src/runtime/gc/write_barrier.cpp
    Function: void gc_write_barrier(void* obj, void* ref)
    Purpose: Track intergenerational pointers
    Test: Write barrier works

═══════════════════════════════════════════════════════════════════════
5.2: Wild/WildX Memory Allocators
═══════════════════════════════════════════════════════════════════════
Reference: [research_022]

[ ] 5.2.1: Implement wild allocator
    File: src/runtime/allocators/wild_alloc.cpp
    Functions:
    - aria_alloc(size) - Manual allocation
    - aria_free(ptr) - Manual deallocation
    Strategy: Simple malloc/free wrapper or custom allocator
    Test: Manual memory management works
    
[ ] 5.2.2: Implement wildx allocator
    File: src/runtime/allocators/wildx_alloc.cpp
    Function: void* aria_alloc_wildx(size_t size)
    Strategy: Allocate RWX memory (mmap on Unix, VirtualAlloc on Windows)
    Reference: [research_023]
    Purpose: JIT code generation
    Test: Executable memory allocation works
    
[ ] 5.2.3: Implement specialized allocators
    File: src/runtime/allocators/specialized.cpp
    Functions:
    - aria_alloc_buffer(size) - Buffer allocation
    - aria_alloc_string(size) - String allocation
    - aria_alloc_array(elem_size, count) - Array allocation
    Test: Specialized allocators work

═══════════════════════════════════════════════════════════════════════
5.3: Runtime Assembler (for WildX)
═══════════════════════════════════════════════════════════════════════
Reference: [research_023]

[ ] 5.3.1: Implement runtime assembler API
    File: include/runtime/assembler.h
    ```cpp
    class RuntimeAssembler {
    public:
        void* assemble(const std::string& asm_code);
        void execute(void* code);
        void free(void* code);
    };
    ```
    Purpose: JIT compilation for wildx memory
    Test: Can assemble and execute code at runtime
    
[ ] 5.3.2: Integrate LLVM JIT
    File: src/runtime/assembler/jit.cpp
    Strategy: Use LLVM ORC JIT
    Test: JIT compilation works
    
[ ] 5.3.3: Implement code cache
    File: src/runtime/assembler/cache.cpp
    Purpose: Cache compiled code for reuse
    Test: Code caching improves performance

═══════════════════════════════════════════════════════════════════════
5.4: File I/O Implementation
═══════════════════════════════════════════════════════════════════════
Reference: [research_004]

[ ] 5.4.1: Implement file operations
    File: src/runtime/io/file.cpp
    Functions:
    - readFile(path) -> result<string>
    - writeFile(path, content) -> result<void>
    - openFile(path, mode) -> result<stream>
    Test: File operations work
    
[ ] 5.4.2: Implement stream operations
    File: src/runtime/io/stream.cpp
    Functions:
    - stream.readLine() -> string
    - stream.write(data) -> result<void>
    - stream.close()
    Test: Stream operations work
    
[ ] 5.4.3: Implement structured file reading
    File: src/runtime/io/structured.cpp
    Functions:
    - readJSON(path) -> result<obj>
    - readCSV(path) -> result<array>
    Reference: [research_004]
    Test: Structured reading works

═══════════════════════════════════════════════════════════════════════
5.5: Modern Streams (Six Channels)
═══════════════════════════════════════════════════════════════════════
Reference: [research_006]

[ ] 5.5.1: Implement stream system
    File: src/runtime/io/modern_streams.cpp
    Streams:
    - stdin: text input
    - stdout: text output
    - stderr: error output
    - stddbg: debug output
    - stddati: binary data input
    - stddato: binary data output
    Test: All six streams work
    
[ ] 5.5.2: Implement buffering
    File: src/runtime/io/buffer.cpp
    Strategy: Buffer writes, flush automatically
    Test: Buffering improves performance

═══════════════════════════════════════════════════════════════════════
5.6: Process Management
═══════════════════════════════════════════════════════════════════════
Reference: [research_005]

[ ] 5.6.1: Implement process operations
    File: src/runtime/process/process.cpp
    Functions:
    - spawn(cmd, args) -> result<process>
    - fork() -> result<pid>
    - exec(cmd, args) -> result<void>
    - wait(pid) -> result<exit_code>
    Test: Process operations work
    
[ ] 5.6.2: Implement pipe communication
    File: src/runtime/process/pipe.cpp
    Functions:
    - createPipe() -> pipe
    - pipe.read() -> data
    - pipe.write(data)
    Test: IPC via pipes works

═══════════════════════════════════════════════════════════════════════
5.7: Threading Library
═══════════════════════════════════════════════════════════════════════
Reference: [research_007]

[ ] 5.7.1: Implement thread operations
    File: src/runtime/threading/thread.cpp
    Functions:
    - thread_create(func, arg) -> thread_id
    - thread_join(thread_id)
    - thread_detach(thread_id)
    Test: Thread creation and joining work
    
[ ] 5.7.2: Implement synchronization primitives
    File: src/runtime/threading/sync.cpp
    Types:
    - Mutex, RWLock
    - Semaphore
    - Condition variable
    Test: Synchronization works

═══════════════════════════════════════════════════════════════════════
5.8: Atomics Library
═══════════════════════════════════════════════════════════════════════
Reference: [research_008]

[ ] 5.8.1: Implement atomic operations
    File: src/runtime/atomics/atomics.cpp
    Operations:
    - atomic_load, atomic_store
    - atomic_add, atomic_sub
    - atomic_compare_exchange
    - Memory orderings: relaxed, acquire, release, seq_cst
    Test: Atomic operations work

═══════════════════════════════════════════════════════════════════════
5.9: Timer/Clock Library
═══════════════════════════════════════════════════════════════════════
Reference: [research_009]

[ ] 5.9.1: Implement time operations
    File: src/runtime/time/time.cpp
    Functions:
    - now() -> timestamp
    - sleep(duration)
    - timer_create(duration, callback)
    Test: Time operations work

═══════════════════════════════════════════════════════════════════════
5.10: Async Runtime
═══════════════════════════════════════════════════════════════════════
Reference: [research_029]

[ ] 5.10.1: Implement async executor
    File: src/runtime/async/executor.cpp
    Functions:
    - spawn_task(async_func)
    - await_task(task_id)
    Strategy: Work-stealing task scheduler
    Test: Async tasks execute concurrently
    
[ ] 5.10.2: Implement future/promise
    File: src/runtime/async/future.cpp
    Types: Future<T>, Promise<T>
    Test: Futures and promises work

═══════════════════════════════════════════════════════════════════════
5.11: Runtime Testing
═══════════════════════════════════════════════════════════════════════

[ ] 5.11.1: Unit test - GC
    File: tests/unit/test_gc.cpp
    Test: GC collects garbage, doesn't collect live objects
    
[ ] 5.11.2: Unit test - Wild/WildX allocators
    File: tests/unit/test_wild_alloc.cpp
    Test: Manual memory management works
    
[ ] 5.11.3: Unit test - File I/O
    File: tests/unit/test_file_io.cpp
    Test: File operations work correctly
    
[ ] 5.11.4: Unit test - Streams
    File: tests/unit/test_streams.cpp
    Test: All six streams work
    
[ ] 5.11.5: Unit test - Process management
    File: tests/unit/test_process.cpp
    Test: Process operations work
    
[ ] 5.11.6: Unit test - Threading
    File: tests/unit/test_threading.cpp
    Test: Threads and synchronization work
    
[ ] 5.11.7: Unit test - Atomics
    File: tests/unit/test_atomics.cpp
    Test: Atomic operations are correct
    
[ ] 5.11.8: Integration test - Runtime stress test
    File: tests/integration/test_runtime_stress.cpp
    Test: Runtime handles heavy load

COMMIT CHECKPOINT: Phase 5 - Runtime complete
Tag: v0.1.0-phase5-runtime-complete
All tests pass
Merge to main: YES (runtime enables full language features)

███████████████████████████████████████████████████████████████████████
██ PHASE 6: STANDARD LIBRARY - CORE FUNCTIONALITY                      ██
███████████████████████████████████████████████████████████████████████

Goal: Implement essential standard library.
Reference: [research_031]

═══════════════════════════════════════════════════════════════════════
6.1: Core Types and Functions
═══════════════════════════════════════════════════════════════════════

[ ] 6.1.1: Implement print function
    File: lib/std/io.aria
    Function: print(string:msg)
    Implementation: Write to stdout
    Test: print() outputs correctly
    
[ ] 6.1.2: Implement aria allocator wrappers
    File: lib/std/memory.aria
    Functions:
    - aria.alloc<T>(count)
    - aria.free(ptr)
    - aria.gc_alloc<T>(count)
    - aria.alloc_buffer(size)
    - aria.alloc_string(size)
    - aria.alloc_array<T>(count)
    Test: Allocator functions work
    
[ ] 6.1.3: Implement result type utilities
    File: lib/std/result.aria
    Functions:
    - result.isOk(), result.isErr()
    - result.unwrap(), result.unwrapOr(default)
    Test: Result utilities work

═══════════════════════════════════════════════════════════════════════
6.2: Collections
═══════════════════════════════════════════════════════════════════════

[ ] 6.2.1: Implement array utilities
    File: lib/std/array.aria
    Functions:
    - Array.push(elem)
    - Array.pop() -> elem
    - Array.length()
    - Array.slice(start, end)
    Test: Array operations work
    
[ ] 6.2.2: Implement functional operations
    File: lib/std/functional.aria
    Functions:
    - filter(array, predicate)
    - transform(array, mapper) // map
    - reduce(array, reducer, initial)
    - sort(array, comparator)
    - reverse(array)
    - unique(array)
    Test: Functional operations work

═══════════════════════════════════════════════════════════════════════
6.3: String Library
═══════════════════════════════════════════════════════════════════════

[ ] 6.3.1: Implement string operations
    File: lib/std/string.aria
    Functions:
    - String.length()
    - String.substring(start, end)
    - String.indexOf(substr)
    - String.split(delimiter)
    - String.join(array, delimiter)
    - String.trim()
    - String.toUpper(), String.toLower()
    Test: String operations work

═══════════════════════════════════════════════════════════════════════
6.4: Math Library
═══════════════════════════════════════════════════════════════════════

[ ] 6.4.1: Implement math functions
    File: lib/std/math.aria
    Functions:
    - Math.abs(x)
    - Math.sqrt(x)
    - Math.pow(x, y)
    - Math.sin(x), Math.cos(x), Math.tan(x)
    - Math.log(x), Math.exp(x)
    - Math.floor(x), Math.ceil(x), Math.round(x)
    - Math.min(a, b), Math.max(a, b)
    Test: Math functions work
    
[ ] 6.4.2: Implement math constants
    File: lib/std/math.aria
    Constants:
    - Math.PI, Math.E
    - Math.INFINITY, Math.NAN
    Test: Constants accessible

═══════════════════════════════════════════════════════════════════════
6.5: Network Library (Basic)
═══════════════════════════════════════════════════════════════════════

[ ] 6.5.1: Implement HTTP client
    File: lib/std/http.aria
    Functions:
    - httpGet(url) -> result<string>
    - httpPost(url, data) -> result<string>
    Test: HTTP requests work

═══════════════════════════════════════════════════════════════════════
6.6: Standard Library Testing
═══════════════════════════════════════════════════════════════════════

[ ] 6.6.1: Unit test - Core functions
    File: tests/unit/test_std_core.cpp
    Test: print, allocators work
    
[ ] 6.6.2: Unit test - Collections
    File: tests/unit/test_std_collections.cpp
    Test: Array and functional operations work
    
[ ] 6.6.3: Unit test - Strings
    File: tests/unit/test_std_string.cpp
    Test: String operations work
    
[ ] 6.6.4: Unit test - Math
    File: tests/unit/test_std_math.cpp
    Test: Math functions and constants work
    
[ ] 6.6.5: Integration test - Use stdlib in examples
    File: tests/integration/test_stdlib_integration.cpp
    Test: Stdlib works with compiled programs

COMMIT CHECKPOINT: Phase 6 - Standard library complete
Tag: v0.1.0-phase6-stdlib-complete
All tests pass
Merge to main: YES (stdlib enables practical programming)

███████████████████████████████████████████████████████████████████████
██ PHASE 7: COMPILER DRIVER & TOOLING                                  ██
███████████████████████████████████████████████████████████████████████

Goal: Complete compiler with CLI and tooling.

═══════════════════════════════════════════════════════════════════════
7.1: Compiler Driver
═══════════════════════════════════════════════════════════════════════

[ ] 7.1.1: Implement command-line interface
    File: src/main.cpp
    Arguments:
    - ariac input.aria -o output
    - ariac input.aria --emit-llvm
    - ariac input.aria --ast-dump
    - ariac --version, --help
    Test: CLI works
    
[ ] 7.1.2: Implement multi-file compilation
    File: src/compiler_driver.cpp
    Function: compile(files[])
    Strategy: Compile all files, link together
    Test: Multi-file projects compile
    
[ ] 7.1.3: Implement incremental compilation
    File: src/incremental.cpp
    Strategy: Cache compiled modules, recompile only changed files
    Test: Incremental builds are faster
    
[ ] 7.1.4: Integrate linker
    File: src/linker.cpp
    Strategy: Use system linker (ld, lld)
    Test: Produces executable binaries

═══════════════════════════════════════════════════════════════════════
7.2: Error Reporting and Diagnostics
═══════════════════════════════════════════════════════════════════════

[ ] 7.2.1: Implement pretty error messages
    File: src/diagnostics/error_reporter.cpp
    Format:
    - File, line, column
    - Source context (show line)
    - Helpful suggestions
    - Color coding (red for errors, yellow for warnings)
    Test: Error messages are clear
    
[ ] 7.2.2: Implement warning system
    File: src/diagnostics/warnings.cpp
    Warnings:
    - Unused variables
    - Type mismatches (implicit conversions)
    - Dead code
    Test: Warnings work
    
[ ] 7.2.3: Implement diagnostic levels
    Arguments:
    - -Werror: Treat warnings as errors
    - -W<warning>: Enable specific warning
    - -Wno-<warning>: Disable specific warning
    Test: Diagnostic control works

═══════════════════════════════════════════════════════════════════════
7.3: Language Server Protocol (LSP) Basics
═══════════════════════════════════════════════════════════════════════

[ ] 7.3.1: Implement LSP server skeleton
    File: tools/lsp/server.cpp
    Protocol: Language Server Protocol
    Purpose: IDE integration (for vscode-aria)
    Features:
    - Syntax highlighting
    - Error checking
    - Go to definition (basic)
    Test: LSP server responds to requests
    
[ ] 7.3.2: Integrate with vscode-aria extension
    Directory: vscode-aria/
    Test: VS Code extension uses LSP server

═══════════════════════════════════════════════════════════════════════
7.4: Build System Integration
═══════════════════════════════════════════════════════════════════════

[ ] 7.4.1: Create aria.toml project file format
    File: docs/aria_toml_spec.md
    Content:
    ```toml
    [package]
    name = "myproject"
    version = "0.1.0"
    
    [dependencies]
    std = "0.1"
    
    [build]
    target = "executable"
    ```
    Test: Project file parses correctly
    
[ ] 7.4.2: Implement project builder
    File: tools/builder/builder.cpp
    Function: buildProject(aria_toml_path)
    Strategy: Read config, compile files, link
    Test: Projects build from config

═══════════════════════════════════════════════════════════════════════
7.5: Package Manager Foundations
═══════════════════════════════════════════════════════════════════════

[ ] 7.5.1: Design package format
    File: docs/package_format.md
    Format: .aria-pkg (tarball with metadata)
    Test: Package format documented
    
[ ] 7.5.2: Implement package installer (basic)
    File: tools/pkg/installer.cpp
    Function: installPackage(pkg_path)
    Strategy: Extract to ~/.aria/packages/
    Test: Packages install correctly

═══════════════════════════════════════════════════════════════════════
7.6: Documentation Generator
═══════════════════════════════════════════════════════════════════════

[ ] 7.6.1: Implement doc comment parser
    File: tools/doc/parser.cpp
    Syntax: /// Doc comment or /** Doc block */
    Test: Doc comments parse correctly
    
[ ] 7.6.2: Implement HTML doc generator
    File: tools/doc/generator.cpp
    Function: generateDocs(source_files[])
    Output: HTML documentation
    Test: Docs generate correctly

═══════════════════════════════════════════════════════════════════════
7.7: Tooling Testing
═══════════════════════════════════════════════════════════════════════

[ ] 7.7.1: Integration test - Compile full projects
    File: tests/integration/test_full_compilation.cpp
    Test: Compile multi-file projects
    Test: Run executables
    
[ ] 7.7.2: Integration test - Error reporting
    File: tests/integration/test_error_reporting.cpp
    Test: Error messages are helpful
    
[ ] 7.7.3: Integration test - LSP server
    File: tests/integration/test_lsp.cpp
    Test: LSP server responds correctly
    
[ ] 7.7.4: End-to-end test - Complete workflow
    File: tests/e2e/test_complete_workflow.sh
    Test: Create project, write code, compile, run

COMMIT CHECKPOINT: Phase 7 - Compiler driver complete
Tag: v0.1.0-phase7-complete
All tests pass
Merge to main: YES (compiler is feature-complete)

███████████████████████████████████████████████████████████████████████
██ FINAL MILESTONE: v0.1.0 RELEASE                                    ██
███████████████████████████████████████████████████████████████████████

[ ] Create release notes
    File: RELEASE_NOTES_v0.1.0.md
    Content: Features, known issues, roadmap
    
[ ] Create user documentation
    Files:
    - docs/user_guide.md
    - docs/language_reference.md
    - docs/stdlib_reference.md
    
[ ] Create developer documentation
    Files:
    - docs/architecture.md
    - docs/contributing.md
    - docs/compiler_internals.md
    
[ ] Tag release
    Command: git tag -a v0.1.0 -m "First feature-complete release"
    
[ ] Package distribution
    Create: aria-0.1.0-linux-x86_64.tar.gz
    
[ ] Celebrate! 🎉
    You've built a compiler from scratch!

███████████████████████████████████████████████████████████████████████
██ END OF ROADMAP                                                     ██
███████████████████████████████████████████████████████████████████████

Total phases: 8 (Phase 0-7 + Release)
Total tasks: ~300+
Estimated time: 6-12 months of focused development
Result: Feature-complete, self-hosting compiler

