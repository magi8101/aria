/* TEST OF SYNTAX FROM ORIGINAL SPECS - PHASE 1 ONLY */
// Testing only features that should work with current parser implementation
// Phase 1: Basic variables, functions, arithmetic, return statements

// Simple variable declarations with initialization
int8:i = 9;
int32:value = 42;

// Function with parameters and return type
fn add(int32:a, int32:b) -> int32 {
    return a + b;
}

// Function with local variables
fn calculate(int32:x) -> int32 {
    int32:doubled = x + x;
    int32:result = doubled + 10;
    return result;
}

// Main function
fn main() -> int32 {
    int32:num1 = 42;
    int32:num2 = 10;
    int32:sum = add(num1, num2);
    int32:calc = calculate(sum);
    return calc;
}

/* FEATURES NOT YET IMPLEMENTED - COMMENTED OUT FOR FUTURE PHASES:

// Phase 2 needed: Loops
string:str = "whats up";
int8:c = 0;
int8[]arr; //empty array, cannot use without initializing properly
int8[256]arr2; //empty int8 array with 256 elements
int8[]:arr3=[100,300,550]; //3 element int8 array with values

//standard while loop
while(i < 100){
    print(`&{i}`);
    i++;
}

when(c <= i){
    print(`&{c}`);
    c++;
}then{
    print(`when loop ran c times`);
}end{
    print(`when loop did not run`);
}

//normal for for familiarity and ease transitioing to till or more advanced uses
for(int:i = 0; i < 100; i ++){
    print(`&{i}`); 
}

//automatically tracks iteration via $ variable
till(100,1){
    //print(`iteration: &{$}`)
    //should count up from 0 to 100 by 1
}
till(100,-1){
    //print(`iteration: &{$}`)
    //should count down from 100 to 0 by 1
}

//*matches any condition, ! means unreachable by match, labels optional but required for explicit fallthrough via fall(label), sorry, they dont get a normal switch this time. i was nice with the while lol. 
pick(c){
    (<9){
        fall(fail);
    },
    (>9){
        fall(fail);
    },
    (9){
        fall(success);
    },
    (*){
        fall(err);
    },
    fail:(!){
        //do fail stuff here
        fall(done);
    },
    success:(!){
        //do success stuff here
        fall(done);
    },
    err(!){
        //do error stuff here
        fall(done);
    },
    done:(!){
        //cleanup or whatever
    }
}

result:r;
int8:t;
int8:closureTest = 2;
func:test = (int8:a,int8:b){
    return {
        err:NULL,
        val:a*b*closureTest;
    }
};
r=test(3,4);
t = is r.err == NULL : r.val : -1; //t should be 24 if closure worked
func:test2 = (func:tt,int:a,int:b){
    return tt(a,b);//should return { err:NULL,val:24} with input of 3,4
};
r=test2(3,4);
t = is r.err == NULL :r.val : -1; //t should be 24 if closure worked
t = test2(3,5) ? -1; //use unwrap operator to abvoid above

dyn:d = "bob";
d = 4; 
d = true;
d= -2;

wild int64:s=100000;
wild int64@:t = @s; //@ address or pointer operator
wild int8:u = #d; //# memory pinning operator

obj:config = {
    version:"0.0.5",
    name:"Aria",
    highTime:420
}

*/
