// Test Standard Integer Types (research_012)
// All integer types use modular arithmetic (wrap-around on overflow)
// Two's complement for signed, pure binary for unsigned

func:main = int8() {
    // ===== SUB-BYTE SIGNED INTEGERS (int1, int2, int4) =====
    // int1: range is {-1, 0} only (NOT {-1, 0, 1}!)
    // int2: range is [-2, 1]
    // int4: range is [-8, 7]
    
    int1:bit_val = 0;        // Valid: 0
    // int1:bad = 1;         // Would wrap to -1
    
    int2:two_bit = -2;       // Valid: -2 to 1
    int4:nibble = 7;         // Valid: -8 to 7
    
    // ===== STANDARD SIGNED INTEGERS =====
    // All use two's complement, modular arithmetic
    
    int8:byte_val = 127;            // Range: [-128, 127]
    int8:byte_neg = -128;
    int8:byte_overflow = 128;       // Wraps to -128 (modular arithmetic)
    
    int16:short_val = 32767;        // Range: [-32768, 32767]
    int16:short_neg = -32768;
    
    int32:int_val = 2147483647;     // Range: [-2147483648, 2147483647]
    int32:int_neg = -2147483648;
    
    int64:long_val = 9223372036854775807;   // Range: [-2^63, 2^63-1]
    
    // ===== WIDE SIGNED INTEGERS =====
    // int128, int256, int512 for cryptographic operations
    // No heap-allocated BigInt needed - first-class types!
    
    int128:wide128 = 170141183460469231731687303715884105727;  // 2^127 - 1
    int256:wide256 = 100;  // Cryptographic key material
    int512:wide512 = 42;   // ECC operations, hashing
    
    // ===== UNSIGNED INTEGERS =====
    // Pure binary representation, range [0, 2^N - 1]
    // Mandatory for bitwise operations (&, |, ^, <<, >>)
    
    uint8:ubyte = 255;              // Range: [0, 255]
    uint16:ushort = 65535;          // Range: [0, 65535]
    uint32:uint = 4294967295;       // Range: [0, 2^32-1]
    uint64:ulong = 18446744073709551615;  // Range: [0, 2^64-1]
    
    // Wide unsigned integers
    uint128:uwide128 = 100;
    uint256:uwide256 = 200;  // Cryptographic operations
    uint512:uwide512 = 300;  // Storage addressing, UUIDs
    
    // ===== MODULAR ARITHMETIC DEMONSTRATION =====
    // Unlike TBB types (which saturate or ERR), standard ints wrap
    
    int8:a = 100;
    int8:b = 50;
    int8:wrapped = a + b;    // 150 overflows → wraps to -106
    
    uint8:ua = 200;
    uint8:ub = 100;
    uint8:uwrapped = ua + ub;  // 300 overflows → wraps to 44
    
    // ===== BITWISE OPERATIONS =====
    // Use unsigned types for bitwise ops to avoid sign extension
    
    uint8:mask = 0xFF;
    uint8:bits = 0xA5;
    uint8:and_result = bits & mask;     // 0xA5
    uint8:or_result = bits | 0x0F;      // 0xAF
    uint8:xor_result = bits ^ 0xFF;     // 0x5A
    uint8:shift_left = bits << 2;       // 0x94 (left shift)
    uint8:shift_right = bits >> 2;      // 0x29 (logical right shift)
    
    // ===== TYPE SAFETY: SIGNED vs UNSIGNED =====
    // Signed right shift is arithmetic (sign extends)
    // Unsigned right shift is logical (zero fills)
    
    int8:signed_neg = -8;              // 0xF8
    int8:arith_shift = signed_neg >> 1; // -4 (0xFC, sign extended)
    
    uint8:unsigned_val = 248;           // 0xF8 (same bit pattern)
    uint8:logic_shift = unsigned_val >> 1;  // 124 (0x7C, zero filled)
    
    return 0;
};
