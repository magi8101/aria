// ara.aria
// Aria Runtime Assembler (ARA)
// x86-64 machine code generation for wildx memory
// NASM-style fluent API using pipeline operators

// ============================================================================
// Register Constants (System V AMD64 ABI)
// ============================================================================

const int8:REG_RAX = 0;   // Accumulator / Return Value
const int8:REG_RCX = 1;   // Counter / 4th Argument  
const int8:REG_RDX = 2;   // Data / 3rd Argument
const int8:REG_RBX = 3;   // Base / Callee-Saved
const int8:REG_RSP = 4;   // Stack Pointer
const int8:REG_RBP = 5;   // Base Pointer / Callee-Saved
const int8:REG_RSI = 6;   // Source Index / 2nd Argument
const int8:REG_RDI = 7;   // Destination Index / 1st Argument
const int8:REG_R8  = 8;   // Extended General Purpose
const int8:REG_R9  = 9;   // Extended General Purpose
const int8:REG_R10 = 10;  // Extended General Purpose
const int8:REG_R11 = 11;  // Extended General Purpose
const int8:REG_R12 = 12;  // Extended General Purpose
const int8:REG_R13 = 13;  // Extended General Purpose
const int8:REG_R14 = 14;  // Extended General Purpose
const int8:REG_R15 = 15;  // Extended General Purpose

// ============================================================================
// Operand Type Constants
// ============================================================================

const int8:OP_REG = 0;  // Register operand (e.g., RAX)
const int8:OP_MEM = 1;  // Memory operand (e.g., [RAX])
const int8:OP_IMM = 2;  // Immediate operand (e.g., 0x10)

// ============================================================================
// Data Structures
// ============================================================================

// Operand - Unified representation for register, memory, and immediate operands
struct Operand {
    int8: type,        // OP_REG, OP_MEM, or OP_IMM
    int8: reg_index,   // Register index (0-15)
    int8: base,        // Base register for memory addressing
    int8: index,       // Index register for SIB
    int8: scale,       // Scale factor (0=1x, 1=2x, 2=4x, 3=8x)
    int32: disp,       // 32-bit displacement
    int64: imm,        // 64-bit immediate value
    bool: is_rel       // Flag for RIP-relative addressing
}

// Fixup - Forward reference for label backpatching
struct Fixup {
    // TODO: Need string type support
    // For now we'll use a simplified approach
    uint64: label_id,      // Numeric label identifier
    uint64: patch_offset,  // Location in buffer to patch
    int8: instr_size       // Instruction size for RIP calculation
}

// Assembler - Main assembler state
struct Assembler {
    wildx uint8@: buffer_ptr,  // Executable buffer
    uint64: capacity,          // Total buffer size
    uint64: cursor,            // Current write position
    // TODO: Add label map and fixup array when we have collections
    uint64: label_count        // Number of labels defined
}

// ============================================================================
// Operand Construction Helpers
// ============================================================================

// Create a register operand
func:reg = Operand(int8:r) {
    Operand:op = {
        type: OP_REG,
        reg_index: r,
        base: 0,
        index: 0,
        scale: 0,
        disp: 0,
        imm: 0,
        is_rel: false
    };
    return op;
};

// Create an immediate operand
func:imm = Operand(int64:val) {
    Operand:op = {
        type: OP_IMM,
        reg_index: 0,
        base: 0,
        index: 0,
        scale: 0,
        disp: 0,
        imm: val,
        is_rel: false
    };
    return op;
};

// Create a memory operand [base]
func:mem = Operand(int8:base) {
    Operand:op = {
        type: OP_MEM,
        reg_index: 0,
        base: base,
        index: 4,  // 4 = 'none' in SIB logic
        scale: 0,
        disp: 0,
        imm: 0,
        is_rel: false
    };
    return op;
};

// Create a memory operand with displacement [base + disp]
func:mem_disp = Operand(int8:base, int32:disp) {
    Operand:op = {
        type: OP_MEM,
        reg_index: 0,
        base: base,
        index: 4,
        scale: 0,
        disp: disp,
        imm: 0,
        is_rel: false
    };
    return op;
};

// ============================================================================
// Low-Level Byte Emission
// ============================================================================

// Write a single byte to the wildx buffer
func:emit_byte = void(Assembler:asm, uint8:val) {
    if (asm.cursor >= asm.capacity) {
        // Buffer overflow - would need error handling
        return;
    }
    
    // Calculate target address and write
    wildx uint8@:ptr = asm.buffer_ptr + asm.cursor;
    *ptr = val;
    
    // Advance cursor
    asm.cursor = asm.cursor + 1;
};

// Emit 32-bit value (little-endian)
func:emit_u32 = void(Assembler:asm, uint32:val) {
    emit_byte(asm, (uint8)(val & 0xFF));
    emit_byte(asm, (uint8)((val >> 8) & 0xFF));
    emit_byte(asm, (uint8)((val >> 16) & 0xFF));
    emit_byte(asm, (uint8)((val >> 24) & 0xFF));
};

// Emit 64-bit value (little-endian)
func:emit_u64 = void(Assembler:asm, uint64:val) {
    emit_u32(asm, (uint32)(val & 0xFFFFFFFF));
    emit_u32(asm, (uint32)((val >> 32) & 0xFFFFFFFF));
};

// ============================================================================
// REX Prefix Logic
// ============================================================================

// Emit REX prefix (0x40 + WRXB)
// w: 64-bit operand width
// r_idx: Register field register (or opcode extension)
// rm_idx: R/M field register
// idx_idx: Index field register (for SIB)
func:emit_rex = void(Assembler:asm, bool:w, int8:r_idx, int8:rm_idx, int8:idx_idx) {
    bool:r = (r_idx > 7);
    bool:b = (rm_idx > 7);
    bool:x = (idx_idx > 7);
    
    // Only emit REX if necessary
    if (w | r | b | x) {
        uint8:rex = 0x40;
        if (w) { rex = rex | 0x08; }
        if (r) { rex = rex | 0x04; }
        if (x) { rex = rex | 0x02; }
        if (b) { rex = rex | 0x01; }
        emit_byte(asm, rex);
    }
};

// ============================================================================
// ModR/M and SIB Encoding
// ============================================================================

// Emit ModR/M byte
// Format: [Mod:2][Reg:3][R/M:3]
func:emit_modrm = void(Assembler:asm, int8:reg, int8:rm, int8:mod) {
    uint8:byte = ((uint8)(mod & 3) << 6) | ((uint8)(reg & 7) << 3) | (uint8)(rm & 7);
    emit_byte(asm, byte);
};

// Emit SIB byte
// Format: [Scale:2][Index:3][Base:3]
func:emit_sib = void(Assembler:asm, int8:scale, int8:index, int8:base) {
    uint8:byte = ((uint8)(scale & 3) << 6) | ((uint8)(index & 7) << 3) | (uint8)(base & 7);
    emit_byte(asm, byte);
};

// ============================================================================
// High-Level Instruction Encoding
// ============================================================================

// MOV instruction
func:mov = Assembler(Assembler:asm, Operand:dst, Operand:src) {
    // MOV r64, imm64 (Opcode: B8+r)
    if (dst.type == OP_REG) {
        if (src.type == OP_IMM) {
            emit_rex(asm, true, 0, dst.reg_index, 0);
            emit_byte(asm, 0xB8 + (uint8)(dst.reg_index & 7));
            emit_u64(asm, (uint64)src.imm);
            return asm;
        }
    }
    
    // MOV r64, r64 (Opcode: 89)
    if (dst.type == OP_REG) {
        if (src.type == OP_REG) {
            emit_rex(asm, true, src.reg_index, dst.reg_index, 0);
            emit_byte(asm, 0x89);
            emit_modrm(asm, src.reg_index, dst.reg_index, 3);
            return asm;
        }
    }
    
    return asm;
};

// ADD instruction
func:add = Assembler(Assembler:asm, Operand:dst, Operand:src) {
    // ADD r64, r64 (Opcode: 01)
    if (dst.type == OP_REG) {
        if (src.type == OP_REG) {
            emit_rex(asm, true, src.reg_index, dst.reg_index, 0);
            emit_byte(asm, 0x01);
            emit_modrm(asm, src.reg_index, dst.reg_index, 3);
            return asm;
        }
    }
    
    // ADD r64, imm8 (Opcode: 83 /0)
    if (dst.type == OP_REG) {
        if (src.type == OP_IMM) {
            if (src.imm >= -128) {
                if (src.imm <= 127) {
                    emit_rex(asm, true, 0, dst.reg_index, 0);
                    emit_byte(asm, 0x83);
                    emit_modrm(asm, 0, dst.reg_index, 3);
                    emit_byte(asm, (uint8)(src.imm & 0xFF));
                    return asm;
                }
            }
            
            // ADD r64, imm32 (Opcode: 81 /0)
            emit_rex(asm, true, 0, dst.reg_index, 0);
            emit_byte(asm, 0x81);
            emit_modrm(asm, 0, dst.reg_index, 3);
            emit_u32(asm, (uint32)src.imm);
            return asm;
        }
    }
    
    return asm;
};

// SUB instruction
func:sub = Assembler(Assembler:asm, Operand:dst, Operand:src) {
    // SUB r64, r64 (Opcode: 29)
    if (dst.type == OP_REG) {
        if (src.type == OP_REG) {
            emit_rex(asm, true, src.reg_index, dst.reg_index, 0);
            emit_byte(asm, 0x29);
            emit_modrm(asm, src.reg_index, dst.reg_index, 3);
            return asm;
        }
    }
    
    // SUB r64, imm8 (Opcode: 83 /5)
    if (dst.type == OP_REG) {
        if (src.type == OP_IMM) {
            if (src.imm >= -128) {
                if (src.imm <= 127) {
                    emit_rex(asm, true, 0, dst.reg_index, 0);
                    emit_byte(asm, 0x83);
                    emit_modrm(asm, 5, dst.reg_index, 3);
                    emit_byte(asm, (uint8)(src.imm & 0xFF));
                    return asm;
                }
            }
            
            // SUB r64, imm32 (Opcode: 81 /5)
            emit_rex(asm, true, 0, dst.reg_index, 0);
            emit_byte(asm, 0x81);
            emit_modrm(asm, 5, dst.reg_index, 3);
            emit_u32(asm, (uint32)src.imm);
            return asm;
        }
    }
    
    return asm;
};

// RET instruction (Opcode: C3)
func:ret = Assembler(Assembler:asm) {
    emit_byte(asm, 0xC3);
    return asm;
};

// SYSCALL instruction (Opcode: 0F 05)
func:syscall = Assembler(Assembler:asm) {
    emit_byte(asm, 0x0F);
    emit_byte(asm, 0x05);
    return asm;
};

// ============================================================================
// Assembler Initialization
// ============================================================================

// Create a new assembler with allocated wildx memory
// For now, this is a placeholder until mem module intrinsics work
func:create = Assembler(uint64:size) {
    // TODO: Use mem.alloc_exec once intrinsics are wired up
    wildx uint8@:buffer = 0;  // Placeholder
    
    Assembler:asm = {
        buffer_ptr: buffer,
        capacity: size,
        cursor: 0,
        label_count: 0
    };
    
    return asm;
};

// Seal the assembler (transition RW -> RX)
// For now, this is a placeholder
func:seal = void(Assembler:asm) {
    // TODO: Use mem.protect_exec once intrinsics are wired up
    // mem.protect_exec(asm.buffer_ptr, asm.capacity);
};
