// ara_inline.aria
// Inline Aria Runtime Assembler - Direct byte array manipulation
// No wildx globals, just demonstrates the encoding logic

// ============================================================================
// Register Constants
// ============================================================================

const int8:REG_RAX = 0;   const int8:REG_RCX = 1;   const int8:REG_RDX = 2;
const int8:REG_RBX = 3;   const int8:REG_RSP = 4;   const int8:REG_RBP = 5;
const int8:REG_RSI = 6;   const int8:REG_RDI = 7;   const int8:REG_R8  = 8;
const int8:REG_R9  = 9;   const int8:REG_R10 = 10;  const int8:REG_R11 = 11;
const int8:REG_R12 = 12;  const int8:REG_R13 = 13;  const int8:REG_R14 = 14;
const int8:REG_R15 = 15;

// ============================================================================
// Encoding Helpers - Return opcodes for manual emission
// ============================================================================

// Calculate REX prefix byte
func:calc_rex = *uint8(bool:w, int8:r_idx, int8:rm_idx) {
    bool:r = (r_idx > 7);
    bool:b = (rm_idx > 7);
    
    if (w | r | b) {
        uint8:rex = 0x40;
        if (w) { rex = rex | 0x08; }
        if (r) { rex = rex | 0x04; }
        if (b) { rex = rex | 0x01; }
        return rex;
    }
    
    return 0;  // No REX needed
};

// Calculate ModR/M byte
func:calc_modrm = *uint8(int8:reg, int8:rm, int8:mod) {
    uint8:byte = ((uint8)(mod & 3) << 6) | ((uint8)(reg & 7) << 3) | (uint8)(rm & 7);
    return byte;
};

// ============================================================================
// Show expected encoding for debugging
// ============================================================================

func:show_mov_r64_r64 = *void(int8:dst, int8:src) {
    print("MOV encoding:");
    
    uint8:rex = calc_rex(true, src, dst);
    if (rex != 0) {
        print("  REX:");
    }
    
    print("  Opcode: 0x89");
    
    uint8:modrm = calc_modrm(src, dst, 3);
    print("  ModR/M:");
};

func:show_add_r64_imm8 = *void(int8:dst, int8:imm) {
    print("ADD encoding:");
    
    uint8:rex = calc_rex(true, 0, dst);
    if (rex != 0) {
        print("  REX:");
    }
    
    print("  Opcode: 0x83");
    
    uint8:modrm = calc_modrm(0, dst, 3);
    print("  ModR/M:");
    print("  Imm8:");
};

func:show_sub_r64_imm8 = *void(int8:dst, int8:imm) {
    print("SUB encoding:");
    
    uint8:rex = calc_rex(true, 0, dst);
    if (rex != 0) {
        print("  REX:");
    }
    
    print("  Opcode: 0x83");
    
    uint8:modrm = calc_modrm(5, dst, 3);
    print("  ModR/M:");
    print("  Imm8:");
};

func:show_ret = *void() {
    print("RET encoding:");
    print("  Opcode: 0xC3");
};
