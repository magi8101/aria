// ara_simple.aria
// Simplified Aria Runtime Assembler (ARA)
// x86-64 machine code generation using current Aria features
// Works without struct support - uses flat encoding

// ============================================================================
// Register Constants (System V AMD64 ABI)
// ============================================================================

const int8:REG_RAX = 0;   const int8:REG_RCX = 1;   const int8:REG_RDX = 2;
const int8:REG_RBX = 3;   const int8:REG_RSP = 4;   const int8:REG_RBP = 5;
const int8:REG_RSI = 6;   const int8:REG_RDI = 7;   const int8:REG_R8  = 8;
const int8:REG_R9  = 9;   const int8:REG_R10 = 10;  const int8:REG_R11 = 11;
const int8:REG_R12 = 12;  const int8:REG_R13 = 13;  const int8:REG_R14 = 14;
const int8:REG_R15 = 15;

// ============================================================================
// Global Assembler State (Simplified)
// ============================================================================

wildx uint8@:g_asm_buffer = 0;  // The executable buffer
uint64:g_asm_cursor = 0;         // Current write position
uint64:g_asm_capacity = 0;       // Buffer size

// ============================================================================
// Initialization
// ============================================================================

func:asm_init = *void(uint64:size) {
    // TODO: Use mem.alloc_exec when intrinsics ready
    // For now, just a placeholder wildx buffer
    g_asm_buffer = 0;
    g_asm_capacity = size;
    g_asm_cursor = 0;
};

func:asm_get_cursor = *uint64() {
    return g_asm_cursor;
};

// ============================================================================
// Low-Level Byte Emission
// ============================================================================

func:emit_byte = *void(uint8:val) {
    if (g_asm_cursor >= g_asm_capacity) {
        return;  // Buffer overflow
    }
    
    wildx uint8@:ptr = g_asm_buffer + g_asm_cursor;
    *ptr = val;
    g_asm_cursor = g_asm_cursor + 1;
};

func:emit_u32 = *void(uint32:val) {
    emit_byte((uint8)(val & 0xFF));
    emit_byte((uint8)((val >> 8) & 0xFF));
    emit_byte((uint8)((val >> 16) & 0xFF));
    emit_byte((uint8)((val >> 24) & 0xFF));
};

func:emit_u64 = *void(uint64:val) {
    emit_u32((uint32)(val & 0xFFFFFFFF));
    emit_u32((uint32)((val >> 32) & 0xFFFFFFFF));
};

// ============================================================================
// REX Prefix
// ============================================================================

func:emit_rex = *void(bool:w, int8:r_idx, int8:rm_idx, int8:idx_idx) {
    bool:r = (r_idx > 7);
    bool:b = (rm_idx > 7);
    bool:x = (idx_idx > 7);
    
    if (w | r | b | x) {
        uint8:rex = 0x40;
        if (w) { rex = rex | 0x08; }
        if (r) { rex = rex | 0x04; }
        if (x) { rex = rex | 0x02; }
        if (b) { rex = rex | 0x01; }
        emit_byte(rex);
    }
};

// ============================================================================
// ModR/M Encoding
// ============================================================================

func:emit_modrm = *void(int8:reg, int8:rm, int8:mod) {
    uint8:byte = ((uint8)(mod & 3) << 6) | ((uint8)(reg & 7) << 3) | (uint8)(rm & 7);
    emit_byte(byte);
};

// ============================================================================
// Instructions
// ============================================================================

// MOV r64, r64
func:mov_r64_r64 = *void(int8:dst, int8:src) {
    emit_rex(true, src, dst, 0);
    emit_byte(0x89);  // MOV r/m64, r64
    emit_modrm(src, dst, 3);
};

// MOV r64, imm64
func:mov_r64_imm64 = *void(int8:dst, int64:imm) {
    emit_rex(true, 0, dst, 0);
    emit_byte(0xB8 + (uint8)(dst & 7));  // MOV r64, imm64
    emit_u64((uint64)imm);
};

// ADD r64, r64
func:add_r64_r64 = *void(int8:dst, int8:src) {
    emit_rex(true, src, dst, 0);
    emit_byte(0x01);  // ADD r/m64, r64
    emit_modrm(src, dst, 3);
};

// ADD r64, imm8
func:add_r64_imm8 = *void(int8:dst, int8:imm) {
    emit_rex(true, 0, dst, 0);
    emit_byte(0x83);  // ADD r/m64, imm8
    emit_modrm(0, dst, 3);  // /0 = ADD
    emit_byte((uint8)imm);
};

// ADD r64, imm32
func:add_r64_imm32 = *void(int8:dst, int32:imm) {
    emit_rex(true, 0, dst, 0);
    emit_byte(0x81);  // ADD r/m64, imm32
    emit_modrm(0, dst, 3);  // /0 = ADD
    emit_u32((uint32)imm);
};

// SUB r64, r64
func:sub_r64_r64 = *void(int8:dst, int8:src) {
    emit_rex(true, src, dst, 0);
    emit_byte(0x29);  // SUB r/m64, r64
    emit_modrm(src, dst, 3);
};

// SUB r64, imm8
func:sub_r64_imm8 = *void(int8:dst, int8:imm) {
    emit_rex(true, 0, dst, 0);
    emit_byte(0x83);  // SUB r/m64, imm8
    emit_modrm(5, dst, 3);  // /5 = SUB
    emit_byte((uint8)imm);
};

// SUB r64, imm32
func:sub_r64_imm32 = *void(int8:dst, int32:imm) {
    emit_rex(true, 0, dst, 0);
    emit_byte(0x81);  // SUB r/m64, imm32
    emit_modrm(5, dst, 3);  // /5 = SUB
    emit_u32((uint32)imm);
};

// RET
func:ret = *void() {
    emit_byte(0xC3);
};

// SYSCALL
func:syscall = *void() {
    emit_byte(0x0F);
    emit_byte(0x05);
};

// NOP
func:nop = *void() {
    emit_byte(0x90);
};

// ============================================================================
// Seal (Memory Protection)
// ============================================================================

func:seal = *void() {
    // TODO: Use mem.protect_exec when intrinsics ready
    // mem.protect_exec(g_asm_buffer, g_asm_capacity);
};
