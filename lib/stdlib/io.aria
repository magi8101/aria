// ============================================================================
// Aria Standard Library - File I/O Module
// ============================================================================
// Provides file operations: open, close, read, write, seek, tell
// Uses intrinsics for POSIX syscalls (open, close, read, write, lseek)
// ============================================================================

// File descriptor type (int32 wraps Unix file descriptor)
// Valid file descriptors are >= 0
// Error conditions return -1

// ============================================================================
// File Open Modes (for flags parameter)
// ============================================================================
// O_RDONLY = 0x0000    (Read only)
// O_WRONLY = 0x0001    (Write only)
// O_RDWR   = 0x0002    (Read and write)
// O_CREAT  = 0x0040    (Create if doesn't exist)
// O_TRUNC  = 0x0200    (Truncate to zero length)
// O_APPEND = 0x0400    (Append mode)
//
// Common combinations:
// - Read existing file:        0x0000 (O_RDONLY)
// - Write new file:            0x0241 (O_WRONLY | O_CREAT | O_TRUNC)
// - Append to file:            0x0441 (O_WRONLY | O_CREAT | O_APPEND)
// - Read/write existing:       0x0002 (O_RDWR)
// - Read/write create:         0x0042 (O_RDWR | O_CREAT)

// ============================================================================
// Seek Modes (for whence parameter)
// ============================================================================
// SEEK_SET = 0    (Seek from beginning of file)
// SEEK_CUR = 1    (Seek from current position)
// SEEK_END = 2    (Seek from end of file)

// ============================================================================
// Standard File Descriptors
// ============================================================================
int32:STDIN = 0;
int32:STDOUT = 1;
int32:STDERR = 2;

// ============================================================================
// File Operations
// ============================================================================

// Open a file
// Returns file descriptor on success (>= 0), -1 on error
// pathname: path to file (null-terminated string)
// flags: open mode flags (see above)
// mode: permissions for new files (e.g., 0x01B6 = 0644 octal = rw-r--r--)
func:open = int32(uint8@:pathname, int32:flags, int32:mode) {
    // intrinsic("syscall", 2, pathname, flags, mode) -> open syscall
    // For now, use intrinsic placeholder
    int32:fd = 0;
    fd = intrinsic_open(pathname, flags, mode);
    pass(fd);
};

// Close a file descriptor
// Returns 0 on success, -1 on error
func:close = int32(int32:fd) {
    int32:result = 0;
    result = intrinsic_close(fd);
    pass(result);
};

// Read from file descriptor
// Returns number of bytes read (0 = EOF, -1 = error)
// fd: file descriptor
// buffer: destination buffer
// count: number of bytes to read
func:read = int64(int32:fd, uint8@:buffer, uint64:count) {
    int64:bytes_read = 0;
    bytes_read = intrinsic_read(fd, buffer, count);
    pass(bytes_read);
};

// Write to file descriptor
// Returns number of bytes written (-1 = error)
// fd: file descriptor
// buffer: source buffer
// count: number of bytes to write
func:write = int64(int32:fd, uint8@:buffer, uint64:count) {
    int64:bytes_written = 0;
    bytes_written = intrinsic_write(fd, buffer, count);
    pass(bytes_written);
};

// Seek to position in file
// Returns new file position on success, -1 on error
// fd: file descriptor
// offset: offset in bytes
// whence: SEEK_SET (0), SEEK_CUR (1), or SEEK_END (2)
func:seek = int64(int32:fd, int64:offset, int32:whence) {
    int64:new_pos = 0;
    new_pos = intrinsic_lseek(fd, offset, whence);
    pass(new_pos);
};

// Get current file position
// Returns current position on success, -1 on error
func:tell = int64(int32:fd) {
    int64:pos = 0;
    pos = intrinsic_lseek(fd, 0, 1);
    pass(pos);
};

// ============================================================================
// Convenience Functions
// ============================================================================

// Open file for reading
// Returns file descriptor on success (>= 0), -1 on error
func:open_read = int32(uint8@:pathname) {
    result:fd = open(pathname, 0, 0);
    pass(fd.val);
};

// Open file for writing (create/truncate)
// Returns file descriptor on success (>= 0), -1 on error
// Creates with permissions 0644 (rw-r--r--)
func:open_write = int32(uint8@:pathname) {
    int32:flags = 0;
    flags = 0x0241;
    int32:mode = 0;
    mode = 0x01B6;
    result:fd = open(pathname, flags, mode);
    pass(fd.val);
};

// Open file for appending (create if needed)
// Returns file descriptor on success (>= 0), -1 on error
// Creates with permissions 0644 (rw-r--r--)
func:open_append = int32(uint8@:pathname) {
    int32:flags = 0;
    flags = 0x0441;
    int32:mode = 0;
    mode = 0x01B6;
    result:fd = open(pathname, flags, mode);
    pass(fd.val);
};

// Open file for read/write (create if needed)
// Returns file descriptor on success (>= 0), -1 on error
// Creates with permissions 0644 (rw-r--r--)
func:open_readwrite = int32(uint8@:pathname) {
    int32:flags = 0;
    flags = 0x0042;
    int32:mode = 0;
    mode = 0x01B6;
    result:fd = open(pathname, flags, mode);
    pass(fd.val);
};

// Seek to beginning of file
// Returns 0 on success, -1 on error
func:rewind = int64(int32:fd) {
    result:pos = seek(fd, 0, 0);
    pass(pos.val);
};

// Get file size
// Returns file size on success, -1 on error
// Preserves current file position
func:get_file_size = int64(int32:fd) {
    // Save current position
    result:current_pos = tell(fd);
    if (current_pos.val < 0) {
        pass(-1);
    }
    
    // Seek to end
    result:end_pos = seek(fd, 0, 2);
    if (end_pos.val < 0) {
        pass(-1);
    }
    
    // Restore original position
    result:restored = seek(fd, current_pos.val, 0);
    if (restored.val < 0) {
        pass(-1);
    }
    
    pass(end_pos.val);
};

// ============================================================================
// String I/O Helpers
// ============================================================================

// Write a null-terminated string to file descriptor
// Returns number of bytes written (-1 = error)
func:write_string = int64(int32:fd, uint8@:str) {
    // Calculate string length
    uint64:len = 0;
    uint64:i = 0;
    int8:ch = 0;
    
    // Find null terminator
    ch = (int8)str[i];
    while (ch != 0) {
        i += 1;
        ch = (int8)str[i];
    }
    len = i;
    
    // Write the string
    result:written = write(fd, str, len);
    pass(written.val);
};

// Print string to stdout
// Returns number of bytes written (-1 = error)
func:print_str = int64(uint8@:str) {
    result:written = write_string(1, str);
    pass(written.val);
};

// Print string to stderr
// Returns number of bytes written (-1 = error)
func:eprint_str = int64(uint8@:str) {
    result:written = write_string(2, str);
    pass(written.val);
};

// Read until newline or EOF
// Returns number of bytes read (0 = EOF, -1 = error)
// Reads up to max_len bytes, null-terminates the buffer
func:read_line = int64(int32:fd, uint8@:buffer, uint64:max_len) {
    uint64:i = 0;
    int64:bytes_read = 0;
    int8:ch = 0;
    
    // Read one byte at a time until newline or max length
    while (i < max_len) {
        uint64:offset = 0;
        offset = i;
        
        // Read single byte
        result:read_result = read(fd, buffer, 1);
        bytes_read = read_result.val;
        
        // Check for EOF or error
        if (bytes_read <= 0) {
            buffer[i] = 0;
            pass(i);
        }
        
        // Check for newline
        ch = (int8)buffer[i];
        if (ch == 10) {
            buffer[i] = 0;
            pass(i);
        }
        
        i += 1;
    }
    
    // Max length reached, null-terminate
    uint64:last = 0;
    last = max_len - 1;
    buffer[last] = 0;
    pass(i);
};

// ============================================================================
// Buffer I/O Helpers
// ============================================================================

// Read entire file into buffer
// Returns number of bytes read (-1 = error, -2 = file too large)
// buffer_size: maximum bytes to read (buffer capacity)
func:read_file = int64(uint8@:pathname, uint8@:buffer, uint64:buffer_size) {
    // Open file
    result:fd_result = open_read(pathname);
    int32:fd = 0;
    fd = fd_result.val;
    
    if (fd < 0) {
        pass(-1);
    }
    
    // Get file size
    result:size_result = get_file_size(fd);
    int64:file_size = 0;
    file_size = size_result.val;
    
    if (file_size < 0) {
        result:close_result = close(fd);
        pass(-1);
    }
    
    // Check if file fits in buffer
    uint64:size_u64 = 0;
    size_u64 = (uint64)file_size;
    if (size_u64 > buffer_size) {
        result:close_result = close(fd);
        pass(-2);
    }
    
    // Read entire file
    result:read_result = read(fd, buffer, size_u64);
    int64:bytes_read = 0;
    bytes_read = read_result.val;
    
    // Close file
    result:close_result = close(fd);
    
    pass(bytes_read);
};

// Write entire buffer to file
// Returns number of bytes written (-1 = error)
func:write_file = int64(uint8@:pathname, uint8@:buffer, uint64:buffer_size) {
    // Open file for writing
    result:fd_result = open_write(pathname);
    int32:fd = 0;
    fd = fd_result.val;
    
    if (fd < 0) {
        pass(-1);
    }
    
    // Write entire buffer
    result:write_result = write(fd, buffer, buffer_size);
    int64:bytes_written = 0;
    bytes_written = write_result.val;
    
    // Close file
    result:close_result = close(fd);
    
    pass(bytes_written);
};

// ============================================================================
// Notes on Intrinsics:
// ============================================================================
// The above code uses placeholder intrinsic calls that need to be implemented
// in the compiler's intrinsic system:
//
// intrinsic_open(pathname, flags, mode) -> syscall 2 on Linux (open)
// intrinsic_close(fd) -> syscall 3 on Linux (close)
// intrinsic_read(fd, buf, count) -> syscall 0 on Linux (read)
// intrinsic_write(fd, buf, count) -> syscall 1 on Linux (write)
// intrinsic_lseek(fd, offset, whence) -> syscall 8 on Linux (lseek)
//
// These map directly to POSIX syscalls and should be implemented as
// compiler intrinsics that generate the appropriate syscall instructions.
// ============================================================================
