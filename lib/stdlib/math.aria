// ============================================================================
// Aria Standard Library - Math Functions
// ============================================================================
// Core mathematical functions generated for all numeric types using macros
// Demonstrates metaprogramming-driven stdlib development
// ============================================================================

// ----------------------------------------------------------------------------
// Type List Macros - Define once, generate for all types
// ----------------------------------------------------------------------------

// Macro to generate abs() for a single type
%macro GEN_ABS 1
func:abs_%1 = *%1(%1:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};
%endmacro

// Macro to generate min() for a single type
%macro GEN_MIN 1
func:min_%1 = *%1(%1:a, %1:b) {
    if (a < b) {
        return a;
    }
    return b;
};
%endmacro

// Macro to generate max() for a single type
%macro GEN_MAX 1
func:max_%1 = *%1(%1:a, %1:b) {
    if (a > b) {
        return a;
    }
    return b;
};
%endmacro

// Macro to generate clamp() for a single type
%macro GEN_CLAMP 1
func:clamp_%1 = *%1(%1:value, %1:min_val, %1:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};
%endmacro

// ----------------------------------------------------------------------------
// Generate for Signed Integers: int8, int16, int32, int64
// ----------------------------------------------------------------------------

GEN_ABS(int8)
GEN_MIN(int8)
GEN_MAX(int8)
GEN_CLAMP(int8)

GEN_ABS(int16)
GEN_MIN(int16)
GEN_MAX(int16)
GEN_CLAMP(int16)

GEN_ABS(int32)
GEN_MIN(int32)
GEN_MAX(int32)
GEN_CLAMP(int32)

GEN_ABS(int64)
GEN_MIN(int64)
GEN_MAX(int64)
GEN_CLAMP(int64)

// ----------------------------------------------------------------------------
// Generate for Unsigned Integers: uint8, uint16, uint32, uint64
// Note: abs() for unsigned is identity function (always positive)
// ----------------------------------------------------------------------------

%macro GEN_ABS_UNSIGNED 1
func:abs_%1 = *%1(%1:value) {
    return value;
};
%endmacro

GEN_ABS_UNSIGNED(uint8)
GEN_MIN(uint8)
GEN_MAX(uint8)
GEN_CLAMP(uint8)

GEN_ABS_UNSIGNED(uint16)
GEN_MIN(uint16)
GEN_MAX(uint16)
GEN_CLAMP(uint16)

GEN_ABS_UNSIGNED(uint32)
GEN_MIN(uint32)
GEN_MAX(uint32)
GEN_CLAMP(uint32)

GEN_ABS_UNSIGNED(uint64)
GEN_MIN(uint64)
GEN_MAX(uint64)
GEN_CLAMP(uint64)

// ----------------------------------------------------------------------------
// Generate for Floating Point: flt32, flt64
// ----------------------------------------------------------------------------

GEN_ABS(flt32)
GEN_MIN(flt32)
GEN_MAX(flt32)
GEN_CLAMP(flt32)

GEN_ABS(flt64)
GEN_MIN(flt64)
GEN_MAX(flt64)
GEN_CLAMP(flt64)

// ----------------------------------------------------------------------------
// Floating Point Math Functions (using LLVM intrinsics)
// ----------------------------------------------------------------------------

// Square root - only for floating point types
%macro GEN_SQRT 1
func:sqrt_%1 = *%1(%1:value) {
    if (value < 0.0) {
        fail(1);  // Error: negative input
    }
    // LLVM intrinsic: llvm.sqrt.f32/f64
    %1:result_val = @llvm_sqrt_%1(value);
    return result_val;
};
%endmacro

// Floor - round down to nearest integer
%macro GEN_FLOOR 1
func:floor_%1 = *%1(%1:value) {
    // LLVM intrinsic: llvm.floor.f32/f64
    %1:result_val = @llvm_floor_%1(value);
    return result_val;
};
%endmacro

// Ceil - round up to nearest integer
%macro GEN_CEIL 1
func:ceil_%1 = *%1(%1:value) {
    // LLVM intrinsic: llvm.ceil.f32/f64
    %1:result_val = @llvm_ceil_%1(value);
    return result_val;
};
%endmacro

// Round - round to nearest integer (ties to even)
%macro GEN_ROUND 1
func:round_%1 = *%1(%1:value) {
    // LLVM intrinsic: llvm.round.f32/f64
    %1:result_val = @llvm_round_%1(value);
    return result_val;
};
%endmacro

// Trunc - round toward zero (remove fractional part)
%macro GEN_TRUNC 1
func:trunc_%1 = *%1(%1:value) {
    // LLVM intrinsic: llvm.trunc.f32/f64
    %1:result_val = @llvm_trunc_%1(value);
    return result_val;
};
%endmacro

// Power function - x^y
%macro GEN_POW 1
func:pow_%1 = *%1(%1:base, %1:exponent) {
    // LLVM intrinsic: llvm.pow.f32/f64
    %1:result_val = @llvm_pow_%1(base, exponent);
    return result_val;
};
%endmacro

// Generate floating point math functions
GEN_SQRT(flt32)
GEN_FLOOR(flt32)
GEN_CEIL(flt32)
GEN_ROUND(flt32)
GEN_TRUNC(flt32)
GEN_POW(flt32)

GEN_SQRT(flt64)
GEN_FLOOR(flt64)
GEN_CEIL(flt64)
GEN_ROUND(flt64)
GEN_TRUNC(flt64)
GEN_POW(flt64)

// ----------------------------------------------------------------------------
// Integer Power Function (for int types without floating point)
// ----------------------------------------------------------------------------

%macro GEN_POW_INT 1
func:pow_%1 = *%1(%1:base, %1:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    %1:result_val = 1;
    %1:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};
%endmacro

// Generate integer power functions
GEN_POW_INT(int8)
GEN_POW_INT(int16)
GEN_POW_INT(int32)
GEN_POW_INT(int64)
GEN_POW_INT(uint8)
GEN_POW_INT(uint16)
GEN_POW_INT(uint32)
GEN_POW_INT(uint64)

// ----------------------------------------------------------------------------
// Integer Square Root (for int types)
// Using Newton's method for integer approximation
// ----------------------------------------------------------------------------

%macro GEN_ISQRT 1
func:isqrt_%1 = *%1(%1:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    %1:x = n;
    %1:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};
%endmacro

// Generate for signed integers
GEN_ISQRT(int8)
GEN_ISQRT(int16)
GEN_ISQRT(int32)
GEN_ISQRT(int64)

// For unsigned, always valid input
%macro GEN_ISQRT_UNSIGNED 1
func:isqrt_%1 = *%1(%1:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    %1:x = n;
    %1:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};
%endmacro

GEN_ISQRT_UNSIGNED(uint8)
GEN_ISQRT_UNSIGNED(uint16)
GEN_ISQRT_UNSIGNED(uint32)
GEN_ISQRT_UNSIGNED(uint64)

// ============================================================================
// Summary:
// Basic functions: 4 functions × 14 types = 56 variants
// Float math: 6 functions × 2 types = 12 variants (sqrt, floor, ceil, round, trunc, pow)
// Integer power: 1 function × 8 types = 8 variants
// Integer sqrt: 1 function × 8 types = 8 variants
// Total: 84 function variants from ~15 macro definitions
// - Type-safe, no runtime overhead
// - Demonstrating macro-driven stdlib development with LLVM intrinsics
// ============================================================================
