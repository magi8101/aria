#include "frontend/parser/parser.h"
#include <sstream>

using namespace aria;
using namespace aria::frontend;

// Operator precedence table (higher = tighter binding)
const std::unordered_map<TokenType, int> Parser::precedence = {
    // Assignment (lowest precedence)
    {TokenType::ASSIGN, 0},
    {TokenType::PLUS_ASSIGN, 0},
    {TokenType::MINUS_ASSIGN, 0},
    {TokenType::MULT_ASSIGN, 0},
    {TokenType::DIV_ASSIGN, 0},
    {TokenType::MOD_ASSIGN, 0},
    
    // Ternary
    {TokenType::TERNARY_IS, 1},
    {TokenType::QUESTION, 1},
    
    // Null coalescing
    {TokenType::NULL_COALESCE, 2},
    
    // Logical OR
    {TokenType::LOGICAL_OR, 3},
    
    // Logical AND
    {TokenType::LOGICAL_AND, 4},
    
    // Bitwise OR
    {TokenType::BITWISE_OR, 5},
    
    // Bitwise XOR
    {TokenType::BITWISE_XOR, 6},
    
    // Bitwise AND
    {TokenType::BITWISE_AND, 7},
    
    // Equality
    {TokenType::EQUAL, 8},
    {TokenType::NOT_EQUAL, 8},
    
    // Comparison
    {TokenType::LESS_THAN, 9},
    {TokenType::LESS_EQUAL, 9},
    {TokenType::GREATER_THAN, 9},
    {TokenType::GREATER_EQUAL, 9},
    {TokenType::SPACESHIP, 9},
    
    // Range
    {TokenType::RANGE_INCLUSIVE, 10},
    {TokenType::RANGE_EXCLUSIVE, 10},
    
    // Shift
    {TokenType::LEFT_SHIFT, 11},
    {TokenType::RIGHT_SHIFT, 11},
    
    // Additive
    {TokenType::PLUS, 12},
    {TokenType::MINUS, 12},
    
    // Multiplicative
    {TokenType::MULTIPLY, 13},
    {TokenType::DIVIDE, 13},
    {TokenType::MODULO, 13},
    
    // Pipeline
    {TokenType::PIPE_FORWARD, 14},
    {TokenType::PIPE_BACKWARD, 14},
    
    // Postfix (handled specially)
    {TokenType::INCREMENT, 16},
    {TokenType::DECREMENT, 16},
    {TokenType::LEFT_PAREN, 16},    // Function call
    {TokenType::LEFT_BRACKET, 16},  // Array index
    {TokenType::DOT, 16},            // Member access
    {TokenType::ARROW, 16},          // Pointer member
    {TokenType::SAFE_NAV, 16},       // Safe navigation
};

Parser::Parser(const std::vector<Token>& tokens)
    : tokens(tokens), current(0) {}

// Utility methods
Token Parser::peek() const {
    if (current < tokens.size()) {
        return tokens[current];
    }
    return tokens.back(); // Return EOF
}

Token Parser::previous() const {
    if (current > 0) {
        return tokens[current - 1];
    }
    return tokens[0];
}

Token Parser::advance() {
    if (!isAtEnd()) {
        current++;
    }
    return previous();
}

bool Parser::isAtEnd() const {
    return peek().type == TokenType::EOF_TOKEN;
}

bool Parser::check(TokenType type) const {
    if (isAtEnd()) return false;
    return peek().type == type;
}

bool Parser::match(TokenType type) {
    if (check(type)) {
        advance();
        return true;
    }
    return false;
}

bool Parser::match(const std::vector<TokenType>& types) {
    for (TokenType type : types) {
        if (check(type)) {
            advance();
            return true;
        }
    }
    return false;
}

Token Parser::consume(TokenType type, const std::string& message) {
    if (check(type)) {
        return advance();
    }
    error(message);
    return peek();
}

void Parser::error(const std::string& message) {
    Token token = peek();
    std::stringstream ss;
    ss << "Parse error at line " << token.line << ", column " << token.column 
       << ": " << message;
    errors.push_back(ss.str());
}

void Parser::synchronize() {
    advance();
    
    while (!isAtEnd()) {
        if (previous().type == TokenType::SEMICOLON) return;
        
        switch (peek().type) {
            case TokenType::FUNC:
            case TokenType::IF:
            case TokenType::WHILE:
            case TokenType::FOR:
            case TokenType::RETURN:
            case TokenType::BREAK:
            case TokenType::CONTINUE:
                return;
            default:
                advance();
        }
    }
}

int Parser::getPrecedence(TokenType type) const {
    auto it = precedence.find(type);
    if (it != precedence.end()) {
        return it->second;
    }
    return -1; // Not an operator
}

bool Parser::isBinaryOperator(TokenType type) const {
    return getPrecedence(type) >= 0 && getPrecedence(type) <= 14;
}

bool Parser::isUnaryOperator(TokenType type) const {
    return type == TokenType::MINUS || 
           type == TokenType::LOGICAL_NOT ||
           type == TokenType::BITWISE_NOT ||
           type == TokenType::ADDRESS ||
           type == TokenType::PIN ||
           type == TokenType::ITERATION;
}

bool Parser::isAssignmentOperator(TokenType type) const {
    return type == TokenType::ASSIGN ||
           type == TokenType::PLUS_ASSIGN ||
           type == TokenType::MINUS_ASSIGN ||
           type == TokenType::MULT_ASSIGN ||
           type == TokenType::DIV_ASSIGN ||
           type == TokenType::MOD_ASSIGN;
}

// Expression parsing (precedence climbing algorithm)
ASTNodePtr Parser::parseExpression(int minPrecedence) {
    // Start with unary or primary
    ASTNodePtr left = parseUnary();
    
    if (!left) return nullptr;
    
    // Handle postfix operators
    left = parsePostfix(left);
    
    // Climb precedence for binary operators
    while (!isAtEnd()) {
        Token op = peek();
        int prec = getPrecedence(op.type);
        
        if (prec < minPrecedence) break;
        
        // Special case: ternary operator
        if (op.type == TokenType::TERNARY_IS) {
            advance(); // consume 'is'
            ASTNodePtr condition = left;
            consume(TokenType::QUESTION, "Expected '?' after 'is' condition");
            ASTNodePtr trueExpr = parseExpression(prec + 1);
            consume(TokenType::COLON, "Expected ':' in ternary expression");
            ASTNodePtr falseExpr = parseExpression(prec);
            
            left = std::make_shared<TernaryExpr>(
                condition, trueExpr, falseExpr,
                op.line, op.column
            );
            continue;
        }
        
        // Binary operator
        if (isBinaryOperator(op.type)) {
            advance(); // consume operator
            ASTNodePtr right = parseExpression(prec + 1);
            
            if (!right) {
                error("Expected expression after operator");
                return nullptr;
            }
            
            left = std::make_shared<BinaryExpr>(
                left, op, right,
                op.line, op.column
            );
            continue;
        }
        
        break;
    }
    
    return left;
}

ASTNodePtr Parser::parsePrimary() {
    Token token = peek();
    
    // Integer literal
    if (token.type == TokenType::INTEGER_LITERAL) {
        advance();
        int64_t value = std::stoll(token.lexeme);
        return std::make_shared<LiteralExpr>(value, token.line, token.column);
    }
    
    // Float literal
    if (token.type == TokenType::FLOAT_LITERAL) {
        advance();
        double value = std::stod(token.lexeme);
        return std::make_shared<LiteralExpr>(value, token.line, token.column);
    }
    
    // String literal
    if (token.type == TokenType::STRING_LITERAL) {
        advance();
        return std::make_shared<LiteralExpr>(token.lexeme, token.line, token.column);
    }
    
    // Boolean literal
    if (token.type == TokenType::TRUE || token.type == TokenType::FALSE) {
        advance();
        bool value = (token.type == TokenType::TRUE);
        return std::make_shared<LiteralExpr>(value, token.line, token.column);
    }
    
    // Null literal
    if (token.type == TokenType::NULL_LITERAL) {
        advance();
        return std::make_shared<LiteralExpr>(token.line, token.column);
    }
    
    // Identifier
    if (token.type == TokenType::IDENTIFIER) {
        advance();
        return std::make_shared<IdentifierExpr>(token.lexeme, token.line, token.column);
    }
    
    // Parenthesized expression
    if (token.type == TokenType::LEFT_PAREN) {
        advance();
        ASTNodePtr expr = parseExpression();
        consume(TokenType::RIGHT_PAREN, "Expected ')' after expression");
        return expr;
    }
    
    // Array literal
    if (token.type == TokenType::LEFT_BRACKET) {
        return parseArrayLiteral();
    }
    
    // Object literal
    if (token.type == TokenType::LEFT_BRACE) {
        return parseObjectLiteral();
    }
    
    // Template literal
    if (token.type == TokenType::TEMPLATE_LITERAL) {
        return parseTemplateLiteral();
    }
    
    error("Expected expression");
    return nullptr;
}

ASTNodePtr Parser::parseUnary() {
    Token token = peek();
    
    if (isUnaryOperator(token.type)) {
        advance();
        ASTNodePtr operand = parseUnary(); // Right-associative
        
        if (!operand) {
            error("Expected expression after unary operator");
            return nullptr;
        }
        
        return std::make_shared<UnaryExpr>(token, operand, token.line, token.column);
    }
    
    return parsePrimary();
}

ASTNodePtr Parser::parsePostfix(ASTNodePtr expr) {
    while (!isAtEnd()) {
        Token token = peek();
        
        // Function call
        if (token.type == TokenType::LEFT_PAREN) {
            expr = parseCallExpression(expr);
            continue;
        }
        
        // Array index
        if (token.type == TokenType::LEFT_BRACKET) {
            expr = parseIndexExpression(expr);
            continue;
        }
        
        // Member access or safe navigation
        if (token.type == TokenType::DOT || 
            token.type == TokenType::ARROW ||
            token.type == TokenType::SAFE_NAV) {
            expr = parseMemberExpression(expr);
            continue;
        }
        
        // Postfix increment/decrement
        if (token.type == TokenType::INCREMENT || token.type == TokenType::DECREMENT) {
            advance();
            expr = std::make_shared<UnaryExpr>(token, expr, true, token.line, token.column);
            continue;
        }
        
        // Unwrap operator
        if (token.type == TokenType::UNWRAP) {
            advance();
            // For now, treat as unary postfix operator
            Token unwrapOp = token;
            expr = std::make_shared<UnaryExpr>(unwrapOp, expr, true, token.line, token.column);
            continue;
        }
        
        break;
    }
    
    return expr;
}

ASTNodePtr Parser::parseCallExpression(ASTNodePtr callee) {
    Token leftParen = advance(); // consume '('
    
    std::vector<ASTNodePtr> arguments;
    
    if (!check(TokenType::RIGHT_PAREN)) {
        do {
            ASTNodePtr arg = parseExpression();
            if (arg) {
                arguments.push_back(arg);
            }
        } while (match(TokenType::COMMA));
    }
    
    consume(TokenType::RIGHT_PAREN, "Expected ')' after function arguments");
    
    return std::make_shared<CallExpr>(callee, arguments, leftParen.line, leftParen.column);
}

ASTNodePtr Parser::parseIndexExpression(ASTNodePtr array) {
    Token leftBracket = advance(); // consume '['
    
    ASTNodePtr index = parseExpression();
    if (!index) {
        error("Expected index expression");
        return array;
    }
    
    consume(TokenType::RIGHT_BRACKET, "Expected ']' after array index");
    
    return std::make_shared<IndexExpr>(array, index, leftBracket.line, leftBracket.column);
}

ASTNodePtr Parser::parseMemberExpression(ASTNodePtr object) {
    Token op = advance(); // consume '.', '->', or '?.'
    
    bool isPointerAccess = (op.type == TokenType::ARROW);
    bool isSafeNav = (op.type == TokenType::SAFE_NAV);
    
    Token memberToken = consume(TokenType::IDENTIFIER, "Expected member name after '.' or '->'");
    std::string memberName = memberToken.lexeme;
    
    auto memberExpr = std::make_shared<MemberAccessExpr>(
        object, memberName, isPointerAccess,
        op.line, op.column
    );
    
    // TODO: Handle safe navigation differently if needed
    return memberExpr;
}

ASTNodePtr Parser::parseArrayLiteral() {
    Token leftBracket = advance(); // consume '['
    
    std::vector<ASTNodePtr> elements;
    
    if (!check(TokenType::RIGHT_BRACKET)) {
        do {
            ASTNodePtr element = parseExpression();
            if (element) {
                elements.push_back(element);
            }
        } while (match(TokenType::COMMA));
    }
    
    consume(TokenType::RIGHT_BRACKET, "Expected ']' after array elements");
    
    return std::make_shared<ArrayLiteralExpr>(elements, leftBracket.line, leftBracket.column);
}

ASTNodePtr Parser::parseObjectLiteral() {
    // Stub for now - will implement in later phase
    error("Object literals not yet implemented");
    return nullptr;
}

ASTNodePtr Parser::parseTemplateLiteral() {
    // Stub for now - will implement in later phase
    error("Template literals not yet implemented");
    return nullptr;
}

ASTNodePtr Parser::parseLambda() {
    // Stub for now - will implement in Phase 2.3
    error("Lambda expressions not yet implemented");
    return nullptr;
}

ASTNodePtr Parser::parse() {
    // For now, just parse a single expression
    // In Phase 2.2, we'll parse full programs with statements
    
    if (isAtEnd()) {
        return std::make_shared<ProgramNode>(std::vector<ASTNodePtr>(), 0, 0);
    }
    
    // Parse single expression for testing
    ASTNodePtr expr = parseExpression();
    
    // Wrap in program node
    std::vector<ASTNodePtr> declarations;
    if (expr) {
        declarations.push_back(expr);
    }
    
    return std::make_shared<ProgramNode>(declarations, 0, 0);
}

bool Parser::hasErrors() const {
    return !errors.empty();
}

const std::vector<std::string>& Parser::getErrors() const {
    return errors;
}
